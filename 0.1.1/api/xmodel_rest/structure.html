<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel_rest.structure API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xmodel_rest.structure</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import TypeVar, List, Tuple, Iterable, Union

from .default_model_urls import DefaultModelURLs
from xurls.url import URLStr
from xmodel import Field
from xmodel.remote import RemoteStructure
from xsentinels import Default
from xurls import HTTPGet, HTTPPatch, HTTPDelete, URL


F = TypeVar(&#34;F&#34;, bound=Field)


class RestStructure(RemoteStructure[F]):
    &#34;&#34;&#34;
    Rest version fo base `xynlib.orm.base.structure.BaseStructure` class.
    Adds extra common attributes that are used by:

    - `xynlib.orm.rest.api.RestApi`
    - `xynlib.orm.rest.client.RestClient`

    See `RestStructure.configure_for_model_type` for class arguments specific to Rest models.

    See [Basic BaseModel Example](../#basic-model-example) for an example of what class arguments
    are.

    See parent `xynlib.orm.base.structure.BaseStructure` for more options that are common among all
    model types (regardless if they are rest or dynamo).
    &#34;&#34;&#34;

    def configure_for_model_type(
            self,
            *,
            # todo: consider a different name for `base_url`, the structure object calls this
            #  attribute the `endpoint_base_url` right now.
            base_url: URLStr = Default,
            urls: List[URLStr] = Default,
            multiple_results_json_path: str = Default,
            **kwargs
    ):
        &#34;&#34;&#34;

        Args:
            **kwargs: For other/base arguments, see super-class method
                `xynlib.orm.base.structure.BaseStructure`.

            base_url (xynlib.url.URLStr): This is appended to
                `xynlib.orm.rest.settings.RestSettings.api_url` as urls
                are constructed from `urls` passed in to determine if the URL is valid and should
                be used.

            urls (List[xynlib.url.URLStr]): List of URL&#39;s to traverse, in order.
                Generally speaking, the system will go though these URL&#39;s in order, the first valid
                URL that is found is the one that is selected. If you don&#39;t provide these then
                we use `DefaultModelURLs`.

                The `xynlib.url.URL.methods` are used to match up the operation, and then
                the URL is valid if it can be formatted with the avalaible information on
                the BaseModel or in URL query.

                Look at `xynlib.orm.rest.RestClient.url_for_endpoint` for more information about
                how the URL find/construction process takes place. This list eventually gets passed
                to the `xynlib.orm.rest.RestClient.url_for_endpoint` method.
                That method runs though this list and determines which URL to use.

                Look at `xynlib.url.URL.is_valid` for more information about how a URL is valid.

            multiple_results_json_path (str): Many API&#39;s have a key that is used to contain
                the results, specially if there are more than one of them.
                This allows for pagination and other meta data to be passed back in the response.
                The default value for this is `&#34;results&#34;`.
        &#34;&#34;&#34;
        super().configure_for_model_type(**kwargs)

        if multiple_results_json_path is not Default:
            self.multiple_results_json_path = multiple_results_json_path

        # Inherit from parent if Default.
        if base_url is not Default:
            self.base_model_url = base_url

        # We inherit the `urls` from parent if they are not provided directly by user.
        if urls is Default:
            if self.model_urls is None:
                self.model_urls = DefaultModelURLs
        else:
            self.model_urls = [*urls]

    multiple_results_json_path = &#34;results&#34;

    _base_model_url: URL = None

    @property
    def base_model_url(self) -&gt; URL:
        &#34;&#34;&#34;
        Used to store endpoint or the most common portion of all the endpoint urls.
        ie: &#39;point_events&#39;, or other such pieces of the URL.

        The endpoint is the part after the version and namespace in the context/base_path
        that client gets on init, eg: `/v1/presclub/{endpoint}`.

        Example:
          &#39;point_events&#39; could be returned, which could ultimately create this URL:
          /v1/presclub/point_events

          The `xynlib.orm.base.client.BaseClient` provides the version and namespace part of the
          `xynlib.url.URL`.
          So the proper RestClient combined with this endpoint method is how the URL is
          constructed.
        &#34;&#34;&#34;
        return self._base_model_url

    @base_model_url.setter
    def base_model_url(self, value: Union[URLStr, bool]):
        self._base_model_url = URL(value) if value else None

    _model_urls: Tuple[URL] = None

    @property
    def model_urls(self) -&gt; Tuple[URL]:
        &#34;&#34;&#34;
        If you need more than one endpoint url, use this. Every URL in this list will be appended
        to the `self.base_endpoint_url` when it&#39;s used.

        For more details on how the final url is found and constructed see
        `xynlib.orm.rest.RestClient.url_for_endpoint`.

        If you don&#39;t provide any endpoint_urls, then we will create a few standard ones
        automatically, such as &#34;/{id}&#34; (for getting a singular object via id).

        See `DefaultModelURLs` for the default list.

        When routing to the correct url, the first url that provides a valid path for the needed
        method + singular state will be used.  You can use path parameters, and order them to most
        specific to least specific, as we try to get a URL in the order they are defined.

        See:

        - `xynlib.url.URL`: for more details on how path formatting, methods, singular work.
        - `xynlib.orm.rest.RestClient.url_for_endpoint`: details on how final `xynlib.url.URL`
            is constructed.
        &#34;&#34;&#34;
        return self._model_urls

    @model_urls.setter
    def model_urls(self, value: Iterable[URLStr]):
        self._model_urls = tuple(URL.ensure_url(v).copy() for v in value) if value else None

    @property
    def have_api_endpoint(self) -&gt; bool:
        &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
            That&#39;s determined right now via seeing if we have any model_urls or not.

            .. todo:: Consider changing this to use
                `xynlib.orm.base.structure.BaseStructure.have_usable_id`
        &#34;&#34;&#34;
        return bool(self.model_urls)

    @property
    def endpoint_description(self):
        return self.base_model_url</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel_rest.structure.RestStructure"><code class="flex name class">
<span>class <span class="ident">RestStructure</span></span>
<span>(</span><span>*, parent: Optional[ForwardRef('RemoteStructure')], field_type: Type[~F])</span>
</code></dt>
<dd>
<div class="desc"><p>Rest version fo base <code>xynlib.orm.base.structure.BaseStructure</code> class.
Adds extra common attributes that are used by:</p>
<ul>
<li><code>xynlib.orm.rest.api.RestApi</code></li>
<li><code>xynlib.orm.rest.client.RestClient</code></li>
</ul>
<p>See <code><a title="xmodel_rest.structure.RestStructure.configure_for_model_type" href="#xmodel_rest.structure.RestStructure.configure_for_model_type">RestStructure.configure_for_model_type()</a></code> for class arguments specific to Rest models.</p>
<p>See <a href="../#basic-model-example">Basic BaseModel Example</a> for an example of what class arguments
are.</p>
<p>See parent <code>xynlib.orm.base.structure.BaseStructure</code> for more options that are common among all
model types (regardless if they are rest or dynamo).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestStructure(RemoteStructure[F]):
    &#34;&#34;&#34;
    Rest version fo base `xynlib.orm.base.structure.BaseStructure` class.
    Adds extra common attributes that are used by:

    - `xynlib.orm.rest.api.RestApi`
    - `xynlib.orm.rest.client.RestClient`

    See `RestStructure.configure_for_model_type` for class arguments specific to Rest models.

    See [Basic BaseModel Example](../#basic-model-example) for an example of what class arguments
    are.

    See parent `xynlib.orm.base.structure.BaseStructure` for more options that are common among all
    model types (regardless if they are rest or dynamo).
    &#34;&#34;&#34;

    def configure_for_model_type(
            self,
            *,
            # todo: consider a different name for `base_url`, the structure object calls this
            #  attribute the `endpoint_base_url` right now.
            base_url: URLStr = Default,
            urls: List[URLStr] = Default,
            multiple_results_json_path: str = Default,
            **kwargs
    ):
        &#34;&#34;&#34;

        Args:
            **kwargs: For other/base arguments, see super-class method
                `xynlib.orm.base.structure.BaseStructure`.

            base_url (xynlib.url.URLStr): This is appended to
                `xynlib.orm.rest.settings.RestSettings.api_url` as urls
                are constructed from `urls` passed in to determine if the URL is valid and should
                be used.

            urls (List[xynlib.url.URLStr]): List of URL&#39;s to traverse, in order.
                Generally speaking, the system will go though these URL&#39;s in order, the first valid
                URL that is found is the one that is selected. If you don&#39;t provide these then
                we use `DefaultModelURLs`.

                The `xynlib.url.URL.methods` are used to match up the operation, and then
                the URL is valid if it can be formatted with the avalaible information on
                the BaseModel or in URL query.

                Look at `xynlib.orm.rest.RestClient.url_for_endpoint` for more information about
                how the URL find/construction process takes place. This list eventually gets passed
                to the `xynlib.orm.rest.RestClient.url_for_endpoint` method.
                That method runs though this list and determines which URL to use.

                Look at `xynlib.url.URL.is_valid` for more information about how a URL is valid.

            multiple_results_json_path (str): Many API&#39;s have a key that is used to contain
                the results, specially if there are more than one of them.
                This allows for pagination and other meta data to be passed back in the response.
                The default value for this is `&#34;results&#34;`.
        &#34;&#34;&#34;
        super().configure_for_model_type(**kwargs)

        if multiple_results_json_path is not Default:
            self.multiple_results_json_path = multiple_results_json_path

        # Inherit from parent if Default.
        if base_url is not Default:
            self.base_model_url = base_url

        # We inherit the `urls` from parent if they are not provided directly by user.
        if urls is Default:
            if self.model_urls is None:
                self.model_urls = DefaultModelURLs
        else:
            self.model_urls = [*urls]

    multiple_results_json_path = &#34;results&#34;

    _base_model_url: URL = None

    @property
    def base_model_url(self) -&gt; URL:
        &#34;&#34;&#34;
        Used to store endpoint or the most common portion of all the endpoint urls.
        ie: &#39;point_events&#39;, or other such pieces of the URL.

        The endpoint is the part after the version and namespace in the context/base_path
        that client gets on init, eg: `/v1/presclub/{endpoint}`.

        Example:
          &#39;point_events&#39; could be returned, which could ultimately create this URL:
          /v1/presclub/point_events

          The `xynlib.orm.base.client.BaseClient` provides the version and namespace part of the
          `xynlib.url.URL`.
          So the proper RestClient combined with this endpoint method is how the URL is
          constructed.
        &#34;&#34;&#34;
        return self._base_model_url

    @base_model_url.setter
    def base_model_url(self, value: Union[URLStr, bool]):
        self._base_model_url = URL(value) if value else None

    _model_urls: Tuple[URL] = None

    @property
    def model_urls(self) -&gt; Tuple[URL]:
        &#34;&#34;&#34;
        If you need more than one endpoint url, use this. Every URL in this list will be appended
        to the `self.base_endpoint_url` when it&#39;s used.

        For more details on how the final url is found and constructed see
        `xynlib.orm.rest.RestClient.url_for_endpoint`.

        If you don&#39;t provide any endpoint_urls, then we will create a few standard ones
        automatically, such as &#34;/{id}&#34; (for getting a singular object via id).

        See `DefaultModelURLs` for the default list.

        When routing to the correct url, the first url that provides a valid path for the needed
        method + singular state will be used.  You can use path parameters, and order them to most
        specific to least specific, as we try to get a URL in the order they are defined.

        See:

        - `xynlib.url.URL`: for more details on how path formatting, methods, singular work.
        - `xynlib.orm.rest.RestClient.url_for_endpoint`: details on how final `xynlib.url.URL`
            is constructed.
        &#34;&#34;&#34;
        return self._model_urls

    @model_urls.setter
    def model_urls(self, value: Iterable[URLStr]):
        self._model_urls = tuple(URL.ensure_url(v).copy() for v in value) if value else None

    @property
    def have_api_endpoint(self) -&gt; bool:
        &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
            That&#39;s determined right now via seeing if we have any model_urls or not.

            .. todo:: Consider changing this to use
                `xynlib.orm.base.structure.BaseStructure.have_usable_id`
        &#34;&#34;&#34;
        return bool(self.model_urls)

    @property
    def endpoint_description(self):
        return self.base_model_url</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></li>
<li><a title="xmodel.base.structure.BaseStructure" href="../xmodel/base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.structure.RestStructure.api_options"><code class="name">var <span class="ident">api_options</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.api_options" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure.api_options">api_options</a></code>
</p>
<div class="desc inherited"><p>When defined at class (in a subclass) level: …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.field_type"><code class="name">var <span class="ident">field_type</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.field_type" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.field_type">field_type</a></code>
</p>
<div class="desc inherited"><p>Field type that this structure will use when auto-generating <code>xmodel.fields.Field</code>'s.
User defined Fields on a model-class will keep whatever type the …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.internal_shared_api_values"><code class="name">var <span class="ident">internal_shared_api_values</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.internal_shared_api_values" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.internal_shared_api_values">internal_shared_api_values</a></code>
</p>
<div class="desc inherited"><p>A place an <code><a title="xmodel.base.api.BaseApi" href="../xmodel/base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> object can use to share values BaseModel-class wide
(ie: for all BaseModel's of a specific type) …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.max_query_by_id"><code class="name">var <span class="ident">max_query_by_id</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.max_query_by_id" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure.max_query_by_id">max_query_by_id</a></code>
</p>
<div class="desc inherited"><p>You can easily change this per-model via model class argument <code>max_query_by_id</code>
(see <code>RemoteStructure.configure_for_model_type</code> for more details) …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.model_cls"><code class="name">var <span class="ident">model_cls</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.model_cls" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.model_cls">model_cls</a></code>
</p>
<div class="desc inherited"><p>The model's class we are defining the structure for.
This is typed as some sort of <code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
.
This is NOT generically typed …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.multiple_results_json_path"><code class="name">var <span class="ident">multiple_results_json_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel_rest.structure.RestStructure.base_model_url"><code class="name">var <span class="ident">base_model_url</span> : <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a></code></dt>
<dd>
<div class="desc"><p>Used to store endpoint or the most common portion of all the endpoint urls.
ie: 'point_events', or other such pieces of the URL.</p>
<p>The endpoint is the part after the version and namespace in the context/base_path
that client gets on init, eg: <code>/v1/presclub/{endpoint}</code>.</p>
<h2 id="example">Example</h2>
<p>'point_events' could be returned, which could ultimately create this URL:
/v1/presclub/point_events</p>
<p>The <code>xynlib.orm.base.client.BaseClient</code> provides the version and namespace part of the
<code>xynlib.url.URL</code>.
So the proper RestClient combined with this endpoint method is how the URL is
constructed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_model_url(self) -&gt; URL:
    &#34;&#34;&#34;
    Used to store endpoint or the most common portion of all the endpoint urls.
    ie: &#39;point_events&#39;, or other such pieces of the URL.

    The endpoint is the part after the version and namespace in the context/base_path
    that client gets on init, eg: `/v1/presclub/{endpoint}`.

    Example:
      &#39;point_events&#39; could be returned, which could ultimately create this URL:
      /v1/presclub/point_events

      The `xynlib.orm.base.client.BaseClient` provides the version and namespace part of the
      `xynlib.url.URL`.
      So the proper RestClient combined with this endpoint method is how the URL is
      constructed.
    &#34;&#34;&#34;
    return self._base_model_url</code></pre>
</details>
</dd>
<dt id="xmodel_rest.structure.RestStructure.endpoint_description"><code class="name">var <span class="ident">endpoint_description</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.endpoint_description" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.endpoint_description">endpoint_description</a></code>
</p>
<div class="desc inherited"><p>Gives some sort of basic descriptive string that contains the path/table-name/etc
that basically indicates the api endpoint being used …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endpoint_description(self):
    return self.base_model_url</code></pre>
</details>
</dd>
<dt id="xmodel_rest.structure.RestStructure.field_map"><code class="name">var <span class="ident">field_map</span> : Mapping[str, ~F]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.field_map" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.field_map">field_map</a></code>
</p>
<div class="desc inherited"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Map of <code>xmodel.fields.Field.name</code> to
<code>xmodel.fields.Field</code> objects.</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.fields"><code class="name">var <span class="ident">fields</span> : List[~F]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.fields" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.fields">fields</a></code>
</p>
<div class="desc inherited"><p>Returns:
List[xmodel.fields.Field]: list of field objects.</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.have_api_endpoint"><code class="name">var <span class="ident">have_api_endpoint</span> : bool</code></dt>
<dd>
<div class="desc"><p>Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
That's determined right now via seeing if we have any model_urls or not.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Consider changing this to use
<code>xynlib.orm.base.structure.BaseStructure.have_usable_id</code></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def have_api_endpoint(self) -&gt; bool:
    &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
        That&#39;s determined right now via seeing if we have any model_urls or not.

        .. todo:: Consider changing this to use
            `xynlib.orm.base.structure.BaseStructure.have_usable_id`
    &#34;&#34;&#34;
    return bool(self.model_urls)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.structure.RestStructure.model_urls"><code class="name">var <span class="ident">model_urls</span> : Tuple[<a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>]</code></dt>
<dd>
<div class="desc"><p>If you need more than one endpoint url, use this. Every URL in this list will be appended
to the <code>self.base_endpoint_url</code> when it's used.</p>
<p>For more details on how the final url is found and constructed see
<code>xynlib.orm.rest.RestClient.url_for_endpoint</code>.</p>
<p>If you don't provide any endpoint_urls, then we will create a few standard ones
automatically, such as "/{id}" (for getting a singular object via id).</p>
<p>See <code>DefaultModelURLs</code> for the default list.</p>
<p>When routing to the correct url, the first url that provides a valid path for the needed
method + singular state will be used.
You can use path parameters, and order them to most
specific to least specific, as we try to get a URL in the order they are defined.</p>
<p>See:</p>
<ul>
<li><code>xynlib.url.URL</code>: for more details on how path formatting, methods, singular work.</li>
<li><code>xynlib.orm.rest.RestClient.url_for_endpoint</code>: details on how final <code>xynlib.url.URL</code>
is constructed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model_urls(self) -&gt; Tuple[URL]:
    &#34;&#34;&#34;
    If you need more than one endpoint url, use this. Every URL in this list will be appended
    to the `self.base_endpoint_url` when it&#39;s used.

    For more details on how the final url is found and constructed see
    `xynlib.orm.rest.RestClient.url_for_endpoint`.

    If you don&#39;t provide any endpoint_urls, then we will create a few standard ones
    automatically, such as &#34;/{id}&#34; (for getting a singular object via id).

    See `DefaultModelURLs` for the default list.

    When routing to the correct url, the first url that provides a valid path for the needed
    method + singular state will be used.  You can use path parameters, and order them to most
    specific to least specific, as we try to get a URL in the order they are defined.

    See:

    - `xynlib.url.URL`: for more details on how path formatting, methods, singular work.
    - `xynlib.orm.rest.RestClient.url_for_endpoint`: details on how final `xynlib.url.URL`
        is constructed.
    &#34;&#34;&#34;
    return self._model_urls</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.structure.RestStructure.configure_for_model_type"><code class="name flex">
<span>def <span class="ident">configure_for_model_type</span></span>(<span>self, *, base_url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = Default, urls: List[Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]] = Default, multiple_results_json_path: str = Default, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>For other/base arguments, see super-class method
<code>xynlib.orm.base.structure.BaseStructure</code>.</dd>
<dt><strong><code>base_url</code></strong> :&ensp;<code>xynlib.url.URLStr</code></dt>
<dd>This is appended to
<code>xynlib.orm.rest.settings.RestSettings.api_url</code> as urls
are constructed from <code>urls</code> passed in to determine if the URL is valid and should
be used.</dd>
<dt><strong><code>urls</code></strong> :&ensp;<code>List[xynlib.url.URLStr]</code></dt>
<dd>
<p>List of URL's to traverse, in order.
Generally speaking, the system will go though these URL's in order, the first valid
URL that is found is the one that is selected. If you don't provide these then
we use <code>DefaultModelURLs</code>.</p>
<p>The <code>xynlib.url.URL.methods</code> are used to match up the operation, and then
the URL is valid if it can be formatted with the avalaible information on
the BaseModel or in URL query.</p>
<p>Look at <code>xynlib.orm.rest.RestClient.url_for_endpoint</code> for more information about
how the URL find/construction process takes place. This list eventually gets passed
to the <code>xynlib.orm.rest.RestClient.url_for_endpoint</code> method.
That method runs though this list and determines which URL to use.</p>
<p>Look at <code>xynlib.url.URL.is_valid</code> for more information about how a URL is valid.</p>
</dd>
<dt><strong><code>multiple_results_json_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Many API's have a key that is used to contain
the results, specially if there are more than one of them.
This allows for pagination and other meta data to be passed back in the response.
The default value for this is <code>"results"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_for_model_type(
        self,
        *,
        # todo: consider a different name for `base_url`, the structure object calls this
        #  attribute the `endpoint_base_url` right now.
        base_url: URLStr = Default,
        urls: List[URLStr] = Default,
        multiple_results_json_path: str = Default,
        **kwargs
):
    &#34;&#34;&#34;

    Args:
        **kwargs: For other/base arguments, see super-class method
            `xynlib.orm.base.structure.BaseStructure`.

        base_url (xynlib.url.URLStr): This is appended to
            `xynlib.orm.rest.settings.RestSettings.api_url` as urls
            are constructed from `urls` passed in to determine if the URL is valid and should
            be used.

        urls (List[xynlib.url.URLStr]): List of URL&#39;s to traverse, in order.
            Generally speaking, the system will go though these URL&#39;s in order, the first valid
            URL that is found is the one that is selected. If you don&#39;t provide these then
            we use `DefaultModelURLs`.

            The `xynlib.url.URL.methods` are used to match up the operation, and then
            the URL is valid if it can be formatted with the avalaible information on
            the BaseModel or in URL query.

            Look at `xynlib.orm.rest.RestClient.url_for_endpoint` for more information about
            how the URL find/construction process takes place. This list eventually gets passed
            to the `xynlib.orm.rest.RestClient.url_for_endpoint` method.
            That method runs though this list and determines which URL to use.

            Look at `xynlib.url.URL.is_valid` for more information about how a URL is valid.

        multiple_results_json_path (str): Many API&#39;s have a key that is used to contain
            the results, specially if there are more than one of them.
            This allows for pagination and other meta data to be passed back in the response.
            The default value for this is `&#34;results&#34;`.
    &#34;&#34;&#34;
    super().configure_for_model_type(**kwargs)

    if multiple_results_json_path is not Default:
        self.multiple_results_json_path = multiple_results_json_path

    # Inherit from parent if Default.
    if base_url is not Default:
        self.base_model_url = base_url

    # We inherit the `urls` from parent if they are not provided directly by user.
    if urls is Default:
        if self.model_urls is None:
            self.model_urls = DefaultModelURLs
    else:
        self.model_urls = [*urls]</code></pre>
</details>
</dd>
<dt id="xmodel_rest.structure.RestStructure.excluded_field_map"><code class="name flex">
<span>def <span class="ident">excluded_field_map</span></span>(<span>self) ‑> Dict[str, ~F]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.excluded_field_map" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.excluded_field_map">excluded_field_map</a></code>
</p>
<div class="desc inherited"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Mapping of <code>xmodel.fields.Field.name</code> to
field objects that are excluded …</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.field_exists"><code class="name flex">
<span>def <span class="ident">field_exists</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.field_exists" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.field_exists">field_exists</a></code>
</p>
<div class="desc inherited"><p>Return <code>True</code> if the field with <code>name</code> exists on the model, otherwise <code>False</code>.</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, name: str) ‑> Optional[~F]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.get_field" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.get_field">get_field</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Field name to query on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xmodel.fields.Field</code></dt>
<dd>If field object exists with <code>name</code> …</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.get_unwraped_typehint"><code class="name flex">
<span>def <span class="ident">get_unwraped_typehint</span></span>(<span>self, field_name: str)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.get_unwraped_typehint" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.get_unwraped_typehint">get_unwraped_typehint</a></code>
</p>
<div class="desc inherited"><p>This is now done for you on <code>xmodel.fields.Field.type_hint</code>, so you can just grab it
directly your self now …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.has_id_field"><code class="name flex">
<span>def <span class="ident">has_id_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.has_id_field" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure.has_id_field">has_id_field</a></code>
</p>
<div class="desc inherited"><p>Defaults to False, returns True for RemoteStructure,
What this property is really saying is if you can do a foreign-key to the related
object/model …</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.id_cache_key"><code class="name flex">
<span>def <span class="ident">id_cache_key</span></span>(<span>self, _id)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.id_cache_key" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.id_cache_key">id_cache_key</a></code>
</p>
<div class="desc inherited"><p>Returns a proper key to use for <code>xmodel.base.client.BaseClient.cache_get</code>
and other caching methods for id-based lookup of an object.</p></div>
</dd>
<dt id="xmodel_rest.structure.RestStructure.is_field_a_child"><code class="name flex">
<span>def <span class="ident">is_field_a_child</span></span>(<span>self, child_field_name, *, and_has_id=False)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.is_field_a_child" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.is_field_a_child">is_field_a_child</a></code>
</p>
<div class="desc inherited"><p>True if the field is a child, otherwise False.
Will still return <code>False</code> if
<code>and_has_id</code> argument is <code>True</code> and the related type is configured to not …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xmodel_rest" href="index.html">xmodel_rest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel_rest.structure.RestStructure" href="#xmodel_rest.structure.RestStructure">RestStructure</a></code></h4>
<ul class="">
<li><code><a title="xmodel_rest.structure.RestStructure.api_options" href="../xmodel/remote/structure.html#xmodel_rest.structure.RestStructure.api_options">api_options</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.base_model_url" href="#xmodel_rest.structure.RestStructure.base_model_url">base_model_url</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.configure_for_model_type" href="#xmodel_rest.structure.RestStructure.configure_for_model_type">configure_for_model_type</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.endpoint_description" href="#xmodel_rest.structure.RestStructure.endpoint_description">endpoint_description</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.excluded_field_map" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.excluded_field_map">excluded_field_map</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.field_exists" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.field_exists">field_exists</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.field_map" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.field_map">field_map</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.field_type" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.field_type">field_type</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.fields" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.fields">fields</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.get_field" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.get_field">get_field</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.get_unwraped_typehint" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.get_unwraped_typehint">get_unwraped_typehint</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.has_id_field" href="../xmodel/remote/structure.html#xmodel_rest.structure.RestStructure.has_id_field">has_id_field</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.have_api_endpoint" href="#xmodel_rest.structure.RestStructure.have_api_endpoint">have_api_endpoint</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.id_cache_key" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.id_cache_key">id_cache_key</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.internal_shared_api_values" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.internal_shared_api_values">internal_shared_api_values</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.is_field_a_child" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.is_field_a_child">is_field_a_child</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.max_query_by_id" href="../xmodel/remote/structure.html#xmodel_rest.structure.RestStructure.max_query_by_id">max_query_by_id</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.model_cls" href="../xmodel/base/structure.html#xmodel_rest.structure.RestStructure.model_cls">model_cls</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.model_urls" href="#xmodel_rest.structure.RestStructure.model_urls">model_urls</a></code></li>
<li><code><a title="xmodel_rest.structure.RestStructure.multiple_results_json_path" href="#xmodel_rest.structure.RestStructure.multiple_results_json_path">multiple_results_json_path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>