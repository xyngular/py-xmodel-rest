<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel.remote.structure API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xmodel.remote.structure</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from copy import copy
from typing import TypeVar, Optional, Type

from xmodel import BaseStructure
from xmodel import Field
from xmodel.remote.options import ApiOptions

F = TypeVar(&#39;F&#39;, bound=Field)


class RemoteStructure(BaseStructure[F]):
    max_query_by_id = 100
    &#34;&#34;&#34;
    You can easily change this per-model via model class argument `max_query_by_id`
    (see `RemoteStructure.configure_for_model_type` for more details).

    Example of easily setting this per-model-class
    (using a more concrete class RestModel, which inherits from RemoteModel):

    &gt;&gt;&gt; from xmodel_rest import RestModel
    &gt;&gt;&gt; class MyRemote(RestModel, max_query_by_id=500)
    ...     pass


    ### More Details

    This is used as a hint to `xmodel.remote.model.RemoteModel.get_via_id`
    on how much to query at a time. It uses this method to split up into chunks
    a list of ID&#39;s as needed automatically.

    That way the outside user can just pass in a list or generator function,
    that has many ID&#39;s. They will be chunked automatically into
    correct number to query for at a time.

    If you use a `1` for this, that means can only grab an object
    by it&#39;s id one at a time instead of in bulk.
    &#34;&#34;&#34;

    api_options: ApiOptions = None
    &#34;&#34;&#34;
    ## When defined at class (in a subclass) level:

    Set of default ApiOptions to apply to everything using the same structure class.
    These will be inherited. Anything directly set on ApiOptions will be inherited.

    If the Model class pass in an ApiOptions object as one of it&#39;s
    class parameters, anything specifically set on that object will override any defaults
    set on the BaseStructure subclass.

    Any subclasses of a particular structure class will also inherit any set api_options
    as you would expect.

    You can also change this on an already allocated BaseStructure or subclass.
    The class/parent inheritance only happens right when the object is constructued.
    Any already constructed BaseStructure or subclass, when an api_option is set,
    would only apply to the specific model-class the BaseStructure/subclass was allocated for.

    (Each model class gets a structure object instance, per-model-class).

    It&#39;s best to define these api_options at class-definition time
    (either for the structure or model); and not dynamically later to get consistent behavior.

    ## How to change Dynamically:

    If you want to change it dynamically, set the options via the Model types
    `xmodel.base.api.BaseApi.options`, ie: `MyModel.api.options.cache_by_id = True`.
    &#34;&#34;&#34;

    def configure_for_model_type(
        self,
        *,
        max_query_by_id: int = None,
        api_options: &#34;ApiOptions&#34; = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        Read super-class docs for more details at `xmodel.base.structure.BaseStructure`.

        But to summarize, we are passed any model-class-arguments that the user provided
        when they defined their RemoteModel sub-class as key-word arguments into
        us, the `configure_for_model_type` method your reading about here.

        The super-method of us also has basic things like `model_type`, `type_hints` and other
        basic ones that are calculated/collects and come from
        `xmodel.base.model.BaseModel.__init_subclass__`.

        We are only documenting the ones relevant to RemoteModel/RemoteStructure here,
        see BaseModel/BaseStructure for the more details.

        Args:
            max_query_by_id (int): If passed in, will set the max number of objects we can request
                by id in the same request at the same time. This is inherited from a super-class.

                If a super-class has not set it, will default to `100`.
                We will otherwise inherit whatever the number is from parent model
                object if it set it to something different.

                See `RemoteStructure.max_query_by_id`, we simply set that property in here.

                Example of easily setting this per-model-class
                (using a more concrete class RestModel, which inherits from RemoteModel):

                &gt;&gt;&gt; from xmodel_rest import RestModel
                &gt;&gt;&gt; class MyRemote(RestModel, max_query_by_id=500)
                ...     pass

                ### More Details

                This is used as a hint to `xmodel.remote.model.RemoteModel.get_via_id`
                on how much to query at a time. It uses this method to split up into chunks
                a list of ID&#39;s as needed automatically.

                That way the outside user can just pass in a list or generator function,
                that has many ID&#39;s. They will be chunked automatically into
                correct number to query for at a time.

                If you pass in a `1` to this method, that means can only grab an object
                by it&#39;s id one at a time instead of in bulk.


            api_options (xmodel.options.ApiOptions): Set of options to use for the API if you
                wanted to change something so the option is enabled/disabled by Default for
                this Model. Keep in mind that a user can override these defaults via
                `xmodel.base.api.BaseApi.options`.

        &#34;&#34;&#34;
        super().configure_for_model_type(**kwargs)

        if max_query_by_id is not None:
            self.max_query_by_id = max_query_by_id

        if api_options is not None:
            # We will get a copy of each attribute that api_options does not have set
            # but that the parent does.
            # todo: Look at this a bit more, I think we can come up with a better way
            #       perhaps with the new xsentinels `Default` type or some such.
            api_options.set_unset_values(self.api_options)
            self.api_options = api_options

    def __init__(
        self,
        *,
        parent: Optional[&#39;RemoteStructure&#39;],
        field_type: Type[F]
    ):
        old_options = copy(self.api_options)
        if not old_options:
            old_options = ApiOptions()
        self.api_options = old_options

        super().__init__(parent=parent, field_type=field_type)

        if parent:
            self.api_options = old_options
            self.api_options.set_unset_values(parent.api_options)

    def __copy__(self):
        obj = super().__copy__()
        obj.api_options = copy(self.api_options)
        return obj

    def has_id_field(self):
        # Hard-Coding to return True; for details on why see doc-comment
        # on `BaseStructure.has_id_field`. Leaving doc-comment empty here because pydoc3
        # will just copy/reuse doc-comment from parent BaseStructure that way.
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel.remote.structure.RemoteStructure"><code class="flex name class">
<span>class <span class="ident">RemoteStructure</span></span>
<span>(</span><span>*, parent: Optional[ForwardRef('<a title="xmodel.remote.structure.RemoteStructure" href="#xmodel.remote.structure.RemoteStructure">RemoteStructure</a>')], field_type: Type[~F])</span>
</code></dt>
<dd>
<div class="desc"><p>BaseStructure class is meant to keep track of things that apply for all
<code><a title="xmodel.base.model.BaseModel" href="../base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s at the class-level.</p>
<p>You can use <code>BaseStructure.fields</code> to get all fields for a particular
<code><a title="xmodel.base.model.BaseModel" href="../base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
as an example of the sort of information on the <code>BaseStructure</code> object.</p>
<p>BaseStructure is lazily configured for a particular BaseModel the first time something
attempts to get <code><a title="xmodel.base.model.BaseModel.api" href="../base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> off the particular BaseModel subclass.</p>
<p>You can get it via first getting api attribute for BaseModel via
<code><a title="xmodel.base.model.BaseModel.api" href="../base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> and then getting the structure attribute on that via
<code><a title="xmodel.base.api.BaseApi.structure" href="../base/api.html#xmodel.base.api.BaseApi.structure">BaseApi.structure</a></code>.</p>
<p>Example getting the structure object for the Account model/api:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt; structure = Account.api.structure
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RemoteStructure(BaseStructure[F]):
    max_query_by_id = 100
    &#34;&#34;&#34;
    You can easily change this per-model via model class argument `max_query_by_id`
    (see `RemoteStructure.configure_for_model_type` for more details).

    Example of easily setting this per-model-class
    (using a more concrete class RestModel, which inherits from RemoteModel):

    &gt;&gt;&gt; from xmodel_rest import RestModel
    &gt;&gt;&gt; class MyRemote(RestModel, max_query_by_id=500)
    ...     pass


    ### More Details

    This is used as a hint to `xmodel.remote.model.RemoteModel.get_via_id`
    on how much to query at a time. It uses this method to split up into chunks
    a list of ID&#39;s as needed automatically.

    That way the outside user can just pass in a list or generator function,
    that has many ID&#39;s. They will be chunked automatically into
    correct number to query for at a time.

    If you use a `1` for this, that means can only grab an object
    by it&#39;s id one at a time instead of in bulk.
    &#34;&#34;&#34;

    api_options: ApiOptions = None
    &#34;&#34;&#34;
    ## When defined at class (in a subclass) level:

    Set of default ApiOptions to apply to everything using the same structure class.
    These will be inherited. Anything directly set on ApiOptions will be inherited.

    If the Model class pass in an ApiOptions object as one of it&#39;s
    class parameters, anything specifically set on that object will override any defaults
    set on the BaseStructure subclass.

    Any subclasses of a particular structure class will also inherit any set api_options
    as you would expect.

    You can also change this on an already allocated BaseStructure or subclass.
    The class/parent inheritance only happens right when the object is constructued.
    Any already constructed BaseStructure or subclass, when an api_option is set,
    would only apply to the specific model-class the BaseStructure/subclass was allocated for.

    (Each model class gets a structure object instance, per-model-class).

    It&#39;s best to define these api_options at class-definition time
    (either for the structure or model); and not dynamically later to get consistent behavior.

    ## How to change Dynamically:

    If you want to change it dynamically, set the options via the Model types
    `xmodel.base.api.BaseApi.options`, ie: `MyModel.api.options.cache_by_id = True`.
    &#34;&#34;&#34;

    def configure_for_model_type(
        self,
        *,
        max_query_by_id: int = None,
        api_options: &#34;ApiOptions&#34; = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        Read super-class docs for more details at `xmodel.base.structure.BaseStructure`.

        But to summarize, we are passed any model-class-arguments that the user provided
        when they defined their RemoteModel sub-class as key-word arguments into
        us, the `configure_for_model_type` method your reading about here.

        The super-method of us also has basic things like `model_type`, `type_hints` and other
        basic ones that are calculated/collects and come from
        `xmodel.base.model.BaseModel.__init_subclass__`.

        We are only documenting the ones relevant to RemoteModel/RemoteStructure here,
        see BaseModel/BaseStructure for the more details.

        Args:
            max_query_by_id (int): If passed in, will set the max number of objects we can request
                by id in the same request at the same time. This is inherited from a super-class.

                If a super-class has not set it, will default to `100`.
                We will otherwise inherit whatever the number is from parent model
                object if it set it to something different.

                See `RemoteStructure.max_query_by_id`, we simply set that property in here.

                Example of easily setting this per-model-class
                (using a more concrete class RestModel, which inherits from RemoteModel):

                &gt;&gt;&gt; from xmodel_rest import RestModel
                &gt;&gt;&gt; class MyRemote(RestModel, max_query_by_id=500)
                ...     pass

                ### More Details

                This is used as a hint to `xmodel.remote.model.RemoteModel.get_via_id`
                on how much to query at a time. It uses this method to split up into chunks
                a list of ID&#39;s as needed automatically.

                That way the outside user can just pass in a list or generator function,
                that has many ID&#39;s. They will be chunked automatically into
                correct number to query for at a time.

                If you pass in a `1` to this method, that means can only grab an object
                by it&#39;s id one at a time instead of in bulk.


            api_options (xmodel.options.ApiOptions): Set of options to use for the API if you
                wanted to change something so the option is enabled/disabled by Default for
                this Model. Keep in mind that a user can override these defaults via
                `xmodel.base.api.BaseApi.options`.

        &#34;&#34;&#34;
        super().configure_for_model_type(**kwargs)

        if max_query_by_id is not None:
            self.max_query_by_id = max_query_by_id

        if api_options is not None:
            # We will get a copy of each attribute that api_options does not have set
            # but that the parent does.
            # todo: Look at this a bit more, I think we can come up with a better way
            #       perhaps with the new xsentinels `Default` type or some such.
            api_options.set_unset_values(self.api_options)
            self.api_options = api_options

    def __init__(
        self,
        *,
        parent: Optional[&#39;RemoteStructure&#39;],
        field_type: Type[F]
    ):
        old_options = copy(self.api_options)
        if not old_options:
            old_options = ApiOptions()
        self.api_options = old_options

        super().__init__(parent=parent, field_type=field_type)

        if parent:
            self.api_options = old_options
            self.api_options.set_unset_values(parent.api_options)

    def __copy__(self):
        obj = super().__copy__()
        obj.api_options = copy(self.api_options)
        return obj

    def has_id_field(self):
        # Hard-Coding to return True; for details on why see doc-comment
        # on `BaseStructure.has_id_field`. Leaving doc-comment empty here because pydoc3
        # will just copy/reuse doc-comment from parent BaseStructure that way.
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel_rest.structure.RestStructure" href="../../xmodel_rest/structure.html#xmodel_rest.structure.RestStructure">RestStructure</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.remote.structure.RemoteStructure.api_options"><code class="name">var <span class="ident">api_options</span> : <a title="xmodel.remote.options.ApiOptions" href="options.html#xmodel.remote.options.ApiOptions">ApiOptions</a></code></dt>
<dd>
<div class="desc"><h2 id="when-defined-at-class-in-a-subclass-level">When defined at class (in a subclass) level:</h2>
<p>Set of default ApiOptions to apply to everything using the same structure class.
These will be inherited. Anything directly set on ApiOptions will be inherited.</p>
<p>If the Model class pass in an ApiOptions object as one of it's
class parameters, anything specifically set on that object will override any defaults
set on the BaseStructure subclass.</p>
<p>Any subclasses of a particular structure class will also inherit any set api_options
as you would expect.</p>
<p>You can also change this on an already allocated BaseStructure or subclass.
The class/parent inheritance only happens right when the object is constructued.
Any already constructed BaseStructure or subclass, when an api_option is set,
would only apply to the specific model-class the BaseStructure/subclass was allocated for.</p>
<p>(Each model class gets a structure object instance, per-model-class).</p>
<p>It's best to define these api_options at class-definition time
(either for the structure or model); and not dynamically later to get consistent behavior.</p>
<h2 id="how-to-change-dynamically">How to change Dynamically:</h2>
<p>If you want to change it dynamically, set the options via the Model types
<code>xmodel.base.api.BaseApi.options</code>, ie: <code>MyModel.api.options.cache_by_id = True</code>.</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.field_type"><code class="name">var <span class="ident">field_type</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.field_type" href="../base/structure.html#xmodel.base.structure.BaseStructure.field_type">field_type</a></code>
</p>
<div class="desc inherited"><p>Field type that this structure will use when auto-generating <code>xmodel.fields.Field</code>'s.
User defined Fields on a model-class will keep whatever type the …</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.internal_shared_api_values"><code class="name">var <span class="ident">internal_shared_api_values</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.internal_shared_api_values" href="../base/structure.html#xmodel.base.structure.BaseStructure.internal_shared_api_values">internal_shared_api_values</a></code>
</p>
<div class="desc inherited"><p>A place an <code><a title="xmodel.base.api.BaseApi" href="../base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> object can use to share values BaseModel-class wide
(ie: for all BaseModel's of a specific type) …</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.max_query_by_id"><code class="name">var <span class="ident">max_query_by_id</span></code></dt>
<dd>
<div class="desc"><p>You can easily change this per-model via model class argument <code>max_query_by_id</code>
(see <code><a title="xmodel.remote.structure.RemoteStructure.configure_for_model_type" href="#xmodel.remote.structure.RemoteStructure.configure_for_model_type">RemoteStructure.configure_for_model_type()</a></code> for more details).</p>
<p>Example of easily setting this per-model-class
(using a more concrete class RestModel, which inherits from RemoteModel):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel_rest import RestModel
&gt;&gt;&gt; class MyRemote(RestModel, max_query_by_id=500)
...     pass
</code></pre>
<h3 id="more-details">More Details</h3>
<p>This is used as a hint to <code>xmodel.remote.model.RemoteModel.get_via_id</code>
on how much to query at a time. It uses this method to split up into chunks
a list of ID's as needed automatically.</p>
<p>That way the outside user can just pass in a list or generator function,
that has many ID's. They will be chunked automatically into
correct number to query for at a time.</p>
<p>If you use a <code>1</code> for this, that means can only grab an object
by it's id one at a time instead of in bulk.</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.model_cls"><code class="name">var <span class="ident">model_cls</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.model_cls" href="../base/structure.html#xmodel.base.structure.BaseStructure.model_cls">model_cls</a></code>
</p>
<div class="desc inherited"><p>The model's class we are defining the structure for.
This is typed as some sort of <code><a title="xmodel.base.model.BaseModel" href="../base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
.
This is NOT generically typed …</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.remote.structure.RemoteStructure.endpoint_description"><code class="name">var <span class="ident">endpoint_description</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.endpoint_description" href="../base/structure.html#xmodel.base.structure.BaseStructure.endpoint_description">endpoint_description</a></code>
</p>
<div class="desc inherited"><p>Gives some sort of basic descriptive string that contains the path/table-name/etc
that basically indicates the api endpoint being used …</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.field_map"><code class="name">var <span class="ident">field_map</span> : Mapping[str, ~F]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.field_map" href="../base/structure.html#xmodel.base.structure.BaseStructure.field_map">field_map</a></code>
</p>
<div class="desc inherited"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Map of <code>xmodel.fields.Field.name</code> to
<code>xmodel.fields.Field</code> objects.</dd>
</dl></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.fields"><code class="name">var <span class="ident">fields</span> : List[~F]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.fields" href="../base/structure.html#xmodel.base.structure.BaseStructure.fields">fields</a></code>
</p>
<div class="desc inherited"><p>Returns:
List[xmodel.fields.Field]: list of field objects.</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.have_api_endpoint"><code class="name">var <span class="ident">have_api_endpoint</span> : bool</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.have_api_endpoint" href="../base/structure.html#xmodel.base.structure.BaseStructure.have_api_endpoint">have_api_endpoint</a></code>
</p>
<div class="desc inherited"><p>Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
That's determined right now via seeing if …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.remote.structure.RemoteStructure.configure_for_model_type"><code class="name flex">
<span>def <span class="ident">configure_for_model_type</span></span>(<span>self, *, max_query_by_id: int = None, api_options: ApiOptions = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Read super-class docs for more details at <code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.</p>
<p>But to summarize, we are passed any model-class-arguments that the user provided
when they defined their RemoteModel sub-class as key-word arguments into
us, the <code>configure_for_model_type</code> method your reading about here.</p>
<p>The super-method of us also has basic things like <code>model_type</code>, <code>type_hints</code> and other
basic ones that are calculated/collects and come from
<code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="../base/model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code>.</p>
<p>We are only documenting the ones relevant to RemoteModel/RemoteStructure here,
see BaseModel/BaseStructure for the more details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>max_query_by_id</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>If passed in, will set the max number of objects we can request
by id in the same request at the same time. This is inherited from a super-class.</p>
<p>If a super-class has not set it, will default to <code>100</code>.
We will otherwise inherit whatever the number is from parent model
object if it set it to something different.</p>
<p>See <code><a title="xmodel.remote.structure.RemoteStructure.max_query_by_id" href="#xmodel.remote.structure.RemoteStructure.max_query_by_id">RemoteStructure.max_query_by_id</a></code>, we simply set that property in here.</p>
<p>Example of easily setting this per-model-class
(using a more concrete class RestModel, which inherits from RemoteModel):</p>
<blockquote>
<blockquote>
<blockquote>
<p>from xmodel_rest import RestModel
class MyRemote(RestModel, max_query_by_id=500)
&hellip;
pass</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="more-details">More Details</h3>
<p>This is used as a hint to <code>xmodel.remote.model.RemoteModel.get_via_id</code>
on how much to query at a time. It uses this method to split up into chunks
a list of ID's as needed automatically.</p>
<p>That way the outside user can just pass in a list or generator function,
that has many ID's. They will be chunked automatically into
correct number to query for at a time.</p>
<p>If you pass in a <code>1</code> to this method, that means can only grab an object
by it's id one at a time instead of in bulk.</p>
</dd>
<dt><strong><code>api_options</code></strong> :&ensp;<code>xmodel.options.ApiOptions</code></dt>
<dd>Set of options to use for the API if you
wanted to change something so the option is enabled/disabled by Default for
this Model. Keep in mind that a user can override these defaults via
<code>xmodel.base.api.BaseApi.options</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_for_model_type(
    self,
    *,
    max_query_by_id: int = None,
    api_options: &#34;ApiOptions&#34; = None,
    **kwargs
):
    &#34;&#34;&#34;
    Read super-class docs for more details at `xmodel.base.structure.BaseStructure`.

    But to summarize, we are passed any model-class-arguments that the user provided
    when they defined their RemoteModel sub-class as key-word arguments into
    us, the `configure_for_model_type` method your reading about here.

    The super-method of us also has basic things like `model_type`, `type_hints` and other
    basic ones that are calculated/collects and come from
    `xmodel.base.model.BaseModel.__init_subclass__`.

    We are only documenting the ones relevant to RemoteModel/RemoteStructure here,
    see BaseModel/BaseStructure for the more details.

    Args:
        max_query_by_id (int): If passed in, will set the max number of objects we can request
            by id in the same request at the same time. This is inherited from a super-class.

            If a super-class has not set it, will default to `100`.
            We will otherwise inherit whatever the number is from parent model
            object if it set it to something different.

            See `RemoteStructure.max_query_by_id`, we simply set that property in here.

            Example of easily setting this per-model-class
            (using a more concrete class RestModel, which inherits from RemoteModel):

            &gt;&gt;&gt; from xmodel_rest import RestModel
            &gt;&gt;&gt; class MyRemote(RestModel, max_query_by_id=500)
            ...     pass

            ### More Details

            This is used as a hint to `xmodel.remote.model.RemoteModel.get_via_id`
            on how much to query at a time. It uses this method to split up into chunks
            a list of ID&#39;s as needed automatically.

            That way the outside user can just pass in a list or generator function,
            that has many ID&#39;s. They will be chunked automatically into
            correct number to query for at a time.

            If you pass in a `1` to this method, that means can only grab an object
            by it&#39;s id one at a time instead of in bulk.


        api_options (xmodel.options.ApiOptions): Set of options to use for the API if you
            wanted to change something so the option is enabled/disabled by Default for
            this Model. Keep in mind that a user can override these defaults via
            `xmodel.base.api.BaseApi.options`.

    &#34;&#34;&#34;
    super().configure_for_model_type(**kwargs)

    if max_query_by_id is not None:
        self.max_query_by_id = max_query_by_id

    if api_options is not None:
        # We will get a copy of each attribute that api_options does not have set
        # but that the parent does.
        # todo: Look at this a bit more, I think we can come up with a better way
        #       perhaps with the new xsentinels `Default` type or some such.
        api_options.set_unset_values(self.api_options)
        self.api_options = api_options</code></pre>
</details>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.excluded_field_map"><code class="name flex">
<span>def <span class="ident">excluded_field_map</span></span>(<span>self) ‑> Dict[str, ~F]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.excluded_field_map" href="../base/structure.html#xmodel.base.structure.BaseStructure.excluded_field_map">excluded_field_map</a></code>
</p>
<div class="desc inherited"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Mapping of <code>xmodel.fields.Field.name</code> to
field objects that are excluded …</dd>
</dl></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.field_exists"><code class="name flex">
<span>def <span class="ident">field_exists</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.field_exists" href="../base/structure.html#xmodel.base.structure.BaseStructure.field_exists">field_exists</a></code>
</p>
<div class="desc inherited"><p>Return <code>True</code> if the field with <code>name</code> exists on the model, otherwise <code>False</code>.</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, name: str) ‑> Optional[~F]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.get_field" href="../base/structure.html#xmodel.base.structure.BaseStructure.get_field">get_field</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Field name to query on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xmodel.fields.Field</code></dt>
<dd>If field object exists with <code>name</code> …</dd>
</dl></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.get_unwraped_typehint"><code class="name flex">
<span>def <span class="ident">get_unwraped_typehint</span></span>(<span>self, field_name: str)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.get_unwraped_typehint" href="../base/structure.html#xmodel.base.structure.BaseStructure.get_unwraped_typehint">get_unwraped_typehint</a></code>
</p>
<div class="desc inherited"><p>This is now done for you on <code>xmodel.fields.Field.type_hint</code>, so you can just grab it
directly your self now …</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.has_id_field"><code class="name flex">
<span>def <span class="ident">has_id_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.has_id_field" href="../base/structure.html#xmodel.base.structure.BaseStructure.has_id_field">has_id_field</a></code>
</p>
<div class="desc inherited"><p>Defaults to False, returns True for RemoteStructure,
What this property is really saying is if you can do a foreign-key to the related
object/model …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_id_field(self):
    # Hard-Coding to return True; for details on why see doc-comment
    # on `BaseStructure.has_id_field`. Leaving doc-comment empty here because pydoc3
    # will just copy/reuse doc-comment from parent BaseStructure that way.
    return True</code></pre>
</details>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.id_cache_key"><code class="name flex">
<span>def <span class="ident">id_cache_key</span></span>(<span>self, _id)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.id_cache_key" href="../base/structure.html#xmodel.base.structure.BaseStructure.id_cache_key">id_cache_key</a></code>
</p>
<div class="desc inherited"><p>Returns a proper key to use for <code>xmodel.base.client.BaseClient.cache_get</code>
and other caching methods for id-based lookup of an object.</p></div>
</dd>
<dt id="xmodel.remote.structure.RemoteStructure.is_field_a_child"><code class="name flex">
<span>def <span class="ident">is_field_a_child</span></span>(<span>self, child_field_name, *, and_has_id=False)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.structure.BaseStructure" href="../base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>.<code><a title="xmodel.base.structure.BaseStructure.is_field_a_child" href="../base/structure.html#xmodel.base.structure.BaseStructure.is_field_a_child">is_field_a_child</a></code>
</p>
<div class="desc inherited"><p>True if the field is a child, otherwise False.
Will still return <code>False</code> if
<code>and_has_id</code> argument is <code>True</code> and the related type is configured to not …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xmodel.remote" href="index.html">xmodel.remote</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel.remote.structure.RemoteStructure" href="#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code></h4>
<ul class="">
<li><code><a title="xmodel.remote.structure.RemoteStructure.api_options" href="#xmodel.remote.structure.RemoteStructure.api_options">api_options</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.configure_for_model_type" href="#xmodel.remote.structure.RemoteStructure.configure_for_model_type">configure_for_model_type</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.endpoint_description" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.endpoint_description">endpoint_description</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.excluded_field_map" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.excluded_field_map">excluded_field_map</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.field_exists" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.field_exists">field_exists</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.field_map" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.field_map">field_map</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.field_type" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.field_type">field_type</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.fields" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.fields">fields</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.get_field" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.get_field">get_field</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.get_unwraped_typehint" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.get_unwraped_typehint">get_unwraped_typehint</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.has_id_field" href="#xmodel.remote.structure.RemoteStructure.has_id_field">has_id_field</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.have_api_endpoint" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.have_api_endpoint">have_api_endpoint</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.id_cache_key" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.id_cache_key">id_cache_key</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.internal_shared_api_values" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.internal_shared_api_values">internal_shared_api_values</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.is_field_a_child" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.is_field_a_child">is_field_a_child</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.max_query_by_id" href="#xmodel.remote.structure.RemoteStructure.max_query_by_id">max_query_by_id</a></code></li>
<li><code><a title="xmodel.remote.structure.RemoteStructure.model_cls" href="../base/structure.html#xmodel.remote.structure.RemoteStructure.model_cls">model_cls</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>