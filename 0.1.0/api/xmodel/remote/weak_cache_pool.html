<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel.remote.weak_cache_pool API documentation</title>
<meta name="description" content="Introduction …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xmodel.remote.weak_cache_pool</code></h1>
</header>
<section id="section-intro">
<h2 id="introduction">Introduction</h2>
<p>Used to weakly store model objects in a Dependency.
Dependency can be activated/enabled temporarily or permanently depending on desired behavior for
app.</p>
<p>The weak-cache is nice, because there are situations where various object will reference
the same object. Take for instance order and order-lines.
The order-lines would have a
one-to-one relationship back to the order object, and there is no need to lookup the same
order object over and over again if you ask each order-line for it's order-object.</p>
<p>This is where the weak-cache can shine. The ORM can store temporary references to objects
by 'id' and check this cache to retrieve them later instead of having to do an actual
fetch-request.</p>
<p>Another place this can be useful is when query objects that are in a tree.
And objects parent could be referenced by several children.</p>
<h2 id="quick-start">Quick Start</h2>
<p>To use, you can either simply allocate a <code><a title="xmodel.remote.weak_cache_pool.WeakCachePool" href="#xmodel.remote.weak_cache_pool.WeakCachePool">WeakCachePool</a></code> resource and activate it
via <code>@</code> function dectorator or <code>with</code> context-manager syntax:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel.weak_cache_pool import WeakCachePool
&gt;&gt;&gt; @WeakCachePool(enabled=True)
&gt;&gt;&gt; def lambda_event_handler(event, context):
...    pass
</code></pre>
<p>While this WeakCachePool is enabled, it will store weakly-cached objects in it's self.
When the object is deactivated and thrown away after the <code>lambda_event_handler</code> is finished
the weak-cache is deallocated.</p>
<p>Next time the function <code>lambda_event_handler</code> is called, a brand-new WeakCachePool is allocated
and then activated.</p>
<p>If you wish to enable the <code><a title="xmodel.remote.weak_cache_pool.WeakCachePool" href="#xmodel.remote.weak_cache_pool.WeakCachePool">WeakCachePool</a></code> permently, you can enable the current
<code><a title="xmodel.remote.weak_cache_pool.WeakCachePool" href="#xmodel.remote.weak_cache_pool.WeakCachePool">WeakCachePool</a></code> instead of allocating and activating a new one:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; WeakCachePool.grab().enabled = True
</code></pre>
<p>When you allocate a new <code><a title="xmodel.remote.weak_cache_pool.WeakCachePool" href="#xmodel.remote.weak_cache_pool.WeakCachePool">WeakCachePool</a></code>, the previous one will not be used while the new one
is activated.
This means, any objects you fetch will not use the previous cache.
You are guaranteed to get brand-new fresh objects while the new <code><a title="xmodel.remote.weak_cache_pool.WeakCachePool" href="#xmodel.remote.weak_cache_pool.WeakCachePool">WeakCachePool</a></code> is active
vs what has been previously fetched (ie: parent should not be consulted).</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
## Introduction

Used to weakly store model objects in a Dependency.
Dependency can be activated/enabled temporarily or permanently depending on desired behavior for
app.

The weak-cache is nice, because there are situations where various object will reference
the same object. Take for instance order and order-lines.  The order-lines would have a
one-to-one relationship back to the order object, and there is no need to lookup the same
order object over and over again if you ask each order-line for it&#39;s order-object.

This is where the weak-cache can shine. The ORM can store temporary references to objects
by &#39;id&#39; and check this cache to retrieve them later instead of having to do an actual
fetch-request.

Another place this can be useful is when query objects that are in a tree.
And objects parent could be referenced by several children.

## Quick Start

To use, you can either simply allocate a `WeakCachePool` resource and activate it
via `@` function dectorator or `with` context-manager syntax:

&gt;&gt;&gt; from xmodel.weak_cache_pool import WeakCachePool
&gt;&gt;&gt; @WeakCachePool(enabled=True)
&gt;&gt;&gt; def lambda_event_handler(event, context):
...    pass

While this WeakCachePool is enabled, it will store weakly-cached objects in it&#39;s self.
When the object is deactivated and thrown away after the `lambda_event_handler` is finished
the weak-cache is deallocated.

Next time the function `lambda_event_handler` is called, a brand-new WeakCachePool is allocated
and then activated.

If you wish to enable the `WeakCachePool` permently, you can enable the current
`WeakCachePool` instead of allocating and activating a new one:

&gt;&gt;&gt; WeakCachePool.grab().enabled = True

When you allocate a new `WeakCachePool`, the previous one will not be used while the new one
is activated.  This means, any objects you fetch will not use the previous cache.
You are guaranteed to get brand-new fresh objects while the new `WeakCachePool` is active
vs what has been previously fetched (ie: parent should not be consulted).

&#34;&#34;&#34;

from xinject import Dependency
from typing import Type, Dict
import weakref


# Only reason we are using ThreadUsafeDependency is to be ultra-safe,
# for now don&#39;t share WeakCachePool cross-thread, associate pool with only one thread of now.
# We may relax this later. See class doc-comment below for more details.
class WeakCachePool(Dependency):
    &#34;&#34;&#34;
    In general, used to enable the weak-cache for the ORM in general.

    By default, the weak cache is not enabled.

    It&#39;s an explicitly opt-in feature, because there may be reference-cycles for the Model
    object and so it may not be immediately deallocated.


    .. important:: For now, we are making this a ThreadUsafeDependency;
        we might relax this later... being ultra-safe.
        If some other thread is doing stuff with orm, weakly-cached objects are
        cached per-thread for now.
        It mostly likely is ok to share weak-cache across thread,
        for now I thought it prudent to not dive into that just yet.

    ## Python Memory Management Details

    Python has a referenced-counting system that can deallocate most objects immediately.
    However, reference-cycles can&#39;t be detected via the referenced-counting system.
    Objects in this situation are collected by the garbage collector process,  that goes though
    and detects reference-cycles that are not longer reachable by a strong-reference.
    &#34;&#34;&#34;

    # Instead of inheriting from `ThreadUnsafeDependency`, we set flag directly ourselves.
    # This allows us to be compatible with both v2 and v3 of xinject.
    resource_thread_safe = False

    # If/when we get copied, we play it safe and don&#39;t copy `_obj_weak_cache` for now.
    # I might consider doing a shallow-copy of the weak cache (even if a deep-copy is requested)
    # at some point in the future. For now, keeping it conservative.
    attributes_to_skip_while_copying = {&#39;_obj_weak_cache&#39;}

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34; Enables the weak-cacher so when it&#39;s asked to weakly cache an object it will
            actually do it.

            If you enable us and we were previously disabled, the weak-cache will be cleared;
            and we also clear cache if we were previously enabled and get disabled.
        &#34;&#34;&#34;
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        if self._enabled == value:
            return
        self._enabled = value
        self.clear_caches()

    _enabled = None
    _obj_weak_cache: Dict[Type, weakref.WeakValueDictionary] = None

    def __init__(self, enable=False):
        self.enabled = bool(enable)
        self.clear_caches()

    def clear_caches(self):

        self._obj_weak_cache = dict()

    def set(self, key: str, value):
        &#34;&#34;&#34;
        Just like `xmodel.base.client.BaseClient.cache_set`,
        except it will weakly keep the value inside us as a Dependency subclass.

        Normally called from `xmodel.base.client.BaseClient.cache_weak_set`,
        we implement most of that methods functionality here.

        We also don&#39;t cache any values if `ModelCacher.enable_weak_cache` is `False`
        (the default).

        This means, while/if a `ModelCacher` `xinject.context.Dependency` is activated and
        enabled, when `xmodel.base.client.BaseClient` uses us to weakly cache something it will
        call us and we will weakly set them into into the cache.

        When we weakly cache something, we use the value&#39;s type + the key to identify it.
        You&#39;ll need the value&#39;s type + key to later retrieve the weakly cached value.

        See `xmodel.base.client.BaseClient.cache_weak_get` for more details.
        &#34;&#34;&#34;
        if not self.enabled:
            return

        # Check to see if we have weak-dict for the value-type...
        value_type = type(value)
        if value_type not in self._obj_weak_cache:
            self._obj_weak_cache[value_type] = weakref.WeakValueDictionary()

        self._obj_weak_cache[value_type][key] = value

    def get(self, value_type: Type, key: str, default=None):
        &#34;&#34;&#34;
        See `xmodel.base.client.BaseClient.cache_get` documentation for more details.
        This gets something out of the weak cache in self.

        Normally called from `xmodel.base.client.BaseClient.cache_get`,
        for weakly cached objects, we implement most of that methods functionality here.

        If key does not exist in cache, then return default [which defaults to None].

        The purpose of this is to provide a way to cache something a
        `xmodel.base.model.BaseModel` so that when
        all other references to it are gone it will automatically be removed out of the cache
        (ie: when `xmodel.base.model.BaseModel` object is not used anymore).

        A good way to get a key-by-id is via
        `xmodel.base.structure.BaseStructure.id_cache_key`.
        &#34;&#34;&#34;
        if not self.enabled:
            return None

        type_weak_dict = self._obj_weak_cache.get(value_type, None)
        if type_weak_dict is None:
            return default

        return type_weak_dict.get(key, default)

    def remove(self, value_type: Type, key: str):
        # No need to check if not enabled (optimization).
        if not self.enabled:
            return

        type_weak_dict = self._obj_weak_cache.get(value_type, None)
        if type_weak_dict is None:
            return

        type_weak_dict.pop(key, None)

    # Whenever we are activated via a `with` or `@`,
    # clear the caches for now just to keep things simple.
    # Overriding __enter__ and __exit__ is the easiest way to do that.

    def __enter__(self) -&gt; &#39;WeakCachePool&#39;:
        self.clear_caches()
        return super().__enter__()

    def __exit__(self, *args, **kwargs):
        self.clear_caches()
        return super().__exit__(*args, **kwargs)


def A():
    with WeakCachePool() as b:
        pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="xmodel.remote.weak_cache_pool.A"><code class="name flex">
<span>def <span class="ident">A</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def A():
    with WeakCachePool() as b:
        pass</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool"><code class="flex name class">
<span>class <span class="ident">WeakCachePool</span></span>
<span>(</span><span>enable=False)</span>
</code></dt>
<dd>
<div class="desc"><p>In general, used to enable the weak-cache for the ORM in general.</p>
<p>By default, the weak cache is not enabled.</p>
<p>It's an explicitly opt-in feature, because there may be reference-cycles for the Model
object and so it may not be immediately deallocated.</p>
<div class="admonition important">
<p class="admonition-title">Important:&ensp;For now, we are making this a ThreadUsafeDependency;</p>
<p>we might relax this later&hellip; being ultra-safe.
If some other thread is doing stuff with orm, weakly-cached objects are
cached per-thread for now.
It mostly likely is ok to share weak-cache across thread,
for now I thought it prudent to not dive into that just yet.</p>
</div>
<h2 id="python-memory-management-details">Python Memory Management Details</h2>
<p>Python has a referenced-counting system that can deallocate most objects immediately.
However, reference-cycles can't be detected via the referenced-counting system.
Objects in this situation are collected by the garbage collector process,
that goes though
and detects reference-cycles that are not longer reachable by a strong-reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeakCachePool(Dependency):
    &#34;&#34;&#34;
    In general, used to enable the weak-cache for the ORM in general.

    By default, the weak cache is not enabled.

    It&#39;s an explicitly opt-in feature, because there may be reference-cycles for the Model
    object and so it may not be immediately deallocated.


    .. important:: For now, we are making this a ThreadUsafeDependency;
        we might relax this later... being ultra-safe.
        If some other thread is doing stuff with orm, weakly-cached objects are
        cached per-thread for now.
        It mostly likely is ok to share weak-cache across thread,
        for now I thought it prudent to not dive into that just yet.

    ## Python Memory Management Details

    Python has a referenced-counting system that can deallocate most objects immediately.
    However, reference-cycles can&#39;t be detected via the referenced-counting system.
    Objects in this situation are collected by the garbage collector process,  that goes though
    and detects reference-cycles that are not longer reachable by a strong-reference.
    &#34;&#34;&#34;

    # Instead of inheriting from `ThreadUnsafeDependency`, we set flag directly ourselves.
    # This allows us to be compatible with both v2 and v3 of xinject.
    resource_thread_safe = False

    # If/when we get copied, we play it safe and don&#39;t copy `_obj_weak_cache` for now.
    # I might consider doing a shallow-copy of the weak cache (even if a deep-copy is requested)
    # at some point in the future. For now, keeping it conservative.
    attributes_to_skip_while_copying = {&#39;_obj_weak_cache&#39;}

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34; Enables the weak-cacher so when it&#39;s asked to weakly cache an object it will
            actually do it.

            If you enable us and we were previously disabled, the weak-cache will be cleared;
            and we also clear cache if we were previously enabled and get disabled.
        &#34;&#34;&#34;
        return self._enabled

    @enabled.setter
    def enabled(self, value: bool):
        if self._enabled == value:
            return
        self._enabled = value
        self.clear_caches()

    _enabled = None
    _obj_weak_cache: Dict[Type, weakref.WeakValueDictionary] = None

    def __init__(self, enable=False):
        self.enabled = bool(enable)
        self.clear_caches()

    def clear_caches(self):

        self._obj_weak_cache = dict()

    def set(self, key: str, value):
        &#34;&#34;&#34;
        Just like `xmodel.base.client.BaseClient.cache_set`,
        except it will weakly keep the value inside us as a Dependency subclass.

        Normally called from `xmodel.base.client.BaseClient.cache_weak_set`,
        we implement most of that methods functionality here.

        We also don&#39;t cache any values if `ModelCacher.enable_weak_cache` is `False`
        (the default).

        This means, while/if a `ModelCacher` `xinject.context.Dependency` is activated and
        enabled, when `xmodel.base.client.BaseClient` uses us to weakly cache something it will
        call us and we will weakly set them into into the cache.

        When we weakly cache something, we use the value&#39;s type + the key to identify it.
        You&#39;ll need the value&#39;s type + key to later retrieve the weakly cached value.

        See `xmodel.base.client.BaseClient.cache_weak_get` for more details.
        &#34;&#34;&#34;
        if not self.enabled:
            return

        # Check to see if we have weak-dict for the value-type...
        value_type = type(value)
        if value_type not in self._obj_weak_cache:
            self._obj_weak_cache[value_type] = weakref.WeakValueDictionary()

        self._obj_weak_cache[value_type][key] = value

    def get(self, value_type: Type, key: str, default=None):
        &#34;&#34;&#34;
        See `xmodel.base.client.BaseClient.cache_get` documentation for more details.
        This gets something out of the weak cache in self.

        Normally called from `xmodel.base.client.BaseClient.cache_get`,
        for weakly cached objects, we implement most of that methods functionality here.

        If key does not exist in cache, then return default [which defaults to None].

        The purpose of this is to provide a way to cache something a
        `xmodel.base.model.BaseModel` so that when
        all other references to it are gone it will automatically be removed out of the cache
        (ie: when `xmodel.base.model.BaseModel` object is not used anymore).

        A good way to get a key-by-id is via
        `xmodel.base.structure.BaseStructure.id_cache_key`.
        &#34;&#34;&#34;
        if not self.enabled:
            return None

        type_weak_dict = self._obj_weak_cache.get(value_type, None)
        if type_weak_dict is None:
            return default

        return type_weak_dict.get(key, default)

    def remove(self, value_type: Type, key: str):
        # No need to check if not enabled (optimization).
        if not self.enabled:
            return

        type_weak_dict = self._obj_weak_cache.get(value_type, None)
        if type_weak_dict is None:
            return

        type_weak_dict.pop(key, None)

    # Whenever we are activated via a `with` or `@`,
    # clear the caches for now just to keep things simple.
    # Overriding __enter__ and __exit__ is the easiest way to do that.

    def __enter__(self) -&gt; &#39;WeakCachePool&#39;:
        self.clear_caches()
        return super().__enter__()

    def __exit__(self, *args, **kwargs):
        self.clear_caches()
        return super().__exit__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.attributes_to_skip_while_copying"><code class="name">var <span class="ident">attributes_to_skip_while_copying</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.resource_thread_safe"><code class="name">var <span class="ident">resource_thread_safe</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying: Optional[Iterable[str]] = Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible …</dd>
</dl></div>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) ‑> ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> …</p></div>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) ‑> ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> …</p></div>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name: str) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> …</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.enabled"><code class="name">var <span class="ident">enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>Enables the weak-cacher so when it's asked to weakly cache an object it will
actually do it.</p>
<p>If you enable us and we were previously disabled, the weak-cache will be cleared;
and we also clear cache if we were previously enabled and get disabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    &#34;&#34;&#34; Enables the weak-cacher so when it&#39;s asked to weakly cache an object it will
        actually do it.

        If you enable us and we were previously disabled, the weak-cache will be cleared;
        and we also clear cache if we were previously enabled and get disabled.
    &#34;&#34;&#34;
    return self._enabled</code></pre>
</details>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.obj"><code class="name">var <span class="ident">obj</span> : <a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other …</p></div>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) …</p></div>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.clear_caches"><code class="name flex">
<span>def <span class="ident">clear_caches</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_caches(self):

    self._obj_weak_cache = dict()</code></pre>
</details>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, value_type: Type[+CT_co], key: str, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>See <code>xmodel.base.client.BaseClient.cache_get</code> documentation for more details.
This gets something out of the weak cache in self.</p>
<p>Normally called from <code>xmodel.base.client.BaseClient.cache_get</code>,
for weakly cached objects, we implement most of that methods functionality here.</p>
<p>If key does not exist in cache, then return default [which defaults to None].</p>
<p>The purpose of this is to provide a way to cache something a
<code><a title="xmodel.base.model.BaseModel" href="../base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> so that when
all other references to it are gone it will automatically be removed out of the cache
(ie: when <code><a title="xmodel.base.model.BaseModel" href="../base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> object is not used anymore).</p>
<p>A good way to get a key-by-id is via
<code><a title="xmodel.base.structure.BaseStructure.id_cache_key" href="../base/structure.html#xmodel.base.structure.BaseStructure.id_cache_key">BaseStructure.id_cache_key()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, value_type: Type, key: str, default=None):
    &#34;&#34;&#34;
    See `xmodel.base.client.BaseClient.cache_get` documentation for more details.
    This gets something out of the weak cache in self.

    Normally called from `xmodel.base.client.BaseClient.cache_get`,
    for weakly cached objects, we implement most of that methods functionality here.

    If key does not exist in cache, then return default [which defaults to None].

    The purpose of this is to provide a way to cache something a
    `xmodel.base.model.BaseModel` so that when
    all other references to it are gone it will automatically be removed out of the cache
    (ie: when `xmodel.base.model.BaseModel` object is not used anymore).

    A good way to get a key-by-id is via
    `xmodel.base.structure.BaseStructure.id_cache_key`.
    &#34;&#34;&#34;
    if not self.enabled:
        return None

    type_weak_dict = self._obj_weak_cache.get(value_type, None)
    if type_weak_dict is None:
        return default

    return type_weak_dict.get(key, default)</code></pre>
</details>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, value_type: Type[+CT_co], key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, value_type: Type, key: str):
    # No need to check if not enabled (optimization).
    if not self.enabled:
        return

    type_weak_dict = self._obj_weak_cache.get(value_type, None)
    if type_weak_dict is None:
        return

    type_weak_dict.pop(key, None)</code></pre>
</details>
</dd>
<dt id="xmodel.remote.weak_cache_pool.WeakCachePool.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, key: str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Just like <code>xmodel.base.client.BaseClient.cache_set</code>,
except it will weakly keep the value inside us as a Dependency subclass.</p>
<p>Normally called from <code>xmodel.base.client.BaseClient.cache_weak_set</code>,
we implement most of that methods functionality here.</p>
<p>We also don't cache any values if <code>ModelCacher.enable_weak_cache</code> is <code>False</code>
(the default).</p>
<p>This means, while/if a <code>ModelCacher</code> <code>xinject.context.Dependency</code> is activated and
enabled, when <code>xmodel.base.client.BaseClient</code> uses us to weakly cache something it will
call us and we will weakly set them into into the cache.</p>
<p>When we weakly cache something, we use the value's type + the key to identify it.
You'll need the value's type + key to later retrieve the weakly cached value.</p>
<p>See <code>xmodel.base.client.BaseClient.cache_weak_get</code> for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, key: str, value):
    &#34;&#34;&#34;
    Just like `xmodel.base.client.BaseClient.cache_set`,
    except it will weakly keep the value inside us as a Dependency subclass.

    Normally called from `xmodel.base.client.BaseClient.cache_weak_set`,
    we implement most of that methods functionality here.

    We also don&#39;t cache any values if `ModelCacher.enable_weak_cache` is `False`
    (the default).

    This means, while/if a `ModelCacher` `xinject.context.Dependency` is activated and
    enabled, when `xmodel.base.client.BaseClient` uses us to weakly cache something it will
    call us and we will weakly set them into into the cache.

    When we weakly cache something, we use the value&#39;s type + the key to identify it.
    You&#39;ll need the value&#39;s type + key to later retrieve the weakly cached value.

    See `xmodel.base.client.BaseClient.cache_weak_get` for more details.
    &#34;&#34;&#34;
    if not self.enabled:
        return

    # Check to see if we have weak-dict for the value-type...
    value_type = type(value)
    if value_type not in self._obj_weak_cache:
        self._obj_weak_cache[value_type] = weakref.WeakValueDictionary()

    self._obj_weak_cache[value_type][key] = value</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#quick-start">Quick Start</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xmodel.remote" href="index.html">xmodel.remote</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="xmodel.remote.weak_cache_pool.A" href="#xmodel.remote.weak_cache_pool.A">A</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool" href="#xmodel.remote.weak_cache_pool.WeakCachePool">WeakCachePool</a></code></h4>
<ul class="">
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.__call__" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.__call__">__call__</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.__copy__" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.__copy__">__copy__</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.__init_subclass__" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.attributes_to_skip_while_copying" href="#xmodel.remote.weak_cache_pool.WeakCachePool.attributes_to_skip_while_copying">attributes_to_skip_while_copying</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.clear_caches" href="#xmodel.remote.weak_cache_pool.WeakCachePool.clear_caches">clear_caches</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.enabled" href="#xmodel.remote.weak_cache_pool.WeakCachePool.enabled">enabled</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.get" href="#xmodel.remote.weak_cache_pool.WeakCachePool.get">get</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.grab" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.grab">grab</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.obj" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.obj">obj</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.proxy" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.proxy">proxy</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.proxy_attribute" href="../../xinject/dependency.html#xmodel.remote.weak_cache_pool.WeakCachePool.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.remove" href="#xmodel.remote.weak_cache_pool.WeakCachePool.remove">remove</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.resource_thread_safe" href="#xmodel.remote.weak_cache_pool.WeakCachePool.resource_thread_safe">resource_thread_safe</a></code></li>
<li><code><a title="xmodel.remote.weak_cache_pool.WeakCachePool.set" href="#xmodel.remote.weak_cache_pool.WeakCachePool.set">set</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>