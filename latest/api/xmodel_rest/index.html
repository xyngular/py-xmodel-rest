<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel_rest API documentation</title>
<meta name="description" content="Rest Specific/Relate Classes …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>xmodel_rest</code></h1>
</header>
<section id="section-intro">
<h2 id="rest-specificrelate-classes">Rest Specific/Relate Classes</h2>
<p>Important rest specific classes:</p>
<ul>
<li><code>xynlib.orm.rest.api.RestApi</code></li>
<li><code>xynlib.orm.rest.client.RestClient</code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
## Rest Specific/Relate Classes

Important rest specific classes:

- `xynlib.orm.rest.api.RestApi`
- `xynlib.orm.rest.client.RestClient`

&#34;&#34;&#34;
from .client import RestClient
from .settings import RestSettings
from .structure import RestStructure
from .auth import RestAuth
from .api import RestApi
from .model import RestModel

# Only these should be imported from here externally.
__all__ = (
    &#39;RestClient&#39;,
    &#39;RestSettings&#39;,
    &#39;RestStructure&#39;,
    &#39;RestApi&#39;,
    &#39;RestModel&#39;,
    &#39;RestAuth&#39;
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="xmodel_rest.api" href="api.html">xmodel_rest.api</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.auth" href="auth.html">xmodel_rest.auth</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.client" href="client.html">xmodel_rest.client</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.default_model_urls" href="default_model_urls.html">xmodel_rest.default_model_urls</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.errors" href="errors.html">xmodel_rest.errors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.model" href="model.html">xmodel_rest.model</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.session" href="session.html">xmodel_rest.session</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.settings" href="settings.html">xmodel_rest.settings</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel_rest.structure" href="structure.html">xmodel_rest.structure</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel_rest.RestApi"><code class="flex name class">
<span>class <span class="ident">RestApi</span></span>
<span>(</span><span>*, api: BaseApi[M] = None, model: <a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base <code>xynlib.orm.base.api.BaseApi</code> subclass generally used by Rest API's.</p>
<p>Things specific and common to rest api's should go in this class.</p>
<p>See parent <code>xynlib.orm.base.api.BaseApi</code> for things in common among all API's.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;You can probably skip the rest (below)</p>
<p>Most of the time you don't create <code>BaseApi</code> objects your self, and so for most people
you can skip the following unless you want to know more about internal details.</p>
</div>
<h1 id="init-method-specifics">Init Method Specifics</h1>
<p>Normally you would not create an <code>BaseApi</code> object directly your self.
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s know how to do this automatically.
It happens in <code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="../xmodel/base/model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code>.</p>
<p>Details about how the arguments you can pass are below.</p>
<h2 id="basemodel-class-construction">BaseModel Class Construction:</h2>
<p>If you provide an <code><a title="xmodel_rest.api" href="api.html">xmodel_rest.api</a></code> arg without a <code><a title="xmodel_rest.model" href="model.html">xmodel_rest.model</a></code> arg; we will copy the <code>BaseApi.structure</code>
into new object, resetting the error status, and internal <code>BaseApi._state</code> to None.
This <code><a title="xmodel_rest.api" href="api.html">xmodel_rest.api</a></code> object is supposed to be the parent BaseModel's class api object.</p>
<p>If both <code><a title="xmodel_rest.api" href="api.html">xmodel_rest.api</a></code> arg + <code><a title="xmodel_rest.model" href="model.html">xmodel_rest.model</a></code> arg are <code>None</code>, the BaseModel is the root/generic BaseModel
(ie: it has no parent BaseModel).</p>
<p>This is what is done by BaseModel classes while the class is lazily loading and
creating/configuring the BaseModel class and it's associated <code>BaseApi</code> object
(accessible via <code><a title="xmodel.base.model.BaseModel.api" href="../xmodel/base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>)</p>
<h2 id="basemodel-instance-creation">BaseModel Instance Creation:</h2>
<p>If you also pass in a <code><a title="xmodel_rest.model" href="model.html">xmodel_rest.model</a></code> arg; this get you a special copy of the api you passed in
for use just with that BaseModel instance. The model <code>BaseApi._state</code> will be allocated
internally in the init'd BaseApi object. This is how a <code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance get's it's own associated <code>BaseApi</code> object
(that's a different instance vs the one set on BaseModel class when the BaseModel class
was originally constructed).</p>
<p>All params are optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>
<p>The "parent" BaseApi obj to copy the basic structure from as a starting point,
etc.
The superclasses BaseApi class is passed via this arg.
This is only used when allocating a new <code>BaseApi</code> object for a new
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> class (not an instance, a model class/type).
This BaseApi object is used for the class-level BaseModel api object;
ie: via "ModelClass.api"</p>
<p>See above "BaseModel Class Construction" for more details.</p>
</dd>
<dt><strong><code>model</code></strong></dt>
<dd>
<p>BaseModel to associate new BaseApi obj with.
This is only used to create a new BaseApi object for a
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance for an already-existing type. ie: for BaseModel object instances.</p>
<p>See above "BaseModel Instance Creation" for more details.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestApi(RemoteApi[M]):
    &#34;&#34;&#34; Base `xynlib.orm.base.api.BaseApi` subclass generally used by Rest API&#39;s.

        Things specific and common to rest api&#39;s should go in this class.

        See parent `xynlib.orm.base.api.BaseApi` for things in common among all API&#39;s.
    &#34;&#34;&#34;

    # Telling system about the default/base rest types we want to use with `RestApi`.
    client: RestClient[M]
    structure: RestStructure[Field]
    auth: RestAuth
    settings: RestSettings

    # todo: decide if we should just remove the below, not strictly needed, more of a convenience.
    #
    # Only used for IDE so it knows what type should be here, not used to know which Model to
    # allocate object.
    # This is because RestModel will tell/pass this into RestApi via `__init__`,
    # it happens when a RestModel/BaseModel is created (in BaseModel.__init__).
    model: RestModel[M]

    def send(self, url: URLStr = None):
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        Convenience method to send this single object to API, it simply calls
        `xynlib.orm.base.client.Client.send_objs` with a single object in the list
        (via `xynlib.orm.base.api.BaseApi.model`).

        If you want to send multiple objects, call `xynlib.orm.base.client.Client.send_objs`.

        Example is below, it uses a made-up rest model called &#39;SomeRestModelSubclass&#39;.

        (I did not provide all details it would need to use the made-up/imagained rest-api;
        trying to illisrate a basic point here is all.
        If you want more details on how to make a real full/valid rest-model subclass
        see #INSERT-README-LINK#.)

        &gt;&gt;&gt; from xmodel_rest import RestModel
        &gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&#34;....etc....&#34;):
        ...     pass  # Some attributes from the rest-api go here
        &gt;&gt;&gt; obj1 = SomeRestModelSubclass()
        &gt;&gt;&gt; obj2 = SomeRestModelSubclass()
        &gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])

        If you pass in a `url` paramater to the `send_objs` method, the url gets appended to the
        final constructed url before the url gets validated.

        If the url is validated, it will use that final url [with passed in `url` this appended].
        For more information about how URL&#39;s are appended to each-other see:
        `xurls.url.URLMutable.append_url`.

        The response from API will update all the values on this object with the results
        of the change [all fields will be updated] and with the latest values from API.

        You can check for errors on model object via `xmodel.remote.api.response_state`, ie:

        &gt;&gt;&gt; from xynlib.orm import BaseModel
        &gt;&gt;&gt; obj: BaseModel
        &gt;&gt;&gt; # Check response_state to see if it had an error:
        &gt;&gt;&gt; obj.api.response_state.had_error
        False
        &#34;&#34;&#34;
        # Redirect to client.send_objs:
        self.client.send_objs([self.model], url=url)

    # This is a resource-type, see `def auth()` doc-comment below for more details.
    # Subclasses can override this type-hint, and `RestApi` will allocate the new
    # type instead automatically, on demand.
    #
    # The type-hints inform this class what type of objects to create when `auth` along
    # with other special attributes such as `client` and `structure` are needed/asked-for.
    #
    # You can override the type by making your own type-hint on a sub-class.
    # See xmodel.base.api.BaseApi and xmodel.remote.api.RemoteApi for its various special
    # type-hinted attributes for more details, it has more detailed comments/documentation on it.
    auth: RestAuth

    @property
    def _auth(self):
        &#34;&#34;&#34;
        Treated a `xyn_resaource.context.Resource`, a context resource for the purposes of sharing
        auth credentials. The type-hint assoicated with `auth: XYZ` will be used to grab
        a resource of that type from the current context each time we are asked.

        Thus resource is the auth object used by your `xmodel.base.client.BaseClient` subclass,
        (such as `xynlib.orm.rest.RestClient`),
        to set what type should be used for this, in your BaseClient sub-class, make a type-hint
        like below.

        Let&#39;s say you have an auth class you want to use:

        &gt;&gt;&gt; import xmodel.base.auth
        &gt;&gt;&gt; import xmodel
        &gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
        ...     pass

        You can set a type-hint for it like so, and it will be automatiaclly used when needed:

        &gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
        ...     auth: MyCoolAuthClass

        Doing that is enough, `xynlib.orm.rest.RestClient` class will see the type-hint and will
        grab one of that type from the XContext and return it.
        In the example above, it would be a `MyCoolAuthClass` type.

        The type-hint is lazily cached in self for fast lookup in the future.

        To see details on what the Auth object should do,
        see `xmodel.base.auth.BaseAuth`.
        &#34;&#34;&#34;

        auth_type: Type[RestAuth] = self._auth_type
        if not auth_type:
            # Will get all type-hints, and ensure they are valid type refrences
            # (otherwise will error out)
            auth_type = get_type_hints(type(self)).get(&#39;auth&#39;, RestAuth)
            self._auth_type = auth_type

        # Auth has tokens we want to try and share, treat it as a resource.
        return auth_type.grab()

    _settings_type: Type[RestSettings] = None

    @property
    def _settings(self):
        &#34;&#34;&#34; The config object that this api uses, can be customized per-model. All you have to
            do is this to make it a different type:

            &gt;&gt;&gt; import xmodel
            &gt;&gt;&gt;
            &gt;&gt;&gt; class MySettings(BaseSettings):
            ...     my_custom_var: str = xmodel.ConfigVar(
            ...         &#34;MY_CUSTOM_ENVIRONMENTAL_VAR&#34;,
            ...         &#34;default&#34;
            ...     )
            &gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
            ...     settings: MySettings
            &gt;&gt;&gt; class MyModel(xmodel.model.BaseModel[&#39;MyModel&#39;]):
            ...     api: MyApi

            The type-hints are enough to tell the system what types to use. They also will
            tell any IDE in use about what type it should be, for type-completion.
            So it&#39;s sort of doing double-duty!
        &#34;&#34;&#34;
        config_type = self._settings_type
        if not config_type:
            config_type = get_type_hints(type(self)).get(&#39;settings&#39;, None)
            self._settings_type = config_type  # Cache config-type.
            if config_type is None:
                raise XynRestError(
                    f&#34;BaseClient subclass type is undefined for model class ({self.model_type}), &#34;
                    f&#34;a type-hint for &#39;client&#39; on BaseApi class must be in place for me to know &#34;
                    f&#34;what type to get.&#34;
                )

        return XContext.current(for_type=config_type)

    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. This gets around it since pycharm
    # can&#39;t figure out what&#39;s going on here.
    auth = _auth
    settings = _settings</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></li>
<li><a title="xmodel.base.api.BaseApi" href="../xmodel/base/api.html#xmodel.base.api.BaseApi">BaseApi</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.RestApi.default_converters"><code class="name">var <span class="ident">default_converters</span> : Dict[Type[Any], <a title="xmodel.base.fields.Converter" href="../xmodel/base/fields.html#xmodel.base.fields.Converter">Converter</a>]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.default_converters" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.default_converters">default_converters</a></code>
</p>
<div class="desc inherited"><p>For an overview of type-converts, see
<a href="./#type-converters">Type Converters Overview</a> …</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel_rest.RestApi.auth"><code class="name">var <span class="ident">auth</span> : <a title="xmodel_rest.auth.RestAuth" href="auth.html#xmodel_rest.auth.RestAuth">RestAuth</a></code></dt>
<dd>
<div class="desc"><p>Treated a <code>xyn_resaource.context.Resource</code>, a context resource for the purposes of sharing
auth credentials. The type-hint assoicated with <code>auth: XYZ</code> will be used to grab
a resource of that type from the current context each time we are asked.</p>
<p>Thus resource is the auth object used by your <code>xmodel.base.client.BaseClient</code> subclass,
(such as <code>xynlib.orm.rest.RestClient</code>),
to set what type should be used for this, in your BaseClient sub-class, make a type-hint
like below.</p>
<p>Let's say you have an auth class you want to use:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import xmodel.base.auth
&gt;&gt;&gt; import xmodel
&gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
...     pass
</code></pre>
<p>You can set a type-hint for it like so, and it will be automatiaclly used when needed:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
...     auth: MyCoolAuthClass
</code></pre>
<p>Doing that is enough, <code>xynlib.orm.rest.RestClient</code> class will see the type-hint and will
grab one of that type from the XContext and return it.
In the example above, it would be a <code>MyCoolAuthClass</code> type.</p>
<p>The type-hint is lazily cached in self for fast lookup in the future.</p>
<p>To see details on what the Auth object should do,
see <code>xmodel.base.auth.BaseAuth</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _auth(self):
    &#34;&#34;&#34;
    Treated a `xyn_resaource.context.Resource`, a context resource for the purposes of sharing
    auth credentials. The type-hint assoicated with `auth: XYZ` will be used to grab
    a resource of that type from the current context each time we are asked.

    Thus resource is the auth object used by your `xmodel.base.client.BaseClient` subclass,
    (such as `xynlib.orm.rest.RestClient`),
    to set what type should be used for this, in your BaseClient sub-class, make a type-hint
    like below.

    Let&#39;s say you have an auth class you want to use:

    &gt;&gt;&gt; import xmodel.base.auth
    &gt;&gt;&gt; import xmodel
    &gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
    ...     pass

    You can set a type-hint for it like so, and it will be automatiaclly used when needed:

    &gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
    ...     auth: MyCoolAuthClass

    Doing that is enough, `xynlib.orm.rest.RestClient` class will see the type-hint and will
    grab one of that type from the XContext and return it.
    In the example above, it would be a `MyCoolAuthClass` type.

    The type-hint is lazily cached in self for fast lookup in the future.

    To see details on what the Auth object should do,
    see `xmodel.base.auth.BaseAuth`.
    &#34;&#34;&#34;

    auth_type: Type[RestAuth] = self._auth_type
    if not auth_type:
        # Will get all type-hints, and ensure they are valid type refrences
        # (otherwise will error out)
        auth_type = get_type_hints(type(self)).get(&#39;auth&#39;, RestAuth)
        self._auth_type = auth_type

    # Auth has tokens we want to try and share, treat it as a resource.
    return auth_type.grab()</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestApi.client"><code class="name">var <span class="ident">client</span> : <a title="xmodel_rest.client.RestClient" href="client.html#xmodel_rest.client.RestClient">RestClient</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.client" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.client">client</a></code>
</p>
<div class="desc inherited"><p>Returns an appropriate concrete <code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code> subclass.
We figure out the proper client object to use based on the type-hint for …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.context"><code class="name">var <span class="ident">context</span> : <a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.context" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.context">context</a></code>
</p>
<div class="desc inherited"><p>BaseApi context to use when asking this object to send/delete/etc its self to/from
service …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.have_changes"><code class="name">var <span class="ident">have_changes</span> : bool</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.have_changes" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.have_changes">have_changes</a></code>
</p>
<div class="desc inherited"><p>Is True if <code>self.json(only_include_changes=True)</code> is not None;
see json() method for more details.</p></div>
</dd>
<dt id="xmodel_rest.RestApi.model"><code class="name">var <span class="ident">model</span> : <a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.model" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.model">model</a></code>
</p>
<div class="desc inherited"><p>REQUIRES associated model object [see doc text below] …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.model_type"><code class="name">var <span class="ident">model_type</span> : Type[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.model_type" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.model_type">model_type</a></code>
</p>
<div class="desc inherited"><p>The same BaseApi class is meant to be re-used for any number of Models,
and so a BaseModel specifies it's BaseApi type as generic <code>BaseApi[M]</code>. In …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.options"><code class="name">var <span class="ident">options</span> : <a title="xmodel.remote.options.ApiOptions" href="../xmodel/remote/options.html#xmodel.remote.options.ApiOptions">ApiOptions</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.options" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.options">options</a></code>
</p>
<div class="desc inherited"><p>A set of options you can modify for the current context. If a particular option
inside the options object is not set, Options object may look at the …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.response_state"><code class="name">var <span class="ident">response_state</span> : <a title="xmodel.remote.response_state.ResponseState" href="../xmodel/remote/response_state.html#xmodel.remote.response_state.ResponseState">ResponseState</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.response_state" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.response_state">response_state</a></code>
</p>
<div class="desc inherited"><p>Returns the HTTP/Communication state of the api object …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.settings"><code class="name">var <span class="ident">settings</span> : <a title="xmodel_rest.settings.RestSettings" href="settings.html#xmodel_rest.settings.RestSettings">RestSettings</a></code></dt>
<dd>
<div class="desc"><p>The config object that this api uses, can be customized per-model. All you have to
do is this to make it a different type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import xmodel
&gt;&gt;&gt;
&gt;&gt;&gt; class MySettings(BaseSettings):
...     my_custom_var: str = xmodel.ConfigVar(
...         &quot;MY_CUSTOM_ENVIRONMENTAL_VAR&quot;,
...         &quot;default&quot;
...     )
&gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
...     settings: MySettings
&gt;&gt;&gt; class MyModel(xmodel.model.BaseModel['MyModel']):
...     api: MyApi
</code></pre>
<p>The type-hints are enough to tell the system what types to use. They also will
tell any IDE in use about what type it should be, for type-completion.
So it's sort of doing double-duty!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _settings(self):
    &#34;&#34;&#34; The config object that this api uses, can be customized per-model. All you have to
        do is this to make it a different type:

        &gt;&gt;&gt; import xmodel
        &gt;&gt;&gt;
        &gt;&gt;&gt; class MySettings(BaseSettings):
        ...     my_custom_var: str = xmodel.ConfigVar(
        ...         &#34;MY_CUSTOM_ENVIRONMENTAL_VAR&#34;,
        ...         &#34;default&#34;
        ...     )
        &gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
        ...     settings: MySettings
        &gt;&gt;&gt; class MyModel(xmodel.model.BaseModel[&#39;MyModel&#39;]):
        ...     api: MyApi

        The type-hints are enough to tell the system what types to use. They also will
        tell any IDE in use about what type it should be, for type-completion.
        So it&#39;s sort of doing double-duty!
    &#34;&#34;&#34;
    config_type = self._settings_type
    if not config_type:
        config_type = get_type_hints(type(self)).get(&#39;settings&#39;, None)
        self._settings_type = config_type  # Cache config-type.
        if config_type is None:
            raise XynRestError(
                f&#34;BaseClient subclass type is undefined for model class ({self.model_type}), &#34;
                f&#34;a type-hint for &#39;client&#39; on BaseApi class must be in place for me to know &#34;
                f&#34;what type to get.&#34;
            )

    return XContext.current(for_type=config_type)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestApi.structure"><code class="name">var <span class="ident">structure</span> : <a title="xmodel_rest.structure.RestStructure" href="structure.html#xmodel_rest.structure.RestStructure">RestStructure</a>[<a title="xmodel.base.fields.Field" href="../xmodel/base/fields.html#xmodel.base.fields.Field">Field</a>]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.structure" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.structure">structure</a></code>
</p>
<div class="desc inherited"><p>Contain things that don't vary among the model instances;
ie: This is the same object and applies to all instances of a particular BaseModel class …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.RestApi.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.delete" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.delete">delete</a></code>
</p>
<div class="desc inherited"><p>REQUIRES associated model object [see self.model] …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.did_send"><code class="name flex">
<span>def <span class="ident">did_send</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.did_send" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.did_send">did_send</a></code>
</p>
<div class="desc inherited"><p>self.client will call us here after someone attempts to send us (a specific model),
you and use <code>RelationApi.model</code> to grab the model that it happened …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.fields_to_pop_for_json"><code class="name flex">
<span>def <span class="ident">fields_to_pop_for_json</span></span>(<span>self, json: dict, field_objs: List[<a title="xmodel.base.fields.Field" href="../xmodel/base/fields.html#xmodel.base.fields.Field">Field</a>], log_output: bool) ‑> Set[Any]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.fields_to_pop_for_json" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.fields_to_pop_for_json">fields_to_pop_for_json</a></code>
</p>
<div class="desc inherited"><p>Goes through the list of fields (field_objs) to determine which ones have not changed in
order to pop them out of the json representation. This method …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.forget_original_json_state"><code class="name flex">
<span>def <span class="ident">forget_original_json_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.forget_original_json_state" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.forget_original_json_state">forget_original_json_state</a></code>
</p>
<div class="desc inherited"><p>If called, we forget/reset the orginal json state, which is a combination
of all the json that this object has been updated with over it's lifetime …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, query: Dict[str, Union[str, int, datetime.date, xurls.url._FormattedQueryValue, None, Iterable[Union[str, int, datetime.date, xurls.url._FormattedQueryValue]]]] = None, *, top: int = None, fields: Optional[Sequence[str]] = Default) ‑> Optional[Iterable[~M]]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.get" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.get">get</a></code>
</p>
<div class="desc inherited"><p>Important: Right now we return a list, but it might be just a generator in the future,
treat the return type as a true Iterable, something you can't …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.get_child_without_lazy_lookup"><code class="name flex">
<span>def <span class="ident">get_child_without_lazy_lookup</span></span>(<span>self, child_field_name, *, false_if_not_set=False) ‑> Union[<a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M], None, bool, <a title="xsentinels.null.NullType" href="../xsentinels/null.html#xsentinels.null.NullType">NullType</a>]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.get_child_without_lazy_lookup" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.get_child_without_lazy_lookup">get_child_without_lazy_lookup</a></code>
</p>
<div class="desc inherited"><p>REQUIRES associated model object [see self.model] …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.get_via_id"><code class="name flex">
<span>def <span class="ident">get_via_id</span></span>(<span>self, id: Union[int, str, List[Union[int, str]], Dict[str, Union[str, int]], List[Dict[str, Union[str, int]]]], fields: Sequence[str] = Default, id_field: str = None, aux_query: Dict[str, Union[str, int, datetime.date, xurls.url._FormattedQueryValue, None, Iterable[Union[str, int, datetime.date, xurls.url._FormattedQueryValue]]]] = None) ‑> Union[Iterable[~M], ~M, None]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.get_via_id" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.get_via_id">get_via_id</a></code>
</p>
<div class="desc inherited"><p>This method would have probably been better named <code>get_via_key</code> …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, only_include_changes: bool = False, log_output: bool = False) ‑> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.json" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.json">json</a></code>
</p>
<div class="desc inherited"><p><code><a title="xmodel.base.api.BaseApi.json" href="../xmodel/base/api.html#xmodel.base.api.BaseApi.json">BaseApi.json()</a></code> to see superclass's documentation for this method …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.list_of_attrs_to_repr"><code class="name flex">
<span>def <span class="ident">list_of_attrs_to_repr</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.list_of_attrs_to_repr" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.list_of_attrs_to_repr">list_of_attrs_to_repr</a></code>
</p>
<div class="desc inherited"><p>" REQUIRES associated model object [see self.model] …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.option_all_for_name"><code class="name flex">
<span>def <span class="ident">option_all_for_name</span></span>(<span>self, option_attribute_name) ‑> List[Any]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.option_all_for_name" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.option_all_for_name">option_all_for_name</a></code>
</p>
<div class="desc inherited"><p>Gets a particular option attribute by name in a particular prioritized order …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.option_for_name"><code class="name flex">
<span>def <span class="ident">option_for_name</span></span>(<span>self, option_attribute_name) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.option_for_name" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.option_for_name">option_for_name</a></code>
</p>
<div class="desc inherited"><p>Returns the first option returned from self.option_all_for_name for the
<code>option_attribute_name</code> that is passed in; otherwise None …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see self.model].</p>
<p>Convenience method to send this single object to API, it simply calls
<code>xynlib.orm.base.client.Client.send_objs</code> with a single object in the list
(via <code>xynlib.orm.base.api.BaseApi.model</code>).</p>
<p>If you want to send multiple objects, call <code>xynlib.orm.base.client.Client.send_objs</code>.</p>
<p>Example is below, it uses a made-up rest model called 'SomeRestModelSubclass'.</p>
<p>(I did not provide all details it would need to use the made-up/imagained rest-api;
trying to illisrate a basic point here is all.
If you want more details on how to make a real full/valid rest-model subclass
see #INSERT-README-LINK#.)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel_rest import RestModel
&gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&quot;....etc....&quot;):
...     pass  # Some attributes from the rest-api go here
&gt;&gt;&gt; obj1 = SomeRestModelSubclass()
&gt;&gt;&gt; obj2 = SomeRestModelSubclass()
&gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])
</code></pre>
<p>If you pass in a <code>url</code> paramater to the <code>send_objs</code> method, the url gets appended to the
final constructed url before the url gets validated.</p>
<p>If the url is validated, it will use that final url [with passed in <code>url</code> this appended].
For more information about how URL's are appended to each-other see:
<code><a title="xurls.url.URLMutable.append_url" href="../xurls/url.html#xurls.url.URLMutable.append_url">URLMutable.append_url()</a></code>.</p>
<p>The response from API will update all the values on this object with the results
of the change [all fields will be updated] and with the latest values from API.</p>
<p>You can check for errors on model object via <code>xmodel.remote.api.response_state</code>, ie:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xynlib.orm import BaseModel
&gt;&gt;&gt; obj: BaseModel
&gt;&gt;&gt; # Check response_state to see if it had an error:
&gt;&gt;&gt; obj.api.response_state.had_error
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, url: URLStr = None):
    &#34;&#34;&#34; REQUIRES associated model object [see self.model].

    Convenience method to send this single object to API, it simply calls
    `xynlib.orm.base.client.Client.send_objs` with a single object in the list
    (via `xynlib.orm.base.api.BaseApi.model`).

    If you want to send multiple objects, call `xynlib.orm.base.client.Client.send_objs`.

    Example is below, it uses a made-up rest model called &#39;SomeRestModelSubclass&#39;.

    (I did not provide all details it would need to use the made-up/imagained rest-api;
    trying to illisrate a basic point here is all.
    If you want more details on how to make a real full/valid rest-model subclass
    see #INSERT-README-LINK#.)

    &gt;&gt;&gt; from xmodel_rest import RestModel
    &gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&#34;....etc....&#34;):
    ...     pass  # Some attributes from the rest-api go here
    &gt;&gt;&gt; obj1 = SomeRestModelSubclass()
    &gt;&gt;&gt; obj2 = SomeRestModelSubclass()
    &gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])

    If you pass in a `url` paramater to the `send_objs` method, the url gets appended to the
    final constructed url before the url gets validated.

    If the url is validated, it will use that final url [with passed in `url` this appended].
    For more information about how URL&#39;s are appended to each-other see:
    `xurls.url.URLMutable.append_url`.

    The response from API will update all the values on this object with the results
    of the change [all fields will be updated] and with the latest values from API.

    You can check for errors on model object via `xmodel.remote.api.response_state`, ie:

    &gt;&gt;&gt; from xynlib.orm import BaseModel
    &gt;&gt;&gt; obj: BaseModel
    &gt;&gt;&gt; # Check response_state to see if it had an error:
    &gt;&gt;&gt; obj.api.response_state.had_error
    False
    &#34;&#34;&#34;
    # Redirect to client.send_objs:
    self.client.send_objs([self.model], url=url)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestApi.should_include_field_in_json"><code class="name flex">
<span>def <span class="ident">should_include_field_in_json</span></span>(<span>self, new_value: Any, old_value: Any, field: str) ‑> bool</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.should_include_field_in_json" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.should_include_field_in_json">should_include_field_in_json</a></code>
</p>
<div class="desc inherited"><p>Returns True if the the value for field should be included in the JSON.
This only gets called if only_include_changes is True when passed to …</p></div>
</dd>
<dt id="xmodel_rest.RestApi.update_from_json"><code class="name flex">
<span>def <span class="ident">update_from_json</span></span>(<span>self, json: Union[Dict[str, Any], Mapping[~KT, +VT_co]])</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.update_from_json" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.update_from_json">update_from_json</a></code>
</p>
<div class="desc inherited"><p><code><a title="xmodel.base.api.BaseApi.update_from_json" href="../xmodel/base/api.html#xmodel.base.api.BaseApi.update_from_json">BaseApi.update_from_json()</a></code> to see superclass's documentation
for this method …</p></div>
</dd>
</dl>
</dd>
<dt id="xmodel_rest.RestAuth"><code class="flex name class">
<span>class <span class="ident">RestAuth</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract type from which all-other api-auth-context's are descended from.
For an example of one used for our Xyngular API's (that can also be used directly with
the Requests 3rd party library), see: <code>xyn_sdk.core.common.Auth</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestAuth(Dependency, Requests_AuthBase):
    &#34;&#34;&#34; Abstract type from which all-other api-auth-context&#39;s are descended from.
        For an example of one used for our Xyngular API&#39;s (that can also be used directly with
        the Requests 3rd party library), see: `xyn_sdk.core.common.Auth`.
    &#34;&#34;&#34;

    def requests_callable(self, settings: RestSettings) -&gt; Requests_AuthBase:
        &#34;&#34;&#34; Right now returns self by default, since by default we will use the current/default
            settings (see `RestAuth.__call__`).

            This is an opportunity to map/return a custom or shared
            `requests.auth.AuthBase` resource customized for the settings that are passed in.

            .. todo:: Put some common logic in here to map passed in settings object
                We want to use a standard set of things we return here to map the passed
                in settings to a callable that the `requests` library can use to inject
                credentials into it&#39;s request.

                For now we just return self and expect the current settings to be used,
                which should be good enough for now.
         &#34;&#34;&#34;
        return self

    def refresh_token(self, settings: RestSettings = None):
        &#34;&#34;&#34; Forces the token/credentials to be refreshed, can use if the token is about to expire.

            When Requests calls to get new token, the expiration should be checked and refreshed
            if needed, which the result of you can pass back [ie: block].

            Args:
                settings (xynlib.orm.base.settings.Settings): Will pass in the settings that
                    need the token refresh.

                    If None (default): The subclass will retrieve the current default settings
                        and use them (the Auth subclass should know what base-settings it needs).
        &#34;&#34;&#34;
        pass

    def __call__(self, request: PreparedRequest):
        &#34;&#34;&#34; Called from requests library to modify request as needed to provide auth.
            Modify the request as needed and return it. Whatever is returned is what is executed.

            `BaseAuth` by default just simply returns the request unmodified.

            If you need Settings, get the default one via, normally you do this by calling
            `xynlib.context.Resource.resource` on the specific
            `xynlib.orm.base.settings.BaseSettings` subclass that you normally use.
        Args:
            request (requests.PreparedRequest): Is the `requests.PreparedRequest` of the request
                that needs the authorization added.
        Returns:
            requests.PreparedRequest: The request object you passed in, modified as needed.
        &#34;&#34;&#34;
        return request</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
<li>requests.auth.AuthBase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.RestAuth.obj"><code class="name">var <span class="ident">obj</span> : <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra …</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xmodel_rest.RestAuth.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying: Optional[Iterable[str]] = Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible …</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.RestAuth.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) ‑> ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> …</p></div>
</dd>
<dt id="xmodel_rest.RestAuth.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) ‑> ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> …</p></div>
</dd>
<dt id="xmodel_rest.RestAuth.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name: str) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.RestAuth.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other …</p></div>
</dd>
<dt id="xmodel_rest.RestAuth.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) …</p></div>
</dd>
<dt id="xmodel_rest.RestAuth.refresh_token"><code class="name flex">
<span>def <span class="ident">refresh_token</span></span>(<span>self, settings: <a title="xmodel_rest.settings.RestSettings" href="settings.html#xmodel_rest.settings.RestSettings">RestSettings</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Forces the token/credentials to be refreshed, can use if the token is about to expire.</p>
<p>When Requests calls to get new token, the expiration should be checked and refreshed
if needed, which the result of you can pass back [ie: block].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>settings</code></strong> :&ensp;<code>xynlib.orm.base.settings.Settings</code></dt>
<dd>
<p>Will pass in the settings that
need the token refresh.</p>
<p>If None (default): The subclass will retrieve the current default settings
and use them (the Auth subclass should know what base-settings it needs).</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_token(self, settings: RestSettings = None):
    &#34;&#34;&#34; Forces the token/credentials to be refreshed, can use if the token is about to expire.

        When Requests calls to get new token, the expiration should be checked and refreshed
        if needed, which the result of you can pass back [ie: block].

        Args:
            settings (xynlib.orm.base.settings.Settings): Will pass in the settings that
                need the token refresh.

                If None (default): The subclass will retrieve the current default settings
                    and use them (the Auth subclass should know what base-settings it needs).
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestAuth.requests_callable"><code class="name flex">
<span>def <span class="ident">requests_callable</span></span>(<span>self, settings: <a title="xmodel_rest.settings.RestSettings" href="settings.html#xmodel_rest.settings.RestSettings">RestSettings</a>) ‑> requests.auth.AuthBase</span>
</code></dt>
<dd>
<div class="desc"><p>Right now returns self by default, since by default we will use the current/default
settings (see <code><a title="xmodel_rest.RestAuth.__call__" href="../xinject/dependency.html#xmodel_rest.RestAuth.__call__">Dependency.__call__()</a></code>).</p>
<p>This is an opportunity to map/return a custom or shared
<code>requests.auth.AuthBase</code> resource customized for the settings that are passed in.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Put some common logic in here to map passed in settings object
We want to use a standard set of things we return here to map the passed
in settings to a callable that the <code>requests</code> library can use to inject
credentials into it's request.</p>
<p>For now we just return self and expect the current settings to be used,
which should be good enough for now.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requests_callable(self, settings: RestSettings) -&gt; Requests_AuthBase:
    &#34;&#34;&#34; Right now returns self by default, since by default we will use the current/default
        settings (see `RestAuth.__call__`).

        This is an opportunity to map/return a custom or shared
        `requests.auth.AuthBase` resource customized for the settings that are passed in.

        .. todo:: Put some common logic in here to map passed in settings object
            We want to use a standard set of things we return here to map the passed
            in settings to a callable that the `requests` library can use to inject
            credentials into it&#39;s request.

            For now we just return self and expect the current settings to be used,
            which should be good enough for now.
     &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel_rest.RestClient"><code class="flex name class">
<span>class <span class="ident">RestClient</span></span>
<span>(</span><span>api: <a title="xmodel_rest.RestApi" href="#xmodel_rest.RestApi">RestApi</a>[M])</span>
</code></dt>
<dd>
<div class="desc"><p>Keep in mind this is sort of the 'base' client class for basic rest-based API's.
I thought about renaming this from "Client" to "RestClient", but it is the most-used
ORM Client class and there are a LOT of references to it.
I decided to leave the name alone.</p>
<p>If we start creating other Client classes for other rest based API's and we discover some
common code they could all use, then you can start putting things in a common <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code>
class.</p>
<p>This class is responsible for communicate with API (or the network in general).
It will figure out the correct endpoint to use and construct a request and execute it
via the Requests 3rd party library.</p>
<p>I grab the auth object via <code>xynlib.orm.rest.RestApi.auth</code>. This object must be usable as an
auth object for 3rd part <code>Requests</code> library.</p>
<p>The <code>xynlib.orm.rest.model.RestModel</code> classes have a order list of URL's attached to the class
that we
try to use in order when we need to find a URL to send/get objects.
The list is at <code>xynlib.orm.base.structure.BaseStructure.model_urls</code>.</p>
<p>See <code>self.url_for_endpoint()</code> for complete details on the url construction process.</p>
<p>Basic Actions:</p>
<ul>
<li><code><a title="xmodel_rest.RestClient.delete_objs" href="#xmodel_rest.RestClient.delete_objs">RestClient.delete_objs()</a></code></li>
<li><code><a title="xmodel_rest.RestClient.send_objs" href="#xmodel_rest.RestClient.send_objs">RestClient.send_objs()</a></code></li>
<li>These call <code><a title="xmodel_rest.RestClient.get" href="#xmodel_rest.RestClient.get">RestClient.get()</a></code> (higher-level methods):<ul>
<li><code><a title="xmodel_rest.RestClient.get" href="#xmodel_rest.RestClient.get">RestClient.get()</a></code></li>
<li><code>RestClient.get_first_for_query</code></li>
</ul>
</li>
</ul>
<p>URL generation:</p>
<ul>
<li><code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> is called from:<ul>
<li><code><a title="xmodel_rest.RestClient.url_for_read" href="#xmodel_rest.RestClient.url_for_read">RestClient.url_for_read()</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_delete" href="#xmodel_rest.RestClient.url_for_delete">RestClient.url_for_delete()</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_send" href="#xmodel_rest.RestClient.url_for_send">RestClient.url_for_send()</a></code></li>
</ul>
</li>
<li><code><a title="xmodel_rest.RestClient.url_for_next_page" href="#xmodel_rest.RestClient.url_for_next_page">RestClient.url_for_next_page()</a></code><ul>
<li>Used to generate URL for the next page of results.</li>
</ul>
</li>
</ul>
<p>Parse Response:</p>
<ul>
<li><code><a title="xmodel_rest.RestClient.parse_json_from_get_response" href="#xmodel_rest.RestClient.parse_json_from_get_response">RestClient.parse_json_from_get_response()</a></code></li>
<li><code><a title="xmodel_rest.RestClient.parse_errors_from_send_response" href="#xmodel_rest.RestClient.parse_errors_from_send_response">RestClient.parse_errors_from_send_response()</a></code><ul>
<li>This can be overridden to provide more detail for model
<code>xynlib.orm.http_state.HttpState</code>.</li>
</ul>
</li>
</ul>
<p>Configuration, use these to customize a sub-class:</p>
<ul>
<li><code><a title="xmodel_rest.RestClient.base_api_url" href="#xmodel_rest.RestClient.base_api_url">RestClient.base_api_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.base_endpoint_url" href="#xmodel_rest.RestClient.base_endpoint_url">RestClient.base_endpoint_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.root_read_url" href="#xmodel_rest.RestClient.root_read_url">RestClient.root_read_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.default_send_batch_size" href="#xmodel_rest.RestClient.default_send_batch_size">RestClient.default_send_batch_size</a></code></li>
<li><code><a title="xmodel_rest.RestClient.enable_send_changes_only" href="#xmodel_rest.RestClient.enable_send_changes_only">RestClient.enable_send_changes_only</a></code></li>
<li><code>RestClient.method_status_to_raise_my_default</code></li>
</ul>
<p>Read-Only attrs:</p>
<ul>
<li><code><a title="xmodel_rest.RestClient.auth" href="#xmodel_rest.RestClient.auth">RestClient.auth</a></code></li>
</ul>
<p>Customization Examples:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class CustomSettings(RestClient):
...     # Make singular=True the default when generating read-urls.
...     root_read_url = URL(singular=True)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>The <code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code> object that is creating this object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestClient(RemoteClient[M]):
    &#34;&#34;&#34;
    Keep in mind this is sort of the &#39;base&#39; client class for basic rest-based API&#39;s.
    I thought about renaming this from &#34;Client&#34; to &#34;RestClient&#34;, but it is the most-used
    ORM Client class and there are a LOT of references to it.  I decided to leave the name alone.

    If we start creating other Client classes for other rest based API&#39;s and we discover some
    common code they could all use, then you can start putting things in a common `RestClient`
    class.

    This class is responsible for communicate with API (or the network in general).
    It will figure out the correct endpoint to use and construct a request and execute it
    via the Requests 3rd party library.

    I grab the auth object via `xynlib.orm.rest.RestApi.auth`. This object must be usable as an
    auth object for 3rd part `Requests` library.

    The `xynlib.orm.rest.model.RestModel` classes have a order list of URL&#39;s attached to the class
    that we
    try to use in order when we need to find a URL to send/get objects.
    The list is at `xynlib.orm.base.structure.BaseStructure.model_urls`.

    See `self.url_for_endpoint()` for complete details on the url construction process.

    Basic Actions:

    - `RestClient.delete_objs`
    - `RestClient.send_objs`
    - These call `RestClient.get` (higher-level methods):
        - `RestClient.get`
        - `RestClient.get_first_for_query`

    URL generation:

    - `RestClient.url_for_endpoint` is called from:
        - `RestClient.url_for_read`
        - `RestClient.url_for_delete`
        - `RestClient.url_for_send`
    - `RestClient.url_for_next_page`
        - Used to generate URL for the next page of results.

    Parse Response:

    - `RestClient.parse_json_from_get_response`
    - `RestClient.parse_errors_from_send_response`
        - This can be overridden to provide more detail for model
          `xynlib.orm.http_state.HttpState`.

    Configuration, use these to customize a sub-class:

    - `RestClient.base_api_url`
    - `RestClient.base_endpoint_url`
    - `RestClient.root_read_url`
    - `RestClient.default_send_batch_size`
    - `RestClient.enable_send_changes_only`
    - `RestClient.method_status_to_raise_my_default`

    Read-Only attrs:

    - `RestClient.auth`

    Customization Examples:

    &gt;&gt;&gt; class CustomSettings(RestClient):
    ...     # Make singular=True the default when generating read-urls.
    ...     root_read_url = URL(singular=True)

    &#34;&#34;&#34;

    # This typehint is only here to provide a better type-hint to IDE&#39;s.
    # The `xynlib.orm.rest.api.RestApi.client` typehint is what is actually used to figure out what
    # RestClient type to allocate.
    api: &#34;RestApi[M]&#34;

    # todo: Perhaps move this into the &#39;xynlib.orm.options.ApiOptions&#39;?
    base_endpoint_url: URLStr = &#34;&#34;
    &#34;&#34;&#34; Whenever a request is executed this is used, it is appended to the base_api_url;

        .. important:: see `RestClient.base_api_url` docs for more details
            It will give you details you how the url construction process works, where
            `base_api_url` comes from and how to override it in various ways.
            *Those same ways also apply to this attribute.*

        .. warning:: Other Notes Related To Auth
            This url is NOT used with Auth obj/class,
            see &#34;Other Notes Related To Auth&#34; in `RestClient.base_api_url` for more details about
            this.
    &#34;&#34;&#34;

    # todo: Perhaps move this into the &#39;xynlib.orm.options.ApiOptions&#39;?
    # todo: Perhaps call this `root_url_for_get` instead?
    root_read_url: URLStr = None
    &#34;&#34;&#34;
    Starting root-url for all get requests; it&#39;s the starting url to every GET request url.
    By default, we use a blank url (aka: None).

    See `RestClient.url_for_endpoint()` and `RestClient.base_api_url` for complete details on the
    url construction process and various ways to customize it (be sure to read both places).

    The purpose of this is easily to modify the URL used for all GET/read requests if necessary
    without having to override a method like `RestClient.url_for_read` (ie: for simple cases).

    .. tip:: Real Example:
        Right now, I use it in `xyn_sdk.datatrax_api.evo.EvoClient.root_read_url`
        to hint that by default every get request singular=True.
    &#34;&#34;&#34;

    # todo: Potentially? Move this into the &#39;xynlib.orm.options.ApiOptions&#39;.
    default_send_batch_size = 500
    &#34;&#34;&#34; Used to set default batch size (if not passed directly into `RestClient.send_objs` method).

        Defaults to 500.

        A RestClient subclass can change this if they have endpoints that are slower or have to
        accept less at a time.
    &#34;&#34;&#34;

    # todo: Move this into the &#39;xynlib.orm.options.ApiOptions&#39;.
    enable_send_changes_only = False  # type: bool
    &#34;&#34;&#34; If `True`, will keep track of changes to api-attributes, and system will only &#39;patch&#39;
        what has actually changed via a PATCH request (normally).
        It only sends the primary &#39;id&#39; field and the fields that actually changed;
        (although this can be changed/customized for other API&#39;s, like hubspot&#39;s for example;
        see hubspot project for example).

        I decided for now this should be opt-in behavior, the default is False for now and
        it will work like it did before, where it sends everything that is not &#39;None&#39;.

        When `xynlib.orm.base.api.BaseApi.update_from_json` is called, it will reset the list of
        changed properties, this
        is normally called after a patch with the latest attribute values from the server.

        If response does not contain the latest attributes for object from server (ie: blank)
        you should still call `xynlib.orm.base.api.BaseApi.update_from_json` with a blank dict so
        it can try and do this housekeeping (I think it will have to assume that everything got
        updated correctly and adjust internal dict of changed attributes like normal).

        .. todo: Verify above behavior, when using API&#39;s that don&#39;t give back latest value
            of attributes when updating them with only the changes.
    &#34;&#34;&#34;

    # todo: Perhaps move this into the &#39;xynlib.orm.options.ApiOptions&#39;?
    base_api_url: URLStr = None
    &#34;&#34;&#34;
    Normally this will come from the `xynlib.orm.rest.settings.RestSettings.api_url` via
    `xynlib.orm.rest.api.RestApi.settings` object.
    But you can override it here if needed.
    For example, you might want to use a `RestClient` sub-class for a non xyngular api.

    Whenever a request is executed this is used, this is used if it&#39;s set to something that looks
    `True` (ie: non-blank string) instead of grabbing the one from api.settings.api_url.
    So you can use this property to &#39;override&#39; the api_url if you want.

    General logic summary of what I am saying above:

    &gt;&gt;&gt; base_url_to_use = self.base_api_url or self.api.settings.api_url

    .. info:: `RestClient.base_endpoint_url` considerations:
        If something is also defined in the `RestClient.base_endpoint_url`,
        we will append that to this base_api_url while determining final url.
        We would then finally append anything passed into the
        method making the request (such as additional Query params or url arguments) and so forth.

        See `RestClient.url_for_endpoint()` for complete details on the url construction process.

    **To Use:**

    You can make a custom-subclass of RestClient and define this property. You can then add this
    custom-subclass as the RestClient to use via custom BaseApi class type-hint
    `client: MyAuthClass`.
    The advantage here is you can reused that same `RestClient` sub-type with other RestModel&#39;s.

    Or if you just want to change it for a single-RestModel, you can just set it before using it
    like so:

    &gt;&gt;&gt; some_model_obj.api.client.base_url_to_use = &#34;api.host.com/base_path&#34;

    If you do it that way, it has to laizly-configure the classes. If you do it via a subclass:

    &gt;&gt;&gt; from xynlib.orm import RestClient
    &gt;&gt;&gt; class MyClient: RestClient
    &gt;&gt;&gt;     base_url_to_use = &#34;api.host.com/base_path&#34;

    Then it will work for other `xynlib.orm.rest.model.RestModel` sub-types, and won&#39;t trigger the
    lazy RestModel configuration code (ie: it will only trigger later if the RestModel&#39;s are truly
    used).

    See `xynlib.orm.base.model.RestModel.__init_subclass__` for more details on what I mean by
    lazily configuring the RestModel class.


    .. warning:: Other Notes Related To Auth
        At the moment the url the auth-client uses will not use what&#39;s in this `RestClient`&#39;s
        `base_api_url`, since the Auth object can be shared among a number of different client
        instances/types.

        If you need something specific for auth that&#39;s different vs standard way, you should
        sub-class
        the `xmodel_rest.auth.RestAuth` sub-type/class you want to customize.
        The sub-class can customize it&#39;s self however it wants.

        You then set a type-annotation/hint via type hint on BaseApi class:
        `xynlib.orm.base.api.BaseApi.auth`.
        This makes the `RestClient` use this auth-type and hence your auth customizations.

        See `RestClient.auth` documentation for a code example of how to do this.

        Real world examples on how to create custom auth/api sub-classes as needed:

        - `xyn_sdk.core.common.Auth`
        - `xyn_sdk.core.common.BaseApi`
    &#34;&#34;&#34;

    # todo: Move this into the &#39;xynlib.orm.options.ApiOptions&#39;?
    method_status_to_raise_by_default: Dict[HTTPMethodType, Set[int]] = None
    &#34;&#34;&#34; A mapping of HTTP-method (HTTPPost/HTTPPut/etc) to a set of status codes that if
        encountered should result in automatically raising an error, with no attempt to parse
        the error response body.

        If set to None, or if method not mapped in dict, the defaults are:

        `DefaultStatusSetToRaiseForSending` when we send objects, which right now has:
        POST/PUT/PATCH: 400, 401, 403, 500-599

        And this for get/delete (work not done yet in RestClient to check this for GET/DELETE).
        GET/DELETE: 400-599
    &#34;&#34;&#34;

    def __init__(self, api: &#34;RestApi[M]&#34;):
        super().__init__(api)
        from xmodel_rest import RestModel
        if not issubclass(api.model_type, RestModel):
            raise XynRestError(f&#34;You have created a rest api with a model type ({api.model_type}) &#34;
                               f&#34;that is not a subclass of RestModel.&#34;)

    # todo: create public alias: `plain_request = _wrap_request`
    # todo: xyndw likes to execute custom requests but take advantage of the _wrap_request.
    #
    # todo: I think it might also want to auto-use my auth-class. I think it would be nice
    # todo: to have an easy-way to execute a Requests.request object with my auth and wrapper.

    # ------------------------------------------------
    # --------- Send Requests to API Methods ---------

    def delete_obj(self, obj: M):
        &#34;&#34;&#34;
        Calls `RestClient.delete_objects` with passed in object in a list.

        Args:
            obj (xynlib.orm.rest.model.RestModel): model to delete.
        &#34;&#34;&#34;
        self.delete_objs([obj])

    def format_body_for_delete(
        self, objects: Sequence[Tuple[RestModel, JsonDict]], url: URLMutable
    ):
        return None

    def delete_objs(self, objs: Iterable[M], url: URLStr = None):
        &#34;&#34;&#34;
        Allows you to delete a bunch of objects, bulk-deleting if possible.
        Automatically falls back to one at a time if necessary.

        Regardless of how it does it, it will attempt to delete every object passed in.

        The objects must have their `xynlib.orm.rest.model.RestModel.id` set to something,
        otherwise they will be skipped.

        Args:
            objs (Iterable[xynlib.orm.rest.model.RestModel]): The objects to delete
                (only attribute needed on them is `xynlib.orm.rest.model.RestModel.id`).
            url (xynlib.url.URLStr): Optional URL to append onto final URL.
        &#34;&#34;&#34;
        # Note for future: Keeping `objs` declared as an Iterable for use with generators in the
        # future [etc, etc].
        preped_objs = self._create_deque_verify_and_reset_http_state(objs)
        url = URL.ensure_url(url)

        def do_delete_request(url: URL, objects: Sequence[M]):
            # todo: Move this into `_wrap_request`, pass in high-level url object to it.
            url = URLMutable(url)
            url_methods = url.methods
            assert len(url_methods) == 1, (
                f&#34;Should only be one method ({url_methods}) for url ({url}) for delete.&#34;
            )

            id_list = list(map(lambda x: x.id, objects))
            # todo: We don&#39;t format &#39;query&#39; params right now inside URL [only the path portion]
            #       so for now we need to do that ourselves here. But in the future, we could
            #       generalize it and have URL format the query param for us!!!
            if not url.singular:
                url.query_add(
                    key=&#34;id&#34;,
                    value=id_list,
                )

            json_body = self.format_body_for_delete(objects, url)

            url_str = url.url()

            response = self._wrap_request(
                lambda: self._requests_session.request(
                    method=url_methods[0],
                    url=url_str,
                    auth=self.auth.requests_callable(self.api.settings),
                    json=json_body,
                    timeout=30
                ),
                creating_objects=False
            )

            if response.status_code &gt;= 300:
                log.error(
                    f&#34;[DELETE]: Non-Success Status ({response.status_code}) from url &#34;
                    f&#34;({url}) - see debug log level for raw response.&#34;
                )

                for obj in objects:
                    obj.api.response_state.had_error = True

            text = response.text
            if text is not None and len(text) &gt; 0:
                log.debug(
                    f&#34;RestClient.delete_objs() - url ({url}) - raw response ({response.text})&#34;
                )

        def debug_log_item(item):
            log.debug(f&#34;Sending DELETE for ({item})&#34;)

        self._do_http_method_on_objs(
            objects=preped_objs,
            url_generator=self.url_for_delete,  # noqa: See note about python 3.8
            object_to_request_item=lambda x: x,  # No need to do any extra work
            request_item_to_obj=lambda x: x,  # No need to do any extra work
            log_request_item=debug_log_item,
            request_generator=do_delete_request,
            send_limit=100,
            url=url
        )

    def send_objs(
            self, objs: &#34;Iterable[RestModel[M]]&#34;, *, url: URLStr = None, send_limit: int = None
    ):
        &#34;&#34;&#34;
        Sends `objs` to the API as efficiently as possible. If you specify `url`, it will be
        appended onto the final candidate url via `xynlib.url.URLMutable.append_url`.
        If the url is still valid (via `xynlib.url.URL.is_valid`) then that&#39;s the final
        url that will be used.

        See `RestClient.url_for_endpoint` for details on how the base URL is found and then how
        our passed in url is appended and final url is formatted.

        Args:
            objs (Iterable[xynlib.orm.rest.model.RestModel]): Objects to send to API.
                If an object has not changes and `RestClient.enable_send_changed_only` is `True`
                then it will be skipped.  Otherwise the entire object is sent.

            url (xynlib.url.URLStr): url to append to final candidate url.

            send_limit (int): How many objects to send at a time (batch size).
                Leave as None to use the default. You can override it by passing a number here.

        Returns:

        &#34;&#34;&#34;
        url = URL.ensure_url(url)

        def model_to_request_item(obj: &#34;RestModel[M]&#34;) -&gt; &#34;Optional[Tuple[RestModel, JsonDict]]&#34;:
            json: JsonDict = obj.api.json(
                only_include_changes=self.enable_send_changes_only,
                log_output=True
            )
            if json is None:
                log.debug(f&#34;API Obj {obj} did not have any changes to send, skipping.&#34;)
                return None
            # Make a tuple and return it as one of the items to send to `_send_objs_to_url`.
            item = (obj, json)
            return item

        def request_item_to_model(item: Any):
            return item[0]

        def debug_log_item(item):
            log.debug(f&#34;Sending JSON ({item[1]})&#34;)

        starting_objects = list(xloop(objs))
        objs_by_endpoint = self._create_deque_verify_and_reset_http_state(starting_objects)
        self._do_http_method_on_objs(
            objects=objs_by_endpoint,
            url_generator=self.url_for_send,  # noqa: See note about python 3.8
            object_to_request_item=model_to_request_item,
            request_item_to_obj=request_item_to_model,
            log_request_item=debug_log_item,
            request_generator=self._send_objs_to_url,
            send_limit=send_limit,
            url=url
        )

        # If no unhandled error happened (ie: exception),
        # we will get to this point.
        for obj in starting_objects:
            obj.api.did_send()

    # ---------------------------------------
    # --------- GET via API Methods ---------

    def get(
            self,
            query: Dict[str, Any] = None,
            *,
            top: int = None,
            fields: Union[FieldNames, DefaultType] = Default,
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34;
        Returns result of calling `RestClient.get` with the query converted into a URL for you.

        Args:
            fields (xynlib.orm.types.FieldNames): You can pass in a list of fields.
                We will attempt to pass this to API if
                possible. The idea is the API will only return the list fields.
                If the API honors it, then they will be the only ones set on the objects.
                If the API returns more fields, they will still be set on the object.

                The field &#39;id&#39; will always be included as a field,
                no need to add that one your self.

                If `xynlib.orm.types.Default` or Empty List (default):
                All fields will be retrieved except the ones ignored by
                (set via `xynlib.orm.fields.Field.exclude`,you can get the full list
                via `xynlib.orm.base.structure.BaseStructure.excluded_field_map`).

                If `None`: Nothing about what fields to include/exclude will be passed to API.
                It should grab everything.

            query: Dictionary for query filters.
            top: Top/Maximum number of objects to return.
        Returns:
            Iterable[xynlib.orm.rest.model.RestModel]: A `Generator`, that when ran will return all
                model objects one at a time (paginating as needed while running the generator).
        &#34;&#34;&#34;
        comps = None
        if query:
            comps = URLMutable().append_query(query)

        return self.get_url(comps, top, fields=fields)

    def get_url(
            self, url: URLStr = None, top: int = None,
            fields: FieldNames = Default
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34;
        The most basic public method for get requests to API.

        Executes a basic GET request for URL, and returns back a list of objects base
        on the BaseApi you pass in.  If `top` defined, we will append a &#39;limit&#39; query param
        for you and only return at most that many regardless of how many are really
        returned from BaseApi.

        Args:
            fields (xynlib.orm.types.FieldNames): You can pass in a list of fields.
                We will attempt to pass this to API if
                possible. The idea is the API will only return the list fields.
                If the API honors it, then they will be the only ones set on the objects.
                If the API returns more fields, they will still be set on the object.

                The field &#39;id&#39; will always be included as a field,
                no need to add that one your self.

                If `xynlib.orm.types.Default` or Empty List (default):
                All fields will be retrieved except the ones ignored by
                (set via `xynlib.orm.fields.Field.exclude`,you can get the full list
                via `xynlib.orm.base.structure.BaseStructure.excluded_field_map`).

                If `None`: Nothing about what fields to include/exclude will be passed to API.
                It should grab everything.

            url (xynlib.url.URLStr): URL to append on the end of the final constructed URL.
                If you specify `url`, it will be
                appended onto the final candidate url via `xynlib.url.URLMutable.append_url`.
                If the url is still valid (via `xynlib.url.URL.is_valid`) then that&#39;s the final
                url that will be used.

                See `RestClient.url_for_endpoint` for details on how the base URL is found and then
                how our passed in url is appended and final url is formatted.
            top (int): The maximum number of objects to iterate though via returned `Generator`.
                We will attempt to tell API to limit the returns results to this.
                But even if API returns more objects in the response only this many objects will
                be returned (via Generator). We will also paginate though result set until
                we get enough objects. We will return less then what you pass in here if
                after paginating the results there are no more left.
        Returns:
            Iterable[xynlib.orm.rest.model.RestModel]: A `Generator`, that when ran will return all
                model objects one at a time (paginating as needed while running the generator).
        &#34;&#34;&#34;

        url_for_reading = self.url_for_read(url=url, top=top, fields=fields)
        return self._get_objects(url_for_reading, top, fields)

    # ------------------------------------------
    # --------- Implementation Details ---------

    # noinspection PyRedeclaration
    @property
    def auth(self) -&gt; RestAuth:
        &#34;&#34;&#34;
        This is the auth object used by client, to set what type should be used for this,
        in your `xynlib.orm.base.api.Api` sub-class, make a type-hint like this in the
        Api subclass definition:

        &gt;&gt;&gt; from xmodel_rest import RestApi, RestAuth
        &gt;&gt;&gt; from typing import TypeVar
        &gt;&gt;&gt;
        &gt;&gt;&gt; class MyAuth(BaseAuth):
        &gt;&gt;&gt;    pass  # Put your auth stuff here
        &gt;&gt;&gt;
        &gt;&gt;&gt; M = TypeVar(&#34;M&#34;)
        &gt;&gt;&gt; class MyApi(BaseApi[M]):
        ...     auth: MyAuth

        Doing that is enough, `xynlib.orm.base.api.Api` will see the type-hint and will grab one of
        that
        type from the `xynlib.context.Context`. `RestClient` gets `xynlib.orm.base.auth.BaseAuth`
        instance from `xynlib.orm.base.api.Api.auth` via `RestClient.api`.
        In the example above, it would be a `MyAuth`.

        Defaults to `xynlib.orm.base.auth.BaseAuth`, which will not do any auth by default.
        See `xyn_sdk.core.common.Auth` for a concrete subclass that implments auth for
        Xyngular API&#39;s.

        &#34;&#34;&#34;
        return self.api.auth

    # noinspection PyMethodMayBeStatic
    # We want to keep this as non-static, for more flexibility when overriding in subclass.
    def parse_json_from_get_response(
            self,
            *,
            url: URL,
            response: requests.Response
    ) -&gt; Optional[JsonDict]:
        &#34;&#34;&#34;
        When we have a response for a GET request, this is called to parse the JSON out of it.

        For a real-world example of a override of this method (among other overrides) see
        `hubspot.api.common.RestClient`.

        ## Parsing Error

        First thing we look for are handling response-level errors and conditions,
        such as 500 errors. Or situations where there is no valid JSON to extract from the
        response (invalid JSON syntax).

        By default if `response.status_code` is:

        - 404: Log warning.
        - 401/403/5xx/4xx: Raise an XynRestError.
            - We will try to parse JSON to get some more detail out of it to log with;
                we then raise an XynRestError.

        ## Parsing JSON

        This basic REST `RestClient` expects:
        - For multiple results: a dict with a key that has a list of dicts,
            or a list of dicts. We could have a list with just one dict in it.
        - For a request that always has a single result: a single dict is usually what is needed.

        For each of these dict(s), the standard dict-format is:

        &gt;&gt;&gt; {&#34;attr-name&#34;: &#34;attr-value&#34;}

        If it&#39;s something else, this is normally handled in the
        `xynlib.orm.base.api.BaseApi.update_from_json` / `xynlib.orm.base.api.BaseApi.json` methods
        associated with Model via type-hint on `xynlib.orm.rest.model.RestModel.api`.
        You can override theose methods to manipulate the json-dict you get passed
        to the standard format before passing it to the `super()` implementation.
        You can see an example of this in `hubspot.api.common.BaseApi.json`.

        If the structure outside of the dict is diffrent, then that&#39;s handled in this
        method unless the only diffrence is the key used to get the multiple results.
        You can easily configure the key to use to get the multiple results list via
        `xynlib.orm.base.structure.BaseStructure.multiple_results_json_path`.

        Example of settting `xynlib.orm.base.structure.BaseStructure.multiple_results_json_path`:

        &gt;&gt;&gt; from xmodel_rest import RestModel
        &gt;&gt;&gt;
        &gt;&gt;&gt; class MyModel(
        ...     RestModel[&#34;MyModel&#34;],
        ...     multiple_results_json_path=&#34;response_list&#34;
        ... )
        ...     first_name: str
        &gt;&gt;&gt;
        &gt;&gt;&gt; # A response like this from API would now work correctly with MyModel:
        &gt;&gt;&gt; {
        ...     &#34;response_list&#34;: [
        ...         {&#34;id&#34;: 1, &#34;first_name&#34;: &#34;Gordan&#34;}.
        ...         {&#34;id&#34;: 2, &#34;first_name&#34;: &#34;JD&#34;}
        ...     ]
        ... }

        Most of the attributes `xynlib.orm.base.structure.BaseStructure` are configurable via
        class arguments, like you see in the above example.
        For more information on this see:

        - `xynlib.orm.base.structure.BaseStructure.configure_for_model_type`
        - `xynlib.orm.base.model.RestModel.__init_subclass__`
        - `xynlib.orm.base.model.RestModel`

        Args:
            url (URL): The URL we got. Keep in mind the auth provider can add or modify URL if
                needed,
                but it won&#39;t be visible in the url passed here. Therefore, you can feel free to log
                the url out if needed, as it should not contain any secrets.
            response (requests.Response): The request response, from the Requests library.
                Dive into the JSON, and parse out enough to get a dict for a single object
                or a dict with key to a list of dicts, or a list of dicts.

                See general doc-comment for `RestClient.parse_json_from_get_response` for more
                details.
        Returns:
            Optional[xynlib.orm.types.JsonDict]: None if 404-NotFound response,
                otherwise a JsonDict.
        Raises:
            XynRestError: Raise if there is a 4xx error that is NOT a 404, or a &gt;=500 error.
        &#34;&#34;&#34;
        status = response.status_code

        if status == 404:
            log.warning(
                f&#34;API result status 404 for GET on url ({url}). &#34;
                f&#34;Returning blank list/None.&#34;
            )
            return None

        if status == 401 or status == 403:
            try:
                detail = response.json().get(&#39;detail&#39;)
            except ValueError:
                detail = response.text

            raise XynRestError(
                f&#34;API result returned unauthorized ({status}) for url &#34;
                f&#34;({url}) detail: ({detail})&#34;
            )

        if status &gt;= 500:
            raise XynRestError(
                f&#34;API result status ({status}) &gt;= 500 for GET on url &#34;
                f&#34;({url}) with raw response text ({response.text}).&#34;
            )

        if status &gt;= 400:
            raise XynRestError(
                f&#34;API result status ({status}) is a 4xx (and NOT 404/401/403) for GET on url &#34;
                f&#34;({url}) for response ({response.text}).&#34;
            )

        try:
            return response.json()
        except ValueError as e:
            raise XynRestError(
                f&#34;Unparsable JSON in response for status ({status}) for url ({url}) with &#34;
                f&#34;response text ({response.text}).&#34;
            )

    def parse_errors_from_send_response(
            self,
            *,  # Tells Python the following are named-arguments only:
            url: URL,
            json: JsonDict,
            response: requests.Response,
            request_objs: &#39;List[RestModel]&#39;
    ):
        &#34;&#34;&#34;
        You can override this to provide more details to the individual objects.
        `RestClient` call this to parse the errors into the objects http-state
        (keep reading further below for more about that)
        and will check for error&#39;s on the objects and call any error handlers for you.

        .. note:: For more details about error handlers:

            Error handlers let you more easily handle errors on individual objects,
            since this method here will hopefully parse the error details in such a
            way to easily check for then.

            Ways to add Error Handlers and what they may use to check for errors and retry sends:

            - `xynlib.orm.options.ApiOptions.error_handler`
            - `xynlib.orm.http_state.HttpState.error_handler`
            - `xynlib.orm.http_state.HttpState.has_field_error`
            - `xynlib.orm.http_state.HttpState.retry_send`

        For a real-world example of a override of this method (among other overrides) see:

        - `hubspot.api.common.RestClient`.
        - `xyn_sdk.core.common.RestClient.parse_errors_from_send_response`

        By default, this method simply sets the `xynlib.orm.http_state.HttpState` you can
        get this object via `xynlib.orm.base.api.BaseApi.http` state of each request_objs with:

        - `xynlib.orm.http_state.HttpState.response_code` = Response code.
        - `xynlib.orm.http_state.HttpState.had_error` = `True`
        - `xynlib.orm.http_state.HttpState.errors` = A list with the
            `response.text` as the only item.
            - And override of `RestClient.parse_errors_from_send_response` can provide more list
                items and other info (keep reading below for more details).

        After doing that by default this method will get
        `RestClient.method_status_to_raise_by_default`
        and if there is nothing defined for the method in that dict then we use
        `DefaultStatusSetToRaiseForSending`.

        If the status code is found what is found above or if the status code is
        `&gt;=600` then an `xynlib.orm.errors.OrmError` is raised.

        Feel free to override this method and provide more details in via
        `xynlib.orm.base.api.BaseApi.http`; or do something entirely different.

        .. tip:: Ways to set/provide more detailed error information + retrying

            Using object at `xynlib.orm.base.api.BaseApi.http` you can uses these methods to both
            provide more info and retry request:

            - `xynlib.orm.http_state.HttpState.add_field_error`
            - `xynlib.orm.http_state.HttpState.retry_send`

            You can see a real-world example using these ^ at:

            - `xyn_sdk.core.common.RestClient.parse_errors_from_send_response`
            - `hubspot.api.common.RestClient.parse_errors_from_send_response`
            - `hubspot.processors.update_contact.execute_transactions`

        It is valid to call `xynlib.orm.http_state.HttpState.retry_send`
        using `xynlib.orm.base.api.BaseApi.http`
        via model object&#39;s `xynlib.orm.rest.model.RestModel.api`
        in this methods and in any error-handlers if you needed to retry a request for a
        particular object.

        You can even change a field/attribute value on a model object and tell it to retry
        again if you pass `xynlib.orm.http_state.ResponseStateRetryValue.EXPORT_JSON_AGAIN` into
        `xynlib.orm.http_state.HttpState.retry_send`, like so:

        &gt;&gt;&gt; from xmodel.remote.response_state import ResponseStateRetryValue
        &gt;&gt;&gt; from xmodel_rest.model import RestModel
        &gt;&gt;&gt;
        &gt;&gt;&gt; model_obj: RestModel  # &lt;-- Some RestModel Object
        &gt;&gt;&gt; model_obj.api.response_state.retry_send(ResponseStateRetryValue.EXPORT_JSON_AGAIN)

        See docs for `xynlib.orm.http_state.HttpState.retry_send` for more details.

        Args:
            url (xynlib.url.URL): The [almost] final URL that was used to make the request.
                The only thing possibly
                missing is anything the &#39;Auth&#39; class adds to the URL for authentication purposes
                (which could have been a header and not any URL changes).

                This URL is guaranteed to have one and only method assigned to it, the method used
                for the original request.
            json (xynlib.orm.types.JsonDict): If we were able to parse any json from the response,
                we provide that here.
            response (requests.Response): Response of the request that had the error.
            request_objs (List[xynlib.orm.rest.model.RestModel]): The objects, in the order we sent
                them in the request.
        &#34;&#34;&#34;
        # If the response was successful, and we don&#39;t know what the body contents look like,
        # so there is nothing more to do.  Subclasses of RestClient class should override this
        # method if there are more things inside response body to indicate errors for particular
        # objects if we sent more then one object in the same request.
        if response.status_code &lt; 300:
            return

        # TODO: Consolidate this and self.get_all_objects() error handling logging/exceptions.

        url_methods = url.methods
        assert len(url_methods) == 1, (
            f&#34;Should only be one method ({url_methods}) for url ({url}).&#34;
        )

        http_method = url_methods[0]
        status_code = response.status_code

        log.warning(
            f&#34;({http_method}): Non-success request response code ({status_code}) for url &#34;
            f&#34;({url}) with raw response ({response.text}).&#34;
        )

        # If we failed due to an authorization issue, we need to stop processing and raise
        # an exception, there is something wrong with our configuration, and we are very
        # likely to keep failing, so might as well stop here.
        status_map = self.method_status_to_raise_by_default
        if not status_map:
            status_map = {}

        # todo: I think I would like to try any error handlers first before defaulting
        #       back to an exception.
        statuses_to_raise = status_map.get(
            http_method, DefaultStatusSetToRaiseForSending
        )

        for obj in request_objs:
            # Communicate to each object about its current api http error status.
            http = obj.api.response_state
            http.had_error = True
            http.response_code = status_code

            # Likely the raw response has more details that pertain to the situation,
            # so just put the response text in the http errors list.
            http.errors = [response.text]

        # &gt;= 600 should never happen, it means that the http server is totally screwed up.
        if status_code &gt;= 600 or status_code in statuses_to_raise:
            try:
                # Try to get some detail out of the response.
                #
                # todo: (
                #     This is Xyngular specific, consider moving this to the
                #     xyn_sdk.core.common.RestClient subclass
                #  ).
                detail = response.json().get(&#39;detail&#39;)
            except (ValueError, AttributeError):
                detail = None

            raise XynRestError(
                f&#34;API result for url ({url}) returned &#34;
                f&#34;status ({status_code}), with detail &#34;
                f&#34;({detail}) with raw response &#34;
                f&#34;({response.text}) with objects ({request_objs}).&#34;
            )

    # -----------------------------------
    # --------- Private Methods ---------
# _objs_by_endpoint

    def _create_deque_verify_and_reset_http_state(
            self, objs: &#39;Iterable[RestModel[M]]&#39;
    ) -&gt; &#39;Deque[RestModel[M]]&#39;:
        &#34;&#34;&#34; Goes though all objects, reset&#39;s their http state, verifies they can be used
            by this RestClient object (check&#39;s their API object is the same as ours).

            After this, it adds them to a `deque` and returns that.

            .. todo:: I am thinking of separating them by their BaseApi object instance and then
                returning ones that don&#39;t match self.api in a separate dict that would let
                the send/delete_objs method
                call the send/delete_objs method on their proper RestClient instance/object
                (ie: redirect call to the correct RestClient instance).
            ..
        &#34;&#34;&#34;
        # My API, to compare to model&#39;s type `RestModel.api` api object.
        api = self.api
        result = deque()

        # todo: Think about separating the objects by their BaseApi/RestClient instance and
        #  redirect call&#39;s of ones that don&#39;t match self.api to their proper RestClient instance.
        for obj in objs:
            obj.api.response_state.reset()

            if api is type(obj).api:
                result.append(obj)
                continue

            raise XynRestError(
                f&#34;For right now, you can&#39;t mix different RestModel object types in the same &#34;
                f&#34;list and send/delete them all in one call to `RestClient.send_objs` or &#34;
                f&#34;`RestClient.delete_objs`.  Separate them into different lists and call&#34;
                f&#34;RestClient separately.\n&#34;
                f&#34;&#34;
                f&#34;Details:\n&#34;
                f&#34;&#34;
                f&#34;I ({self}) was passed a RestModel object ({obj}) with api &#34;
                f&#34;({type(obj).api}); this api instance normally works with &#34;
                f&#34;({type(obj).api.model_type}) type models.\n&#34;
                f&#34;&#34;
                f&#34;I normally only work with ({api.model_type}) type objects, but I got a &#34;
                f&#34;{type(obj).api.model_type} type object instead. &#34;
                f&#34;You can&#39;t mix different model types in the same list and send them to the &#34;
                f&#34;same RestClient subclass instance.\n&#34;
                f&#34;&#34;
                f&#34;Each RestClient is set to work only with one model type. &#34;
                f&#34;You need to use `{type(obj).api.model_type}.api.client` or &#34;
                f&#34;`obj_instance.api.client` for the correct client instance for that &#34;
                f&#34;model type/object.\n&#34;
                f&#34;&#34;
                f&#34;The RestModel.api object instance must match what&#39;s put in RestClient.api. &#34;
                f&#34;It could be a single RestClient instance got multiple-different model types &#34;
                f&#34;to send at the same time OR the RestClient class was setup incorrectly.&#34;
            )

        return result

    def format_body_for_get(
        self,
        url: URLMutable,
        top: int = None,
        fields: Union[FieldNames, DefaultType] = Default
    ):
        raise XynRestError(
            &#34;We don&#39;t know how to generically format this. For now override the method.&#34;
        )

    def _get_objects(
        self,
        url: URLMutable,
        top: int = None,
        fields: Union[FieldNames, DefaultType] = Default
    ) -&gt; Iterable[M]:
        &#34;&#34;&#34;
        Return objects based on URL, internal method only
        [subclasses can call me still if necessary].

        Args:
            url (URLMutable): URLMutable obj that can produce the URL to get the objects.
            top (int): Only return first top/maximum number of objects.
            request_method (function): method used to send request
        Returns:
            Iterable[xmodel_rest.model.RestModel]: Sequence/List of
                `xmodel_rest.model.RestModel` objects.
        &#34;&#34;&#34;
        api = self.api

        objs = []
        object_count = 0
        obj_type = api.model_type
        structure = api.structure
        multiple_results_json_path = structure.multiple_results_json_path

        # todo: Make this a general option, instead of hard-coded.
        #       Right now the below is for an optimization, it speeds up the API requests.
        #       We don&#39;t use the fields at the moment.

        # We want to use the /v1/endpoint/id_value version instead of the /v1/endpoint?id=id_value
        # version if there is a ?id=id_value with a single value in query.

        singular = url.singular

        # todo: figure out a better way [ie: with new singular var or something].
        # singular_id = url.query_id_if_singular()
        # if singular_id is not None:
        #     # So, we want to change the URL from /endpoint?id= to /endpoint/id
        #     # todo: make the primary key name configurable per-api, don&#39;t assume it&#39;s &#39;id&#39;.
        #     url.append_path(singular_id)
        #     url.query_remove(key=&#34;id&#34;)
        #     singular = True

        use_get = HTTPGet in url.methods or len(url.methods) == 0
        if not use_get and HTTPPost not in url.methods:
            raise XynRestError(
                &#39;We are currently only supporting HTTPGet and HTTPPost for retrieving objects.&#39;
            )

        get_child_objects = api.option_for_name(&#34;auto_get_child_objects&#34;)
        if use_get:
            url = URLMutable(url, methods=(HTTPGet,))
        else:
            url = URLMutable(url, methods=(HTTPPost,))
            # We are assuming for now that the json_body will stay the same and if there is any
            # pagination it will be added to the url as a query param.
        current_url_str = url.url()
        try:
            while current_url_str:
                if isinstance(current_url_str, URL):
                    current_url_str = current_url_str.url()
                if use_get:
                    result = self._wrap_request(
                        lambda: self._requests_session.get(
                            current_url_str,
                            auth=self.auth.requests_callable(self.api.settings),
                            timeout=30
                        ),
                        creating_objects=False
                    )
                else:
                    post_url = URLMutable(current_url_str)
                    json_body = self.format_body_for_get(post_url, top, fields)
                    current_url_str = post_url.url()
                    log.debug(
                        f&#34;Going to read from ({current_url_str}) via (POST) with body &#34;
                        f&#34;({json_body}).&#34;
                    )
                    result = self._wrap_request(
                        lambda: self._requests_session.post(
                            current_url_str,
                            json=json_body,
                            auth=self.auth.requests_callable(self.api.settings),
                            timeout=30
                        ),
                        creating_objects=False
                    )

                json = self.parse_json_from_get_response(url=url, response=result)
                if json is None:
                    return []

                results_list = []

                # todo: Handle the `singular is None` option, and examine result and guess.
                if singular:
                    results_list.append(json)
                else:
                    if not isinstance(json, list):
                        if multiple_results_json_path in json:
                            results_list = json[multiple_results_json_path]
                        else:
                            # todo: We could potentially just assume the dict we have is an
                            #   single/normal object (and not a list of them).
                            raise XynRestError(
                                f&#34;Result from api was a dict, but the multiple_results_json_path &#34;
                                f&#34;({multiple_results_json_path}) key was not in the result dict &#34;
                                f&#34;({json}). Did we expect singular or multiple results at &#34;
                                f&#34;url ({url})?&#34;
                            )
                    else:
                        results_list = json
                    if results_list is None:
                        # Might be a single object-result, or no pagination
                        # todo: Consider adapting to no-pagination or single-object response?
                        break

                objs: &#39;List[RestModel]&#39; = []

                for obj_dict in results_list:
                    objs.append(obj_type(obj_dict))

                if get_child_objects:
                    from xmodel.common.children import bulk_request_lazy_children
                    # todo: idea:  use a `with` statement directly on `api.options`
                    #   have it return object to modify and properly activate it (dynamic class?).

                    # Create new ApiOptionsGroup, that way we can set a few temporary options.
                    # Once the `with` is done it will revert back-to previous ApiOptionsGroup.
                    with ApiOptionsGroup():
                        # We are configuring a context so that when an object retrieves
                        # children of its own type it doesn&#39;t recursively grab their children.
                        # I think we can improve this in some way by using an `Options` resource
                        # or some such instead directly.... for now I&#39;m going to leave it like
                        # this.
                        api.options.auto_get_child_objects = False
                        bulk_request_lazy_children(objs)

                for obj in objs:
                    object_count += 1
                    yield obj
                    if top is not None and object_count &gt;= top:
                        return

                # Check if we used the single-result end point.
                if singular:
                    break

                # This is a standard method to find the next page of results url.
                # If the value is None, the while loop will exit for us automatically.
                current_url_str = self.url_for_next_page(
                    original_url=url,
                    json_response=json
                )

        except requests.exceptions.RequestException as exc:
            # Transform this exception into a more standard one, which will eventually be caught
            # and logged out appropriately.
            raise XynRestError(
                f&#34;There was a problem connecting to api endpoint ({url}), &#34;
                f&#34;due to a request exception ({exc}) via ({self}).&#34;
            )

    # todo: When we use Python 3.8 (soon), have _URLGenerator inherit from Protocol, we only care
    #   about defining the method signature, don&#39;t care about the specific type...
    #   ie: structural subtyping, see https://www.python.org/dev/peps/pep-0544/#callback-protocols
    class _URLGenerator:
        def __call__(self, model_objs: &#39;List[RestModel[M]]&#39;, url: URL) -&gt; Union[
            UseSingularValueType, GeneratedURL, URL
        ]:
            raise NotImplementedError(
                &#34;Use a concrete url generator, &#34;
                &#34;see `xmodel_rest.client.RestClient.url_for_delete` &#34;
                &#34;for an example.&#34;
            )

    def _do_http_method_on_objs(
            self,
            objects: Deque[RestModel[M]],
            object_to_request_item: Callable[[RestModel[M]], Any],
            request_item_to_obj: Callable[[Any], RestModel[M]],
            url_generator: _URLGenerator,  # See todo on _URLGenerator, talks about Python 3.8.
            log_request_item: Callable[[Any], None],
            request_generator: Callable,  # See doc-comment for call signature for now.
            send_limit: int = None,
            log_limit: int = 4,
            url: URL = None
    ):
        &#34;&#34;&#34;
        Internal method to execute a URL (with it&#39;s corresponding method) on a set of objects.
        The url_generator passed in produces a URL as it&#39;s return value.  This URL should only
        have one method attached to it, the method to use for the request.

        .. todo:: Perhapse make this method public in the near-future.

        Args:
            objects: RestModel objects to send to API.
            url: If provided, URL gets appended to final url before it&#39;s validated.
                If valid, the end result is used to connect to API for the request.
            url_generator: Generator for URL, needs a method that can be called like this:

                &gt;&gt;&gt; url_for_send(model_objs=[v[0] for v in objects], url=url)

                See `RestClient.url_for_send` for an example.
            request_generator: Generates and executes request, needs a method that can be
                called like this:

                &gt;&gt;&gt; _send_objs_to_url(url=final_url, objects=buffer_list)

                See `RestClient._send_objs_to_url` for an example.
            object_to_request_item: Generator to convert an object into and item,
                which will eventually be passed to request_generator.
                If requested, we may resend the request without having to convert
                the object again (we will buffer the converted item for you).

                It gets called like this:

                &gt;&gt;&gt; item_to_send_to_request_generator = object_to_request_item(obj)

                see method definition for `RestClient.send_objs` for an example.
            request_item_to_obj: Callable/Method to extract the RestModel object out of the
                item.
            log_request_item: This is a method I can call when I want to log about what
                will be sent for converted item.  If we are going to Post/Patch JSON,
                we would want to log the JSON [for example].

                It gets called like this:

                &gt;&gt;&gt; request_item_send_logger(item)

                Generally, you&#39;ll want to log this on the debug log level, something like this:

                &gt;&gt;&gt; log.debug(f&#34;Will send json: {item[1]}&#34;)

            send_limit: How many objects to send at a time, defaults to 500.
            log_limit: How many objects to log, defaults to the first 3 sent.
        &#34;&#34;&#34;
        api = self.api

        if len(objects) == 0:
            return

        if send_limit is None:
            send_limit = self.default_send_batch_size

        # Convert the list objects into a list of dicts to send via json, this holds the json.
        request_objs: List[RestModel[M]] = []

        assert send_limit &gt; 0

        BufferItem = Tuple[RestModel, JsonDict]
        objects: Deque[Union[RestModel, BufferItem]] = objects.copy()

        # todo:
        #  Right now all endpoints support simultaneous update/create with multiple objects
        #  at the same time. If ever need to change this assumption, we can order create first
        #  transactions than updates into separate. For now, I am not going to worry about it.

        # We create a list of objects and their json documents.
        buffer_list: Deque[BufferItem] = deque()
        num_objects_skipped = 0

        def log_about_skipped_objects_if_needed():
            nonlocal num_objects_skipped
            if not num_objects_skipped:
                return
            log.info(f&#34;Skipped ({num_objects_skipped}) because there are no changes to send.&#34;)
            num_objects_skipped = 0

        while len(objects) &gt; 0 or len(buffer_list) &gt; 0:
            buffer_count = len(buffer_list)
            objects_count = len(objects)

            if buffer_count &gt;= send_limit or objects_count &lt;= 0:
                log_about_skipped_objects_if_needed()
                model_objs = [request_item_to_obj(i) for i in buffer_list]

                generated_url: Union[UseSingularValue, GeneratedURL] = url_generator(
                    model_objs=model_objs,
                    url=url
                )

                if generated_url and isinstance(generated_url, URL):
                    generated_url = GeneratedURL(url=generated_url, models=model_objs)

                if generated_url and generated_url is not UseSingularValue:
                    buffer_items_to_send: Union[List[BufferItem], Sequence[BufferItem]] = []
                    buffer_items_to_keep: List[BufferItem] = []
                    if len(model_objs) == len(generated_url.models):
                        buffer_items_to_send = buffer_list
                    else:
                        model_hash_ids_for_url = {id(x) for x in generated_url.models}
                        for x in buffer_list:
                            # todo:
                            #  We could &#39;continue&#39; back to to the `while len(...)...` statement
                            #  above to try to fill in more objects to send if we can&#39;t send
                            #  everything right now, so we can maximize how many we send
                            #  pre-request, but that&#39;s a future optimization for right now.
                            #  for the moment we are willing to live with sending less
                            #  pre-request then we could theoretically do for simplicity&#39;s sake.
                            if id(request_item_to_obj(x)) in model_hash_ids_for_url:
                                buffer_items_to_send.append(x)
                            else:
                                # We will keep these in buffer_list after we send the objects
                                # the url_generator told us we could.
                                buffer_items_to_keep.append(x)

                    final_url = generated_url.url

                    # todo: Lot out at verbose logging level without using the verbose log method.
                    # todo: Figure out how we want to log updates [perhaps just log everything].
                    #
                    # if i &lt; log_limit:
                    #     log.verbose(f&#34;Did Update Obj: {obj}&#34;)
                    # elif i == log_limit:
                    #     log.verbose(
                    #       f&#34;Did Update Obj: And many more were updated [log throttled].&#34;
                    #     )

                    # self._send_objs_to_url(api=api, url=final_url, objects=buffer_list)
                    request_generator(
                        url=final_url, objects=buffer_items_to_send
                    )

                    # We are iterating though this in reverse, so we append to the
                    # left of objects [if needed] in the correct order.
                    for buffer_item in reversed(buffer_items_to_send):
                        obj = request_item_to_obj(buffer_item)
                        last_http = obj.api.response_state

                        if not last_http.had_error:
                            continue

                        # Error handler for object could request a retry_send, check for that here.
                        should_retry = last_http.should_retry_send
                        if not should_retry:
                            continue

                        last_http = obj.api.response_state
                        if last_http.try_count &gt; 4:
                            last_http.should_retry = False
                            log.warning(
                                f&#34;We got an object {obj} we are trying to resend, it has &#34;
                                f&#34;a try count of ({last_http.try_count}), and so we will stop &#34;
                                f&#34;retrying to send it as a sanity check.&#34;
                            )
                            continue

                        log.info(
                            f&#34;Failed to send {obj}, but it was requested to be retried, &#34;
                            f&#34;with a try-count of ({last_http.try_count}).&#34;
                        )

                        last_http.reset(for_retry=True)
                        if should_retry is ResponseStateRetryValue.AS_IS:
                            objects.appendleft(buffer_item)
                        elif should_retry is ResponseStateRetryValue.EXPORT_JSON_AGAIN:
                            objects.appendleft(obj)

                        last_http.should_retry = None

                    buffer_list.clear()
                    buffer_list.extend(buffer_items_to_keep)
                    continue

                log.info(
                    f&#34;Have multiple objects, but can&#39;t find endpoint for Model ({api.model_type}) &#34;
                    f&#34;that supports sending multiple objects, attempting to send them as &#34;
                    f&#34;individual/single objects instead (one per-request, multiple requests). &#34;
                )

                # url_for_send should raise an exception for us, this just here as a
                # sanity check to ensure we don&#39;t infinite loop.
                assert buffer_count &gt; 1, &#34;Could not find URL to send a singular object.&#34;

                objects.extendleft(buffer_list)
                buffer_list.clear()
                send_limit = 1
                continue

            obj_or_buffer_item = objects.popleft()

            if isinstance(obj_or_buffer_item, RestModel):
                item = object_to_request_item(obj_or_buffer_item)
                if item is None:
                    # This means there is nothing to send, so skip to next object, no error.
                    #
                    # We rely on the `object_to_request_item` method to log any needed
                    # info about why it could not send this object. We track the number of skipped
                    # objects so we can post a summary of how many objects where skipped.
                    num_objects_skipped += 1
                    obj_or_buffer_item.api.response_state.did_send = False
                    continue
                buffer_item = item
            else:
                buffer_item = obj_or_buffer_item

            # We could be sending tens of thousands of objects, only log a few of them.
            # todo: override log_limit when &#39;verbose&#39; logging level is on [on step past debug].
            if buffer_count &lt; log_limit:
                log_request_item(buffer_item)
            elif buffer_count == log_limit:
                obj_count_left = send_limit - buffer_count
                if obj_count_left &gt; len(objects):
                    obj_count_left = len(objects)

                obj_count_left += 1
                log.debug(f&#34;Will send ({obj_count_left}) more objects in request [log throttled].&#34;)

            buffer_list.append(buffer_item)
            continue
        log_about_skipped_objects_if_needed()

    def format_body_for_send(
        self, objects: Sequence[Tuple[RestModel, JsonDict]], url: URLMutable
    ):
        &#34;&#34;&#34;
        If you send us a list or dictionary we will json encode it for you otherwise if you
        pass back a string we will just use that as is.
        &#34;&#34;&#34;
        return [v[1] for v in objects]

    def _send_objs_to_url(self, url: URL, objects: Sequence[Tuple[RestModel, JsonDict]]):
        &#34;&#34;&#34;
        This method is used as a request-generator for `RestClient._do_http_method_on_objs`.
        `RestClient.send_objs` is what sets this up.

        `RestClient._do_http_method_on_objs` is used as the main driver, it uses
        `RestClient.url_for_send` as the URL generator, that in turns tells it how to group objects
        into a single-request.  It that uses us here to generate a request and execute it.

        Based on URL, we know the HTTP method + endpoint URL, we construct and execute request
        to send objects there.

        Response is parsed for errors via `RestClient.parse_errors_from_send_response`.

        If errors are found, awe also execute any error handler&#39;s as needed for any objects
        that have an error.
        `RestClient._do_http_method_on_objs` is responsible for checking for errors and
        calling as a second time with those objects if they need to be retried
        (see `xynlib.orm.http_state.HttpState.retry_send`).

        Args:
            objects: Objects to send; we parse and set error info on any objects as needed.
        &#34;&#34;&#34;
        api = self.api

        url = URLMutable(url)

        if not objects:
            return

        request_objs = [v[0] for v in objects]
        if url.singular:
            assert len(request_objs) == 1, &#34;Got more objects that url supports&#34;
            request_json = objects[0][1]
        else:
            request_json = self.format_body_for_send(objects, url)

        url_str = url.url()
        assert url_str, f&#34;Passed an invalid url (path: {url.path}) for api ({api}).&#34;

        # todo: Move this into `_wrap_request`, pass in high-level url object to it.
        url_methods = url.methods
        assert len(url_methods) == 1, (
            f&#34;Should only be one method ({url_methods}) for url ({url_str}).&#34;
        )

        http_method = url_methods[0]

        log.info(
            f&#34;Sending a total of ({len(request_objs)}) objects to url ({url_str}) &#34;
            f&#34;via method ({http_method}).&#34;
        )

        # Quick check to see if we are creating any objects or not.
        # If we even have a single create among a sea of updates, say we are creating.
        creating_objects = False
        for o in request_objs:
            if o.id is None:
                creating_objects = True
                break

        try:
            log.debug(f&#34;Going to ({http_method}) to ({url_str}) with ({request_json}) &#34;)
            response = self._wrap_request(
                lambda: self._requests_session.request(
                    method=http_method,
                    url=url_str,
                    json=request_json,
                    auth=self.auth.requests_callable(api.settings),
                    timeout=30
                ),
                creating_objects=creating_objects
            )
        except requests.exceptions.RequestException as exc:
            # Transform this exception into a more standard one, which will eventually be caught
            # and logged out appropriately.
            raise XynRestError(
                f&#34;There was a problem connecting to api endpoint ({url_str}), &#34;
                f&#34;due to a request exception ({exc}) via ({self}).&#34;
            )

        status_code = response.status_code
        resp_list = None
        # HTTP 204 means there is &#39;No Content&#39;, ie: they did not return the current obj values
        # after the update happened. So we assume all went well and the values we sent
        # are unchanged after they processed them.
        if status_code != 204 or len(response.text) &gt; 0:
            try:
                resp_list = response.json()
                if resp_list and isinstance(resp_list, dict):
                    structure = api.structure
                    multiple_results_json_path = structure.multiple_results_json_path
                    resp_check = resp_list.get(multiple_results_json_path)
                    if resp_check is not None:
                        resp_list = resp_check
            except (ValueError, KeyError) as e:
                if len(response.text) &gt; 0:
                    log.warning(
                        f&#34;Could not parse JSON from response ({response}). With response text &#34;
                        f&#34;({response.text}) with error({e}).&#34;
                    )
                    if status_code &lt; 300:
                        # If we have an OK status [&lt;300], we should be able to parse the JSON.
                        # Re-raise the exception so to continues to propagate.
                        raise e
                else:
                    log.warning(
                        f&#34;Received blank response for response ({response}), assuming we are &#34;
                        f&#34;fine and continuing as normal.&#34;
                    )

        for obj in request_objs:
            http = obj.api.response_state
            http.try_count += 1
            http.did_send = True
        http = None

        # TODO: Consolidate this and self.get_all_objects() error handling logging/exceptions.
        self.parse_errors_from_send_response(
            url=url, json=resp_list, response=response, request_objs=request_objs
        )

        if url.singular:
            # We change the JSON to a list, so we can consolidate the multi/single obj code.
            if resp_list:
                resp_list = [resp_list]

        if not resp_list:
            resp_list = []

        # todo: Consider:
        #  Consolidate non-error obj updating into `parse_json_from_get_response`? Rename method
        #  to parse_json_from_response? See below `to-do` under `if not http.had_error:`.

        resp_list_len = 0
        if response.status_code &lt; 300:
            if not isinstance(resp_list, list):
                raise XynRestError(
                    f&#34;We got a response of status OK ({response.status_code}) but the result was &#34;
                    f&#34;not in a list, it was instead a ({type(resp_list).__name__}) for &#34;
                    f&#34;url ({url}).&#34;
                )
            resp_list_len = len(resp_list)

        for i, obj in enumerate(request_objs):
            obj: RestModel

            # We did not get anything in the response body, probably an async operation
            # on their end and so we have nothing else to do.
            # I know hubspot can return a 202 without a body for bulk-importing of contacts.
            response_json: Optional[Dict[str, Any]] = {}
            if i &lt; resp_list_len:
                response_json = resp_list[i]

            http = obj.api.response_state

            if not http.had_error:
                &#34;&#34;&#34;
                    Example Xyngular API Ok Response:
                  {
                    &#34;status_code&#34;: 201,
                    &#34;status_text&#34;: &#34;Created&#34;,
                    &#34;data&#34;: {
                      &#34;id&#34;: 5,
                      &#34;url&#34;: &#34;http://127.0.0.1:49120/v1/presclub/point_events/5&#34;,
                      &#34;point_type_url&#34;: &#34;http://127.0.0.1:49120/v1/presclub/point_types/1&#34;,
                      &#34;account_id&#34;: 123,
                      &#34;event_date&#34;: &#34;2010-03-03&#34;,
                      &#34;points_earned&#34;: 100,
                      &#34;description&#34;: &#34;Some Desc&#34;,
                      &#34;detail&#34;: {},
                      &#34;waiver&#34;: false,
                      &#34;created_at&#34;: &#34;2017-09-12T22:11:41.352839Z&#34;,
                      &#34;updated_at&#34;: &#34;2017-09-12T22:11:41.352867Z&#34;
                    }
                  }
                &#34;&#34;&#34;

                if not response_json or not isinstance(response_json, dict):
                    continue

                # todo: Move this into something in xyn_sdk.core.common.RestClient
                #   we want to make this specific to Xyngular api&#39;s only [vs hubspot, etc].
                #   for now if we have a &#39;data&#39; element, use that if it&#39;s a dict, otherwise
                #   just use the entire response.
                #
                # todo: Another Idea: Instead of doing what I am talking about above, just switch
                #   to always sending the full response data and having the BaseApi class parse
                #   out the &#39;data&#39; or whatever else it needs [I do that for hubspot current].
                obj_resp_data = response_json.get(&#39;data&#39;)
                if obj_resp_data and isinstance(obj_resp_data, dict):
                    obj.api.update_from_json(obj_resp_data)
                else:
                    obj.api.update_from_json(response_json)
                continue

            # Next, if the obj had an error, we call their error handler if they have one.
            error_handlers: List[ErrorHandler] = []
            if http.error_handler:
                error_handlers.append(http.error_handler)

            error_handlers.extend(obj.api.option_all_for_name(&#39;error_handler&#39;))

            # todo: Have a catch-all error handler @ self.error_handler or some such...

            handled = False
            for handler in error_handlers:
                if handler(obj, http, url) or obj.api.response_state.should_retry_send:
                    # If the error on the object was handled or the object was marked to retry
                    # sending we will say it was handled.
                    handled = True
                    break

            if handled:
                # Error was handled in some way, no need to log about it.
                continue

            if not obj.api.response_state.should_retry_send:
                # If we did not handle it or are not going to retry to send it, log out details
                # about this object&#39;s error.
                log.error(
                    f&#34;Had error for url ({url_str}) while updating object ({obj}) &#34;
                    f&#34;via ({http_method}) with full response ({response_json}).&#34;
                )

    def _wrap_request(
            self, handler: Callable[[], requests.Response], creating_objects: bool
    ) -&gt; requests.Response:
        &#34;&#34;&#34;
            Used internally to make requests, and will do some standard error checking.

            If it decides the entire request needs to be resent, it will call handler a second
            time.
            This could happen, for example, if an auth token has expired, and it refreshed it
            and so the call should be attempted a second time.

            If the error happens a second time, or if the original error was not recoverable,
            then the errored response will be returned from handler.  If the second request is
            successful, then that will be the response that is returned.

            .. important:: This request retrying ONLY happens if the entire request failed, and
                it&#39;s determined it&#39;s safe to retry the request
                (ie: no chance of accidentally making more objects a second time).

                Otherwise, retrying individual objects is handled via the standard error
                handlers and retrying mechanism.

                For details on that see:

                - `RestClient.parse_errors_from_send_response`
                - `RestClient.parse_json_from_get_response`

        Args:
            handler: Called to construct a ready to use request. May be called a second time
                if the original request has an issue, and we determine we can resend it.
            creating_objects: True if we could possibly create objects/resources.
                If we are only updating existing ones, or getting/deleting them, then pass in
                False. If this is True we have to limit what error codes we will trigger a re-try
                of the request on, to be safe.

        Returns:
            requests.Response: The response.
        &#34;&#34;&#34;
        retry_requests = self.api.settings.retry_requests

        # Default retry_requests to True.
        if retry_requests is Default:
            retry_requests = True

        try:
            response = handler()
        except (ConnectionResetError, ConnectionAbortedError, ConnectionError, Timeout) as e:

            if not retry_requests:
                raise

            log.warning(
                f&#34;We had the connect reset or abort with exception ({e}). &#34;
                f&#34;Will reset the requests session and then attempt the request a second time &#34;
                f&#34;before giving up.&#34;
            )

            # Next time the current requests Session is asked for, we will generate a new Session.
            # This forces a new connection to be used.
            # We don&#39;t want to attempt to reuse any of the old connections, to be safe.
            Session.grab().reset()

            if creating_objects and isinstance(e, ReadTimeout):
                # We reset the connection so the next time we try to use the connection it gets
                # a new one. But we are not retrying the request, so it doesn&#39;t attempt to create
                # a second object (We don&#39;t know if the original request made it to the server).
                raise

            # If we get error this second time, let the exception propagate.
            response = handler()

        request: requests.PreparedRequest = response.request

        if response.status_code in [401]:
            # We want to try to refresh the token and try request again.
            log.warning(
                f&#34;Executed request and got response status ({response.status_code}), going to &#34;
                f&#34;attempt refreshing token and then retrying the ({request.method}) request with &#34;
                f&#34;url ({request.url}).&#34;
            )
            self.auth.refresh_token(settings=self.api.settings)
            response = handler()
            request = response.request

        if not retry_requests:
            return response

        status_codes_to_retry = {500, 502, 503}
        if not creating_objects:
            status_codes_to_retry.add(504)

        if response.status_code in status_codes_to_retry:

            log.warning(
                f&#34;Executed request and got response status ({response.status_code}), going to &#34;
                f&#34;attempt to retry the ({request.method}) request with url ({request.url}).&#34;
            )

            # If it&#39;s a 502/503/504, then try request again before giving up.
            response = handler()
            request = response.request

        # Whatever the latest response is at this point, return it.
        return response

    # -------------------------------
    # --------- URL Methods ---------

    def url_for_read(
            self, *,
            url: URL,
            top: int = None,
            fields: FieldNames = Default
    ) -&gt; URLMutable:
        &#34;&#34;&#34;
        Given an url, top; returns the URL that should be requested for a read/get.

        `RestClient.root_read_url` is used a the root_url (see `RestClient.url_for_endpoint`).

        The `id` query value is used to determine if we should look for singular or non-singular
        URL&#39;s first.  If that does not work, I look at all of them.
        See `RestClient.url_for_endpoint` and it&#39;s `singular_values` Args doc for more details
        about this (we pass in None for this arg to that method).

        By default, look only for URL&#39;s that support url.HTTPGet.

        .. todo:: Put in correct API error class below

        If we can&#39;t find a valid url, will raise an XynRestError.

        Args:
            url (xynlib.url.URL): Appended to endpoint url(s), first valid url will be used.

            fields (Sequence[str]): You can pass in a list of fields, which will be the only ones
                returned in the objects.
                The field &#39;id&#39; will always be included, no need to add that one your self.

                If `xynlib.orm.types.Default` or Empty List (default):
                Then all fields will be retrieved except the ones ignored by default.

                .. note:: `xynlib.orm.base.structure.BaseStructure.excluded_field_map` is used if
                    fields is left as Default as a way to exclude specific fields
                    by default.

                If `None`: Nothing about what fields to include/exclude will be passed to API.
                It should grab everything.

            top: If provided, provides a &#39;max&#39; of how many results pre-request should come back.
        Returns:
            xynlib.url.URLMutable: Best url to use from among the candidate urls.
        &#34;&#34;&#34;
        api = self.api

        excluded_field_map = api.structure.excluded_field_map()
        only_fields: Optional[Set[str]] = None
        ignore_fields: Optional[Set[str]] = None

        extra_query: Query = {}

        if fields is not None:
            if fields and fields is not Default:
                only_fields = set(xloop(fields))
            elif excluded_field_map:
                # noinspection PyTypeChecker
                ignore_fields = excluded_field_map.keys()

        # todo: For now, assume fields are specified this way, split it out later when we need to.
        if only_fields:
            only_fields.add(&#39;id&#39;)
            # It may be ok with a `set`, but just use a `list` for now.
            extra_query[&#39;field__in&#39;] = list(only_fields)
        elif ignore_fields:
            extra_query[&#39;field!__in&#39;] = list(ignore_fields)

        # Append user provided url on-top of the extra_query, the passed in url overrides any
        # conflicting values provided.
        if extra_query:
            url = URLMutable(query=extra_query).append_url(url)

        final_url = self.url_for_endpoint(
            root_url=URL.ensure_url(self.root_read_url), url=url, methods=(HTTPGet,)
        )

        formatting_options = final_url.formatting_options or DefaultQueryValueListFormat

        limit_name = formatting_options.query_limit_key or &#34;limit&#34;
        max_limit = formatting_options.query_limit_max
        query_limit_value = None
        if limit_name in final_url.query:
            query_limit_value = final_url.query.get(limit_name)

        final_limit_value = None
        if top:
            # Top has the highest priority and will override anything passed into the query.
            if max_limit and top &gt; max_limit:
                # Some endpoints have a max query limit which we will respect here.
                final_limit_value = max_limit
            else:
                # The top value was fine, so we will add or override the limit in the query for
                # the final url.
                final_limit_value = top
        elif query_limit_value:
            # This will be overridden if it is higher than the configured max limit, otherwise we
            # will leave it alone within the final url.
            if max_limit and query_limit_value &gt; max_limit:
                final_limit_value = max_limit
        elif formatting_options.query_limit_always_include:
            # We want to set the limit, but we will not be able to if there was no top,
            # manual query limit, or max limit configured.
            # TODO: We may want to raise an exception saying the max_limit was not configured and
            #  that query_limit_always_include depends on that value. Or have a hardcoded value
            #  we default to.
            if max_limit:
                final_limit_value = max_limit

        if final_limit_value:
            final_url.query_add(limit_name, final_limit_value)

        return final_url

    def url_for_next_page(
            self, original_url: URL, json_response: JsonDict
    ) -&gt; Optional[URLStr]:
        &#34;&#34;&#34;
        This is called to get next url to call for next page of results in a GET request.
        If you return `None`, then pagination will stop.

        By default we just get `next` attribute in JSON response and return that.
        You can see an alternative real-world example at
        `hubspot.api.common.RestClient.url_for_next_page`. That shows how hubspot API does
        pagination and how it&#39;s communicated to ORM library.

        Args:
            original_url (xynlib.url.URL): The current url that was just requested,
                as a URL object.

            json_response (xynlib.orm.types.JsonDict): The response as a JSON dict from the
                requested_url.

        Returns:
            xynlib.url.URLStr: Can either by a `xynlib.url.URL` or a url as a `str`.

            None: pagination stops.
        &#34;&#34;&#34;
        # Standard Xyngular API&#39;s have a &#39;next&#39; field that has a full URL to request next.
        return json_response.get(&#39;next&#39;, None)

    def url_for_delete(
            self, *, url: URL, model_objs: Sequence[RestModel]
    ) -&gt; URLMutable:
        &#34;&#34;&#34;
        Simply calls `RestClient.url_for_endpoint` and returns the result; with
        `xynlib.url.HTTPDelete`
        as the only `methods` arg and singular_values set as `(True, None)` if there is more
        than one `model_objs` or `(False,)` if there is only one object to delete.

        See `RestClient.url_for_endpoint` for more details.
        You may also glean some more insight from `RestClient.url_for_send` and
        `RestClient.url_for_read`.

        Args:
            url (xynlib.url.URL): This is passed to `url` arg on `RestClient.url_for_endpoint`.
                It&#39;s supposed to be the final url appended to the resulting URL via
                `xynlib.url.URLMutable.append_url`.
            model_objs (Sequence[xynlib.orm.rest.model.RestModel]): Objects to delete.

        Returns:
            xynlib.url.URLMutable: Final url used to delete the passed in objects.

        &#34;&#34;&#34;
        have_multiple_models = len(model_objs) &gt; 1
        return self.url_for_endpoint(
            url=url,
            methods=(HTTPDelete,),
            singular_values=(False,) if have_multiple_models else (True, None),
            secondary_values=model_objs,
            raise_if_none=not have_multiple_models
        )

    def url_for_send(
            self, *, model_objs: Sequence[RestModel], url: URL = None
            # todo: `GeneratedURL` revamp!!!!
    ) -&gt; Union[GeneratedURL, UseSingularValueType]:
        &#34;&#34;&#34;
        We have more than one model object, we return UseSingularValue if we can&#39;t find a valid url
        to indicate that a single model object should be tried instead of multiple.

        If we only have a single, we will raise an exception.

        If we send back a result, it&#39;s a `GeneratedURL`. This `GeneratedURL` contains the
        `xurls.URL`
        to use plus the model objects that are valid for this URL.

        You must call us again
        in the future with the other object(s) that did not make it the first time to get
        their URL. If you call us back a second time with other objects in addition to the ones
        that were previously skipped, we may still skip the previously skipped ones again. Just
        keep calling us over and over and eventually everything will have a URL to send it with
        or you will get an exception.

        The RestModel classes have an ordered list of URLs attached to the class that we try to use
        in order when we need to find a URL to send/get objects.

        By default: We attempt to find a method/url using a prioritized method order.
        We look for he first valid url in this prioritized order.
        I use `RestClient.url_for_endpoint` to find the URL for each method in the priority list
        below.
        The first valid url (`orm.url.URL.is_valid`) is what is used.

        The method priority list is:

        1. `xynlib.url.HTTPPatch`
        2. `xynlib.url.HTTPPost`
        3. `xynlib.url.HTTPPut`

        If a `xynlib.url.URL.is_valid` method/url is not found we go to the next method and try
        again by calling `RestClient.url_for_endpoint` with the proper arguments.

        If one is found, we will return a url to use that method/url first with all objects
        that can use that method/url. It could be only 100 objects are supported in a single
        request (as an example). So we may use the same method/url each time you call us as
        we &#34;paginate&#34; though all the objects to send. We will do as many objects as we can as
        you call us back with this same higher-priority url/method.

        Eventually, all of the objects for this higher-priority url will have been gotten to
        and what are left over (if any) are objects that need a different lower-priority
        method/url.
        When they are the only ones passed into this method, we will use that lower-priority
        method/url.

        This will keep happening until all objects have had a url to use with them.
        If all the objects passed into this method can&#39;t find a `xynlib.url.URL.is_valid` url
        to use, then we will raise an `xynlib.orm.errors.OrmError`.

        If you pass us no model objects, we will also raise an `xynlib.orm.errors.OrmError`.
        This usually means you meant to pass in some objcts but did not by mistake.

        Args:
            model_objs: RestModel objects to send.
            url: URL to append to end of final URL. This final URL is checked for validity.
                If it&#39;s valid, we will return it.  Otherwise we try other URL&#39;s.
        Returns
            UseSingularValue: We are requesting you call us back with a single model object.

            GeneratedURL: The URL and objects to send.
        &#34;&#34;&#34;
        # We first look for Patch, then Put, and finally a Post method.

        if not model_objs:
            raise XynRestError(
                &#34;For some reason we got passed no model objects when generating url.&#34;
            )

        have_multiple_models = len(model_objs) &gt; 1
        methods = [HTTPPatch]

        url = self.url_for_endpoint(
            url=url,
            methods=(HTTPPatch,),
            singular_values=(False,) if have_multiple_models else (True, None),
            secondary_values=model_objs,
            raise_if_none=False
        )

        if url:
            return GeneratedURL(url=url, models=model_objs)

        # Else, we have to figure out if we are creating/modifying objects to select correct
        # http method to use. We look for creation first.

        created = []
        updated = []
        for model in model_objs:
            if model.id is None:
                # We are creating the object, we have no id.
                created.append(model)
            else:
                updated.append(model)

        if created:
            # for now, we send back a single URL that indicates we are only creating.
            url = self.url_for_endpoint(
                url=url,
                methods=(HTTPPost,),
                singular_values=(False,) if have_multiple_models else (True, None),
                secondary_values=created,
                raise_if_none=not have_multiple_models
            )
            if not url:
                return UseSingularValue
            return GeneratedURL(url=url, models=created)

        url = self.url_for_endpoint(
            url=url,
            methods=(HTTPPut,),
            singular_values=(False,) if have_multiple_models else (True, None),
            secondary_values=updated,
            raise_if_none=not have_multiple_models
        )

        if not url:
            return UseSingularValue

        return GeneratedURL(url=url, models=updated)

    def url_for_endpoint(
            self,
            *,
            methods: Iterable[str],
            url: URL = None,
            root_url: URL = None,
            singular_values: Iterable[Union[bool, None]] = None,
            secondary_values: Union[dict, RestModel[M], Sequence[RestModel[M]]] = None,
            raise_if_none: bool = True
    ) -&gt; Optional[URLMutable]:
        &#34;&#34;&#34;
        Normally, this method is called from:

        - `RestClient.url_for_read`
        - `RestClient.url_for_send`
        - `RestClient.url_for_delete`

        To construct the final URL.

        Returns a copy of full/appended `xynlib.url.URLMutable` for the endpoint for the api
        passed, along
        with the root_url and url passed in.

        The resulting URL that is returned will only have one `xynlib.url.URL.methods`
        assigned to it, which is the first method we found a valid url for in the order
        in which you specify them. You can use this method to figure out what HTTP method is
        needed.

        Look at `xynlib.url.URL.is_valid` for more information about how `xynlib.url.URL`&#39;s
        are valid.

        `xynlib.url.URL` Construction Process
        (when it says append, it&#39;s using `xynlib.url.URLMutable.append_url`):

        1. Start with passed in `root_url`, or a blank `xynlib.url.URL`
           if `root_url` is `None` (default).
        2. Append `RestClient.base_api_url` if not None, otherwise RestSettings.api_url.
        3. Append `RestClient.base_endpoint_url`.
        4. Append `xynlib.orm.rest.RestStructure.base_model_url` from
           `xynlib.orm.base.api.BaseApi.structure` via `RestClient.api`.
        5. Loop though singular_values, followed by methods, and finally each model_urls,
           in that order.
            - Append model url, and check if it&#39;s valid. If it is not, continue looping.
            - Return the first valid url that is found.

        Take a look at docs for `xynlib.orm.rest.RestStructure.base_model_url` for some
        more details.

        Args:
            root_url: A url that is the starting-point for any generated candidate url that we
                consider. If you don&#39;t provide one, a blank-url is the starting point.

                Sometimes we have special base-url&#39;s depending on if we are trying to get or send
                an object. An example of one is `RestClient.root_read_url`, which is passed in as
                the `root_url` arg when attempting to do a get request via
                `RestClient.url_for_read`
                (side note: we should have called it `root_url_for_read` probably).

            url: After calculating a candidate endpoint url, we append this to it before checking
                the url&#39;s validity. If the url is valid, we return this fully constructed
                candidate url.

                If None, then nothing will be appended to the final candidate endpoint url.

            methods: Only use URLs where at least on of these methods are valid for it.
                If None, methods are not considered when selecting URL.

            singular_values: The order to try singular_values. Only use URLs where this matches
                the singularity of the url. Will try urls in the order provided.

                Example: (True, False) -&gt; So we look at singular url&#39;s first, and then
                non-singular.

                The default is a None for the iterable value [ie: `singular_values = None`];
                this means singularity is preferred based on how many values are in the
                url&#39;s &#39;id&#39; query parameter. But it will ultimately consider all urls when
                looking though url list.

                If a value inside the iterable is None [ie: `(True, None)` or some such],
                the `None` value will force us to look at all urls
                [regardless of their singularity] based purely on their order.

            secondary_values: Backup list of values to use if url can&#39;t satisfy a formatting
                placeholder it&#39;s self.

            raise_if_none: Raise an XynRestError instead of returning None when we can&#39;t find a
                valid URL.
        &#34;&#34;&#34;

        # TODO - TODO - TODO: return METHOD to use, and if response will contain obj data...

        api = self.api
        structure = api.structure

        if structure.base_model_url is False:
            raise XynRestError(
                f&#34;RestClient was asked to do something with api RestModel type ({api.model_type}),&#34;
                f&#34; but the model has a False for it&#39;s base_url, that means it does not have an &#34;
                f&#34;API endpoint the client ({self}) can use..&#34;
            )

        base_model_url = URL.ensure_url(structure.base_model_url)

        # May consider caching this in the future.
        api_url = self.base_api_url or api.settings.api_url

        # we do a copy here for efficiency/safety-purposes. We will get an error if we try
        # to modify it. We don&#39;t want to modify it accidentally after this point.
        base_url = (
            URLMutable(root_url)
            .append_url(api_url)
            .append_url(self.base_endpoint_url)
            .append_url(base_model_url).copy()
        )

        # Figure out a good default for singular_values if needed.
        if singular_values is None:
            #  For now we are assuming &#39;id&#39; as special throughout, if we do add standard
            #  generic way to remap id, pay attention to that here.
            #
            #  todo: When we must remap id, we do it via overriding `Api.json*` methods at the
            #        moment. I don&#39;t have a generic way to do it.
            #
            #   For now we assume if we have a single value, that the &#39;id&#39; in the query values
            #   is the key to use. We do this consistently across everything at the moment.
            #   The URL list of the model can put this &#39;id&#39; anywhere (see xynlib.url, formatting).
            id_value = api_url.query_value(&#39;id&#39;)
            singular_values = (None,)
            if id_value:
                if isinstance(id_value, list) and len(id_value) &gt; 0:
                    singular_values = (len(id_value) == 1, None)
                else:
                    singular_values = (True, None)

        all_candidate_urls_cache: List[URLMutable] = []

        # Generator that will cache the values so you can reuse generator again
        # without having to re-calculate the urls again.
        def all_urls():
            if all_candidate_urls_cache:
                for v in all_candidate_urls_cache:
                    yield v
            else:
                for ep_url in structure.model_urls:
                    # Make a copy, going through a list to try out on the base_url.
                    # We append any url provided by caller, and then check validity.
                    final_url = base_url.copy().append_url(ep_url).append_url(url)
                    all_candidate_urls_cache.append(final_url)
                    yield final_url

        for singular in singular_values:
            for method in methods:
                for candidate_url in all_urls():

                    if singular is not None and candidate_url.singular != singular:
                        continue

                    if not candidate_url.methods_contain(method):
                        continue

                    if candidate_url.is_valid(
                            secondary_values=secondary_values, attach_values=True
                    ):
                        candidate_url.methods = (method,)
                        return candidate_url

        if raise_if_none:
            raise XynRestError(
                f&#34;Could not find valid URL from base_url ({base_url}) + url ({url}) for API {api} &#34;
                f&#34;for methods ({methods}), singular ({singular_values}), &#34;
                f&#34;secondary values ({secondary_values}).&#34;
            )

        return None

    @property
    def _requests_session(self) -&gt; requests.Session:
        return Session.grab().requests_session</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.RestClient.base_api_url"><code class="name">var <span class="ident">base_api_url</span> : Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]</code></dt>
<dd>
<div class="desc"><p>Normally this will come from the <code>xynlib.orm.rest.settings.RestSettings.api_url</code> via
<code>xynlib.orm.rest.api.RestApi.settings</code> object.
But you can override it here if needed.
For example, you might want to use a <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code> sub-class for a non xyngular api.</p>
<p>Whenever a request is executed this is used, this is used if it's set to something that looks
<code>True</code> (ie: non-blank string) instead of grabbing the one from api.settings.api_url.
So you can use this property to 'override' the api_url if you want.</p>
<p>General logic summary of what I am saying above:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; base_url_to_use = self.base_api_url or self.api.settings.api_url
</code></pre>
<div class="admonition info">
<p class="admonition-title">Info:&ensp;<code><a title="xmodel_rest.RestClient.base_endpoint_url" href="#xmodel_rest.RestClient.base_endpoint_url">RestClient.base_endpoint_url</a></code> considerations:</p>
<p>If something is also defined in the <code><a title="xmodel_rest.RestClient.base_endpoint_url" href="#xmodel_rest.RestClient.base_endpoint_url">RestClient.base_endpoint_url</a></code>,
we will append that to this base_api_url while determining final url.
We would then finally append anything passed into the
method making the request (such as additional Query params or url arguments) and so forth.</p>
<p>See <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> for complete details on the url construction process.</p>
</div>
<p><strong>To Use:</strong></p>
<p>You can make a custom-subclass of RestClient and define this property. You can then add this
custom-subclass as the RestClient to use via custom BaseApi class type-hint
<code>client: MyAuthClass</code>.
The advantage here is you can reused that same <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code> sub-type with other RestModel's.</p>
<p>Or if you just want to change it for a single-RestModel, you can just set it before using it
like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; some_model_obj.api.client.base_url_to_use = &quot;api.host.com/base_path&quot;
</code></pre>
<p>If you do it that way, it has to laizly-configure the classes. If you do it via a subclass:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xynlib.orm import RestClient
&gt;&gt;&gt; class MyClient: RestClient
&gt;&gt;&gt;     base_url_to_use = &quot;api.host.com/base_path&quot;
</code></pre>
<p>Then it will work for other <code>xynlib.orm.rest.model.RestModel</code> sub-types, and won't trigger the
lazy RestModel configuration code (ie: it will only trigger later if the RestModel's are truly
used).</p>
<p>See <code>xynlib.orm.base.model.RestModel.__init_subclass__</code> for more details on what I mean by
lazily configuring the RestModel class.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Other Notes Related To Auth</p>
<p>At the moment the url the auth-client uses will not use what's in this <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code>'s
<code>base_api_url</code>, since the Auth object can be shared among a number of different client
instances/types.</p>
<p>If you need something specific for auth that's different vs standard way, you should
sub-class
the <code><a title="xmodel_rest.auth.RestAuth" href="auth.html#xmodel_rest.auth.RestAuth">RestAuth</a></code> sub-type/class you want to customize.
The sub-class can customize it's self however it wants.</p>
<p>You then set a type-annotation/hint via type hint on BaseApi class:
<code>xynlib.orm.base.api.BaseApi.auth</code>.
This makes the <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code> use this auth-type and hence your auth customizations.</p>
<p>See <code><a title="xmodel_rest.RestClient.auth" href="#xmodel_rest.RestClient.auth">RestClient.auth</a></code> documentation for a code example of how to do this.</p>
<p>Real world examples on how to create custom auth/api sub-classes as needed:</p>
<ul>
<li><code>xyn_sdk.core.common.Auth</code></li>
<li><code>xyn_sdk.core.common.BaseApi</code></li>
</ul>
</div></div>
</dd>
<dt id="xmodel_rest.RestClient.base_endpoint_url"><code class="name">var <span class="ident">base_endpoint_url</span> : Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]</code></dt>
<dd>
<div class="desc"><p>Whenever a request is executed this is used, it is appended to the base_api_url;</p>
<div class="admonition important">
<p class="admonition-title">Important:&ensp;see <code><a title="xmodel_rest.RestClient.base_api_url" href="#xmodel_rest.RestClient.base_api_url">RestClient.base_api_url</a></code> docs for more details</p>
<p>It will give you details you how the url construction process works, where
<code>base_api_url</code> comes from and how to override it in various ways.
<em>Those same ways also apply to this attribute.</em></p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Other Notes Related To Auth</p>
<p>This url is NOT used with Auth obj/class,
see "Other Notes Related To Auth" in <code><a title="xmodel_rest.RestClient.base_api_url" href="#xmodel_rest.RestClient.base_api_url">RestClient.base_api_url</a></code> for more details about
this.</p>
</div></div>
</dd>
<dt id="xmodel_rest.RestClient.default_send_batch_size"><code class="name">var <span class="ident">default_send_batch_size</span></code></dt>
<dd>
<div class="desc"><p>Used to set default batch size (if not passed directly into <code><a title="xmodel_rest.RestClient.send_objs" href="#xmodel_rest.RestClient.send_objs">RestClient.send_objs()</a></code> method).</p>
<p>Defaults to 500.</p>
<p>A RestClient subclass can change this if they have endpoints that are slower or have to
accept less at a time.</p></div>
</dd>
<dt id="xmodel_rest.RestClient.enable_send_changes_only"><code class="name">var <span class="ident">enable_send_changes_only</span></code></dt>
<dd>
<div class="desc"><p>If <code>True</code>, will keep track of changes to api-attributes, and system will only 'patch'
what has actually changed via a PATCH request (normally).
It only sends the primary 'id' field and the fields that actually changed;
(although this can be changed/customized for other API's, like hubspot's for example;
see hubspot project for example).</p>
<p>I decided for now this should be opt-in behavior, the default is False for now and
it will work like it did before, where it sends everything that is not 'None'.</p>
<p>When <code>xynlib.orm.base.api.BaseApi.update_from_json</code> is called, it will reset the list of
changed properties, this
is normally called after a patch with the latest attribute values from the server.</p>
<p>If response does not contain the latest attributes for object from server (ie: blank)
you should still call <code>xynlib.orm.base.api.BaseApi.update_from_json</code> with a blank dict so
it can try and do this housekeeping (I think it will have to assume that everything got
updated correctly and adjust internal dict of changed attributes like normal).</p>
<p>.. todo: Verify above behavior, when using API's that don't give back latest value
of attributes when updating them with only the changes.</p></div>
</dd>
<dt id="xmodel_rest.RestClient.method_status_to_raise_by_default"><code class="name">var <span class="ident">method_status_to_raise_by_default</span> : Dict[str, Set[int]]</code></dt>
<dd>
<div class="desc"><p>A mapping of HTTP-method (HTTPPost/HTTPPut/etc) to a set of status codes that if
encountered should result in automatically raising an error, with no attempt to parse
the error response body.</p>
<p>If set to None, or if method not mapped in dict, the defaults are:</p>
<p><code>DefaultStatusSetToRaiseForSending</code> when we send objects, which right now has:
POST/PUT/PATCH: 400, 401, 403, 500-599</p>
<p>And this for get/delete (work not done yet in RestClient to check this for GET/DELETE).
GET/DELETE: 400-599</p></div>
</dd>
<dt id="xmodel_rest.RestClient.root_read_url"><code class="name">var <span class="ident">root_read_url</span> : Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]</code></dt>
<dd>
<div class="desc"><p>Starting root-url for all get requests; it's the starting url to every GET request url.
By default, we use a blank url (aka: None).</p>
<p>See <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> and <code><a title="xmodel_rest.RestClient.base_api_url" href="#xmodel_rest.RestClient.base_api_url">RestClient.base_api_url</a></code> for complete details on the
url construction process and various ways to customize it (be sure to read both places).</p>
<p>The purpose of this is easily to modify the URL used for all GET/read requests if necessary
without having to override a method like <code><a title="xmodel_rest.RestClient.url_for_read" href="#xmodel_rest.RestClient.url_for_read">RestClient.url_for_read()</a></code> (ie: for simple cases).</p>
<div class="admonition tip">
<p class="admonition-title">Tip:&ensp;Real Example:</p>
<p>Right now, I use it in <code>xyn_sdk.datatrax_api.evo.EvoClient.root_read_url</code>
to hint that by default every get request singular=True.</p>
</div></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel_rest.RestClient.api"><code class="name">var <span class="ident">api</span> : RemoteApi[M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.api" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.api">api</a></code>
</p>
<div class="desc inherited"><p>Abstract type from which any client class is descended from …</p></div>
</dd>
<dt id="xmodel_rest.RestClient.auth"><code class="name">var <span class="ident">auth</span> : <a title="xmodel_rest.auth.RestAuth" href="auth.html#xmodel_rest.auth.RestAuth">RestAuth</a></code></dt>
<dd>
<div class="desc"><p>This is the auth object used by client, to set what type should be used for this,
in your <code>xynlib.orm.base.api.Api</code> sub-class, make a type-hint like this in the
Api subclass definition:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel_rest import RestApi, RestAuth
&gt;&gt;&gt; from typing import TypeVar
&gt;&gt;&gt;
&gt;&gt;&gt; class MyAuth(BaseAuth):
&gt;&gt;&gt;    pass  # Put your auth stuff here
&gt;&gt;&gt;
&gt;&gt;&gt; M = TypeVar(&quot;M&quot;)
&gt;&gt;&gt; class MyApi(BaseApi[M]):
...     auth: MyAuth
</code></pre>
<p>Doing that is enough, <code>xynlib.orm.base.api.Api</code> will see the type-hint and will grab one of
that
type from the <code>xynlib.context.Context</code>. <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code> gets <code>xynlib.orm.base.auth.BaseAuth</code>
instance from <code>xynlib.orm.base.api.Api.auth</code> via <code><a title="xmodel_rest.RestClient.api" href="#xmodel_rest.RestClient.api">RestClient.api</a></code>.
In the example above, it would be a <code>MyAuth</code>.</p>
<p>Defaults to <code>xynlib.orm.base.auth.BaseAuth</code>, which will not do any auth by default.
See <code>xyn_sdk.core.common.Auth</code> for a concrete subclass that implments auth for
Xyngular API's.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth(self) -&gt; RestAuth:
    &#34;&#34;&#34;
    This is the auth object used by client, to set what type should be used for this,
    in your `xynlib.orm.base.api.Api` sub-class, make a type-hint like this in the
    Api subclass definition:

    &gt;&gt;&gt; from xmodel_rest import RestApi, RestAuth
    &gt;&gt;&gt; from typing import TypeVar
    &gt;&gt;&gt;
    &gt;&gt;&gt; class MyAuth(BaseAuth):
    &gt;&gt;&gt;    pass  # Put your auth stuff here
    &gt;&gt;&gt;
    &gt;&gt;&gt; M = TypeVar(&#34;M&#34;)
    &gt;&gt;&gt; class MyApi(BaseApi[M]):
    ...     auth: MyAuth

    Doing that is enough, `xynlib.orm.base.api.Api` will see the type-hint and will grab one of
    that
    type from the `xynlib.context.Context`. `RestClient` gets `xynlib.orm.base.auth.BaseAuth`
    instance from `xynlib.orm.base.api.Api.auth` via `RestClient.api`.
    In the example above, it would be a `MyAuth`.

    Defaults to `xynlib.orm.base.auth.BaseAuth`, which will not do any auth by default.
    See `xyn_sdk.core.common.Auth` for a concrete subclass that implments auth for
    Xyngular API&#39;s.

    &#34;&#34;&#34;
    return self.api.auth</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.RestClient.cache_get"><code class="name flex">
<span>def <span class="ident">cache_get</span></span>(<span>self, key, default=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.cache_get" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.cache_get">cache_get</a></code>
</p>
<div class="desc inherited"><p>See cache_set documentation above for more details.
This gets something out of cache.
If key does not exist in cache, then return default [which …</p></div>
</dd>
<dt id="xmodel_rest.RestClient.cache_remove"><code class="name flex">
<span>def <span class="ident">cache_remove</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.cache_remove" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.cache_remove">cache_remove</a></code>
</p>
<div class="desc inherited"><p>See cache_set documentation above for more details.
This gets removes something out of the cache if it exists, or does nothing otherwise …</p></div>
</dd>
<dt id="xmodel_rest.RestClient.cache_set"><code class="name flex">
<span>def <span class="ident">cache_set</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.cache_set" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.cache_set">cache_set</a></code>
</p>
<div class="desc inherited"><p>Right now this is a dictionary that you can set/retrieve keys from.
It strongly caches the objects (ie: if they are unreferenced elsewhere, we still
…</p></div>
</dd>
<dt id="xmodel_rest.RestClient.cache_weak_get"><code class="name flex">
<span>def <span class="ident">cache_weak_get</span></span>(<span>self, key, default=None)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.cache_weak_get" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.cache_weak_get">cache_weak_get</a></code>
</p>
<div class="desc inherited"><p>See <code>RemoteClient.cache_set</code> documentation above for more details.
This gets something out of the weak cache.
If key does not exist in cache, then …</p></div>
</dd>
<dt id="xmodel_rest.RestClient.cache_weak_set"><code class="name flex">
<span>def <span class="ident">cache_weak_set</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.cache_weak_set" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.cache_weak_set">cache_weak_set</a></code>
</p>
<div class="desc inherited"><p>Just like `RemoteClient.cache_set, except it will weakly keep the value …</p></div>
</dd>
<dt id="xmodel_rest.RestClient.clear_caches"><code class="name flex">
<span>def <span class="ident">clear_caches</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code>.<code><a title="xmodel.remote.client.RemoteClient.clear_caches" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient.clear_caches">clear_caches</a></code>
</p>
<div class="desc inherited"><p>Clears both the weak and strong caches …</p></div>
</dd>
<dt id="xmodel_rest.RestClient.delete_obj"><code class="name flex">
<span>def <span class="ident">delete_obj</span></span>(<span>self, obj: ~M)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls <code>RestClient.delete_objects</code> with passed in object in a list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>xynlib.orm.rest.model.RestModel</code></dt>
<dd>model to delete.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_obj(self, obj: M):
    &#34;&#34;&#34;
    Calls `RestClient.delete_objects` with passed in object in a list.

    Args:
        obj (xynlib.orm.rest.model.RestModel): model to delete.
    &#34;&#34;&#34;
    self.delete_objs([obj])</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.delete_objs"><code class="name flex">
<span>def <span class="ident">delete_objs</span></span>(<span>self, objs: Iterable[~M], url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows you to delete a bunch of objects, bulk-deleting if possible.
Automatically falls back to one at a time if necessary.</p>
<p>Regardless of how it does it, it will attempt to delete every object passed in.</p>
<p>The objects must have their <code>xynlib.orm.rest.model.RestModel.id</code> set to something,
otherwise they will be skipped.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>Iterable[xynlib.orm.rest.model.RestModel]</code></dt>
<dd>The objects to delete
(only attribute needed on them is <code>xynlib.orm.rest.model.RestModel.id</code>).</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>xynlib.url.URLStr</code></dt>
<dd>Optional URL to append onto final URL.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_objs(self, objs: Iterable[M], url: URLStr = None):
    &#34;&#34;&#34;
    Allows you to delete a bunch of objects, bulk-deleting if possible.
    Automatically falls back to one at a time if necessary.

    Regardless of how it does it, it will attempt to delete every object passed in.

    The objects must have their `xynlib.orm.rest.model.RestModel.id` set to something,
    otherwise they will be skipped.

    Args:
        objs (Iterable[xynlib.orm.rest.model.RestModel]): The objects to delete
            (only attribute needed on them is `xynlib.orm.rest.model.RestModel.id`).
        url (xynlib.url.URLStr): Optional URL to append onto final URL.
    &#34;&#34;&#34;
    # Note for future: Keeping `objs` declared as an Iterable for use with generators in the
    # future [etc, etc].
    preped_objs = self._create_deque_verify_and_reset_http_state(objs)
    url = URL.ensure_url(url)

    def do_delete_request(url: URL, objects: Sequence[M]):
        # todo: Move this into `_wrap_request`, pass in high-level url object to it.
        url = URLMutable(url)
        url_methods = url.methods
        assert len(url_methods) == 1, (
            f&#34;Should only be one method ({url_methods}) for url ({url}) for delete.&#34;
        )

        id_list = list(map(lambda x: x.id, objects))
        # todo: We don&#39;t format &#39;query&#39; params right now inside URL [only the path portion]
        #       so for now we need to do that ourselves here. But in the future, we could
        #       generalize it and have URL format the query param for us!!!
        if not url.singular:
            url.query_add(
                key=&#34;id&#34;,
                value=id_list,
            )

        json_body = self.format_body_for_delete(objects, url)

        url_str = url.url()

        response = self._wrap_request(
            lambda: self._requests_session.request(
                method=url_methods[0],
                url=url_str,
                auth=self.auth.requests_callable(self.api.settings),
                json=json_body,
                timeout=30
            ),
            creating_objects=False
        )

        if response.status_code &gt;= 300:
            log.error(
                f&#34;[DELETE]: Non-Success Status ({response.status_code}) from url &#34;
                f&#34;({url}) - see debug log level for raw response.&#34;
            )

            for obj in objects:
                obj.api.response_state.had_error = True

        text = response.text
        if text is not None and len(text) &gt; 0:
            log.debug(
                f&#34;RestClient.delete_objs() - url ({url}) - raw response ({response.text})&#34;
            )

    def debug_log_item(item):
        log.debug(f&#34;Sending DELETE for ({item})&#34;)

    self._do_http_method_on_objs(
        objects=preped_objs,
        url_generator=self.url_for_delete,  # noqa: See note about python 3.8
        object_to_request_item=lambda x: x,  # No need to do any extra work
        request_item_to_obj=lambda x: x,  # No need to do any extra work
        log_request_item=debug_log_item,
        request_generator=do_delete_request,
        send_limit=100,
        url=url
    )</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.format_body_for_delete"><code class="name flex">
<span>def <span class="ident">format_body_for_delete</span></span>(<span>self, objects: Sequence[Tuple[<a title="xmodel_rest.model.RestModel" href="model.html#xmodel_rest.model.RestModel">RestModel</a>, Dict[str, Any]]], url: <a title="xurls.url.URLMutable" href="../xurls/url.html#xurls.url.URLMutable">URLMutable</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_body_for_delete(
    self, objects: Sequence[Tuple[RestModel, JsonDict]], url: URLMutable
):
    return None</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.format_body_for_get"><code class="name flex">
<span>def <span class="ident">format_body_for_get</span></span>(<span>self, url: <a title="xurls.url.URLMutable" href="../xurls/url.html#xurls.url.URLMutable">URLMutable</a>, top: int = None, fields: Union[Sequence[str], <a title="xsentinels.default.DefaultType" href="../xsentinels/default.html#xsentinels.default.DefaultType">DefaultType</a>] = Default)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_body_for_get(
    self,
    url: URLMutable,
    top: int = None,
    fields: Union[FieldNames, DefaultType] = Default
):
    raise XynRestError(
        &#34;We don&#39;t know how to generically format this. For now override the method.&#34;
    )</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.format_body_for_send"><code class="name flex">
<span>def <span class="ident">format_body_for_send</span></span>(<span>self, objects: Sequence[Tuple[<a title="xmodel_rest.model.RestModel" href="model.html#xmodel_rest.model.RestModel">RestModel</a>, Dict[str, Any]]], url: <a title="xurls.url.URLMutable" href="../xurls/url.html#xurls.url.URLMutable">URLMutable</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>If you send us a list or dictionary we will json encode it for you otherwise if you
pass back a string we will just use that as is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_body_for_send(
    self, objects: Sequence[Tuple[RestModel, JsonDict]], url: URLMutable
):
    &#34;&#34;&#34;
    If you send us a list or dictionary we will json encode it for you otherwise if you
    pass back a string we will just use that as is.
    &#34;&#34;&#34;
    return [v[1] for v in objects]</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, query: Dict[str, Any] = None, *, top: int = None, fields: Union[Sequence[str], <a title="xsentinels.default.DefaultType" href="../xsentinels/default.html#xsentinels.default.DefaultType">DefaultType</a>] = Default) ‑> Iterable[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns result of calling <code><a title="xmodel_rest.RestClient.get" href="#xmodel_rest.RestClient.get">RestClient.get()</a></code> with the query converted into a URL for you.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields</code></strong> :&ensp;<code>xynlib.orm.types.FieldNames</code></dt>
<dd>
<p>You can pass in a list of fields.
We will attempt to pass this to API if
possible. The idea is the API will only return the list fields.
If the API honors it, then they will be the only ones set on the objects.
If the API returns more fields, they will still be set on the object.</p>
<p>The field 'id' will always be included as a field,
no need to add that one your self.</p>
<p>If <code>xynlib.orm.types.Default</code> or Empty List (default):
All fields will be retrieved except the ones ignored by
(set via <code>xynlib.orm.fields.Field.exclude</code>,you can get the full list
via <code>xynlib.orm.base.structure.BaseStructure.excluded_field_map</code>).</p>
<p>If <code>None</code>: Nothing about what fields to include/exclude will be passed to API.
It should grab everything.</p>
</dd>
<dt><strong><code>query</code></strong></dt>
<dd>Dictionary for query filters.</dd>
<dt><strong><code>top</code></strong></dt>
<dd>Top/Maximum number of objects to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[xynlib.orm.rest.model.RestModel]</code></dt>
<dd>A <code>Generator</code>, that when ran will return all
model objects one at a time (paginating as needed while running the generator).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(
        self,
        query: Dict[str, Any] = None,
        *,
        top: int = None,
        fields: Union[FieldNames, DefaultType] = Default,
) -&gt; Iterable[M]:
    &#34;&#34;&#34;
    Returns result of calling `RestClient.get` with the query converted into a URL for you.

    Args:
        fields (xynlib.orm.types.FieldNames): You can pass in a list of fields.
            We will attempt to pass this to API if
            possible. The idea is the API will only return the list fields.
            If the API honors it, then they will be the only ones set on the objects.
            If the API returns more fields, they will still be set on the object.

            The field &#39;id&#39; will always be included as a field,
            no need to add that one your self.

            If `xynlib.orm.types.Default` or Empty List (default):
            All fields will be retrieved except the ones ignored by
            (set via `xynlib.orm.fields.Field.exclude`,you can get the full list
            via `xynlib.orm.base.structure.BaseStructure.excluded_field_map`).

            If `None`: Nothing about what fields to include/exclude will be passed to API.
            It should grab everything.

        query: Dictionary for query filters.
        top: Top/Maximum number of objects to return.
    Returns:
        Iterable[xynlib.orm.rest.model.RestModel]: A `Generator`, that when ran will return all
            model objects one at a time (paginating as needed while running the generator).
    &#34;&#34;&#34;
    comps = None
    if query:
        comps = URLMutable().append_query(query)

    return self.get_url(comps, top, fields=fields)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.get_url"><code class="name flex">
<span>def <span class="ident">get_url</span></span>(<span>self, url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = None, top: int = None, fields: Sequence[str] = Default) ‑> Iterable[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>The most basic public method for get requests to API.</p>
<p>Executes a basic GET request for URL, and returns back a list of objects base
on the BaseApi you pass in.
If <code>top</code> defined, we will append a 'limit' query param
for you and only return at most that many regardless of how many are really
returned from BaseApi.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields</code></strong> :&ensp;<code>xynlib.orm.types.FieldNames</code></dt>
<dd>
<p>You can pass in a list of fields.
We will attempt to pass this to API if
possible. The idea is the API will only return the list fields.
If the API honors it, then they will be the only ones set on the objects.
If the API returns more fields, they will still be set on the object.</p>
<p>The field 'id' will always be included as a field,
no need to add that one your self.</p>
<p>If <code>xynlib.orm.types.Default</code> or Empty List (default):
All fields will be retrieved except the ones ignored by
(set via <code>xynlib.orm.fields.Field.exclude</code>,you can get the full list
via <code>xynlib.orm.base.structure.BaseStructure.excluded_field_map</code>).</p>
<p>If <code>None</code>: Nothing about what fields to include/exclude will be passed to API.
It should grab everything.</p>
</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>xynlib.url.URLStr</code></dt>
<dd>
<p>URL to append on the end of the final constructed URL.
If you specify <code>url</code>, it will be
appended onto the final candidate url via <code>xynlib.url.URLMutable.append_url</code>.
If the url is still valid (via <code>xynlib.url.URL.is_valid</code>) then that's the final
url that will be used.</p>
<p>See <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> for details on how the base URL is found and then
how our passed in url is appended and final url is formatted.</p>
</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of objects to iterate though via returned <code>Generator</code>.
We will attempt to tell API to limit the returns results to this.
But even if API returns more objects in the response only this many objects will
be returned (via Generator). We will also paginate though result set until
we get enough objects. We will return less then what you pass in here if
after paginating the results there are no more left.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Iterable[xynlib.orm.rest.model.RestModel]</code></dt>
<dd>A <code>Generator</code>, that when ran will return all
model objects one at a time (paginating as needed while running the generator).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url(
        self, url: URLStr = None, top: int = None,
        fields: FieldNames = Default
) -&gt; Iterable[M]:
    &#34;&#34;&#34;
    The most basic public method for get requests to API.

    Executes a basic GET request for URL, and returns back a list of objects base
    on the BaseApi you pass in.  If `top` defined, we will append a &#39;limit&#39; query param
    for you and only return at most that many regardless of how many are really
    returned from BaseApi.

    Args:
        fields (xynlib.orm.types.FieldNames): You can pass in a list of fields.
            We will attempt to pass this to API if
            possible. The idea is the API will only return the list fields.
            If the API honors it, then they will be the only ones set on the objects.
            If the API returns more fields, they will still be set on the object.

            The field &#39;id&#39; will always be included as a field,
            no need to add that one your self.

            If `xynlib.orm.types.Default` or Empty List (default):
            All fields will be retrieved except the ones ignored by
            (set via `xynlib.orm.fields.Field.exclude`,you can get the full list
            via `xynlib.orm.base.structure.BaseStructure.excluded_field_map`).

            If `None`: Nothing about what fields to include/exclude will be passed to API.
            It should grab everything.

        url (xynlib.url.URLStr): URL to append on the end of the final constructed URL.
            If you specify `url`, it will be
            appended onto the final candidate url via `xynlib.url.URLMutable.append_url`.
            If the url is still valid (via `xynlib.url.URL.is_valid`) then that&#39;s the final
            url that will be used.

            See `RestClient.url_for_endpoint` for details on how the base URL is found and then
            how our passed in url is appended and final url is formatted.
        top (int): The maximum number of objects to iterate though via returned `Generator`.
            We will attempt to tell API to limit the returns results to this.
            But even if API returns more objects in the response only this many objects will
            be returned (via Generator). We will also paginate though result set until
            we get enough objects. We will return less then what you pass in here if
            after paginating the results there are no more left.
    Returns:
        Iterable[xynlib.orm.rest.model.RestModel]: A `Generator`, that when ran will return all
            model objects one at a time (paginating as needed while running the generator).
    &#34;&#34;&#34;

    url_for_reading = self.url_for_read(url=url, top=top, fields=fields)
    return self._get_objects(url_for_reading, top, fields)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.parse_errors_from_send_response"><code class="name flex">
<span>def <span class="ident">parse_errors_from_send_response</span></span>(<span>self, *, url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, json: Dict[str, Any], response: requests.models.Response, request_objs: List[<a title="xmodel_rest.RestModel" href="#xmodel_rest.RestModel">RestModel</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>You can override this to provide more details to the individual objects.
<code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code> call this to parse the errors into the objects http-state
(keep reading further below for more about that)
and will check for error's on the objects and call any error handlers for you.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;For more details about error handlers:</p>
<p>Error handlers let you more easily handle errors on individual objects,
since this method here will hopefully parse the error details in such a
way to easily check for then.</p>
<p>Ways to add Error Handlers and what they may use to check for errors and retry sends:</p>
<ul>
<li><code>xynlib.orm.options.ApiOptions.error_handler</code></li>
<li><code>xynlib.orm.http_state.HttpState.error_handler</code></li>
<li><code>xynlib.orm.http_state.HttpState.has_field_error</code></li>
<li><code>xynlib.orm.http_state.HttpState.retry_send</code></li>
</ul>
</div>
<p>For a real-world example of a override of this method (among other overrides) see:</p>
<ul>
<li><code>hubspot.api.common.RestClient</code>.</li>
<li><code>xyn_sdk.core.common.RestClient.parse_errors_from_send_response</code></li>
</ul>
<p>By default, this method simply sets the <code>xynlib.orm.http_state.HttpState</code> you can
get this object via <code>xynlib.orm.base.api.BaseApi.http</code> state of each request_objs with:</p>
<ul>
<li><code>xynlib.orm.http_state.HttpState.response_code</code> = Response code.</li>
<li><code>xynlib.orm.http_state.HttpState.had_error</code> = <code>True</code></li>
<li><code>xynlib.orm.http_state.HttpState.errors</code> = A list with the
<code>response.text</code> as the only item.<ul>
<li>And override of <code><a title="xmodel_rest.RestClient.parse_errors_from_send_response" href="#xmodel_rest.RestClient.parse_errors_from_send_response">RestClient.parse_errors_from_send_response()</a></code> can provide more list
items and other info (keep reading below for more details).</li>
</ul>
</li>
</ul>
<p>After doing that by default this method will get
<code><a title="xmodel_rest.RestClient.method_status_to_raise_by_default" href="#xmodel_rest.RestClient.method_status_to_raise_by_default">RestClient.method_status_to_raise_by_default</a></code>
and if there is nothing defined for the method in that dict then we use
<code>DefaultStatusSetToRaiseForSending</code>.</p>
<p>If the status code is found what is found above or if the status code is
<code>&gt;=600</code> then an <code>xynlib.orm.errors.OrmError</code> is raised.</p>
<p>Feel free to override this method and provide more details in via
<code>xynlib.orm.base.api.BaseApi.http</code>; or do something entirely different.</p>
<div class="admonition tip">
<p class="admonition-title">Tip:&ensp;Ways to set/provide more detailed error information + retrying</p>
<p>Using object at <code>xynlib.orm.base.api.BaseApi.http</code> you can uses these methods to both
provide more info and retry request:</p>
<ul>
<li><code>xynlib.orm.http_state.HttpState.add_field_error</code></li>
<li><code>xynlib.orm.http_state.HttpState.retry_send</code></li>
</ul>
<p>You can see a real-world example using these ^ at:</p>
<ul>
<li><code>xyn_sdk.core.common.RestClient.parse_errors_from_send_response</code></li>
<li><code>hubspot.api.common.RestClient.parse_errors_from_send_response</code></li>
<li><code>hubspot.processors.update_contact.execute_transactions</code></li>
</ul>
</div>
<p>It is valid to call <code>xynlib.orm.http_state.HttpState.retry_send</code>
using <code>xynlib.orm.base.api.BaseApi.http</code>
via model object's <code>xynlib.orm.rest.model.RestModel.api</code>
in this methods and in any error-handlers if you needed to retry a request for a
particular object.</p>
<p>You can even change a field/attribute value on a model object and tell it to retry
again if you pass <code>xynlib.orm.http_state.ResponseStateRetryValue.EXPORT_JSON_AGAIN</code> into
<code>xynlib.orm.http_state.HttpState.retry_send</code>, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel.remote.response_state import ResponseStateRetryValue
&gt;&gt;&gt; from xmodel_rest.model import RestModel
&gt;&gt;&gt;
&gt;&gt;&gt; model_obj: RestModel  # &lt;-- Some RestModel Object
&gt;&gt;&gt; model_obj.api.response_state.retry_send(ResponseStateRetryValue.EXPORT_JSON_AGAIN)
</code></pre>
<p>See docs for <code>xynlib.orm.http_state.HttpState.retry_send</code> for more details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>xynlib.url.URL</code></dt>
<dd>
<p>The [almost] final URL that was used to make the request.
The only thing possibly
missing is anything the 'Auth' class adds to the URL for authentication purposes
(which could have been a header and not any URL changes).</p>
<p>This URL is guaranteed to have one and only method assigned to it, the method used
for the original request.</p>
</dd>
<dt><strong><code>json</code></strong> :&ensp;<code>xynlib.orm.types.JsonDict</code></dt>
<dd>If we were able to parse any json from the response,
we provide that here.</dd>
<dt><strong><code>response</code></strong> :&ensp;<code>requests.Response</code></dt>
<dd>Response of the request that had the error.</dd>
<dt><strong><code>request_objs</code></strong> :&ensp;<code>List[xynlib.orm.rest.model.RestModel]</code></dt>
<dd>The objects, in the order we sent
them in the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_errors_from_send_response(
        self,
        *,  # Tells Python the following are named-arguments only:
        url: URL,
        json: JsonDict,
        response: requests.Response,
        request_objs: &#39;List[RestModel]&#39;
):
    &#34;&#34;&#34;
    You can override this to provide more details to the individual objects.
    `RestClient` call this to parse the errors into the objects http-state
    (keep reading further below for more about that)
    and will check for error&#39;s on the objects and call any error handlers for you.

    .. note:: For more details about error handlers:

        Error handlers let you more easily handle errors on individual objects,
        since this method here will hopefully parse the error details in such a
        way to easily check for then.

        Ways to add Error Handlers and what they may use to check for errors and retry sends:

        - `xynlib.orm.options.ApiOptions.error_handler`
        - `xynlib.orm.http_state.HttpState.error_handler`
        - `xynlib.orm.http_state.HttpState.has_field_error`
        - `xynlib.orm.http_state.HttpState.retry_send`

    For a real-world example of a override of this method (among other overrides) see:

    - `hubspot.api.common.RestClient`.
    - `xyn_sdk.core.common.RestClient.parse_errors_from_send_response`

    By default, this method simply sets the `xynlib.orm.http_state.HttpState` you can
    get this object via `xynlib.orm.base.api.BaseApi.http` state of each request_objs with:

    - `xynlib.orm.http_state.HttpState.response_code` = Response code.
    - `xynlib.orm.http_state.HttpState.had_error` = `True`
    - `xynlib.orm.http_state.HttpState.errors` = A list with the
        `response.text` as the only item.
        - And override of `RestClient.parse_errors_from_send_response` can provide more list
            items and other info (keep reading below for more details).

    After doing that by default this method will get
    `RestClient.method_status_to_raise_by_default`
    and if there is nothing defined for the method in that dict then we use
    `DefaultStatusSetToRaiseForSending`.

    If the status code is found what is found above or if the status code is
    `&gt;=600` then an `xynlib.orm.errors.OrmError` is raised.

    Feel free to override this method and provide more details in via
    `xynlib.orm.base.api.BaseApi.http`; or do something entirely different.

    .. tip:: Ways to set/provide more detailed error information + retrying

        Using object at `xynlib.orm.base.api.BaseApi.http` you can uses these methods to both
        provide more info and retry request:

        - `xynlib.orm.http_state.HttpState.add_field_error`
        - `xynlib.orm.http_state.HttpState.retry_send`

        You can see a real-world example using these ^ at:

        - `xyn_sdk.core.common.RestClient.parse_errors_from_send_response`
        - `hubspot.api.common.RestClient.parse_errors_from_send_response`
        - `hubspot.processors.update_contact.execute_transactions`

    It is valid to call `xynlib.orm.http_state.HttpState.retry_send`
    using `xynlib.orm.base.api.BaseApi.http`
    via model object&#39;s `xynlib.orm.rest.model.RestModel.api`
    in this methods and in any error-handlers if you needed to retry a request for a
    particular object.

    You can even change a field/attribute value on a model object and tell it to retry
    again if you pass `xynlib.orm.http_state.ResponseStateRetryValue.EXPORT_JSON_AGAIN` into
    `xynlib.orm.http_state.HttpState.retry_send`, like so:

    &gt;&gt;&gt; from xmodel.remote.response_state import ResponseStateRetryValue
    &gt;&gt;&gt; from xmodel_rest.model import RestModel
    &gt;&gt;&gt;
    &gt;&gt;&gt; model_obj: RestModel  # &lt;-- Some RestModel Object
    &gt;&gt;&gt; model_obj.api.response_state.retry_send(ResponseStateRetryValue.EXPORT_JSON_AGAIN)

    See docs for `xynlib.orm.http_state.HttpState.retry_send` for more details.

    Args:
        url (xynlib.url.URL): The [almost] final URL that was used to make the request.
            The only thing possibly
            missing is anything the &#39;Auth&#39; class adds to the URL for authentication purposes
            (which could have been a header and not any URL changes).

            This URL is guaranteed to have one and only method assigned to it, the method used
            for the original request.
        json (xynlib.orm.types.JsonDict): If we were able to parse any json from the response,
            we provide that here.
        response (requests.Response): Response of the request that had the error.
        request_objs (List[xynlib.orm.rest.model.RestModel]): The objects, in the order we sent
            them in the request.
    &#34;&#34;&#34;
    # If the response was successful, and we don&#39;t know what the body contents look like,
    # so there is nothing more to do.  Subclasses of RestClient class should override this
    # method if there are more things inside response body to indicate errors for particular
    # objects if we sent more then one object in the same request.
    if response.status_code &lt; 300:
        return

    # TODO: Consolidate this and self.get_all_objects() error handling logging/exceptions.

    url_methods = url.methods
    assert len(url_methods) == 1, (
        f&#34;Should only be one method ({url_methods}) for url ({url}).&#34;
    )

    http_method = url_methods[0]
    status_code = response.status_code

    log.warning(
        f&#34;({http_method}): Non-success request response code ({status_code}) for url &#34;
        f&#34;({url}) with raw response ({response.text}).&#34;
    )

    # If we failed due to an authorization issue, we need to stop processing and raise
    # an exception, there is something wrong with our configuration, and we are very
    # likely to keep failing, so might as well stop here.
    status_map = self.method_status_to_raise_by_default
    if not status_map:
        status_map = {}

    # todo: I think I would like to try any error handlers first before defaulting
    #       back to an exception.
    statuses_to_raise = status_map.get(
        http_method, DefaultStatusSetToRaiseForSending
    )

    for obj in request_objs:
        # Communicate to each object about its current api http error status.
        http = obj.api.response_state
        http.had_error = True
        http.response_code = status_code

        # Likely the raw response has more details that pertain to the situation,
        # so just put the response text in the http errors list.
        http.errors = [response.text]

    # &gt;= 600 should never happen, it means that the http server is totally screwed up.
    if status_code &gt;= 600 or status_code in statuses_to_raise:
        try:
            # Try to get some detail out of the response.
            #
            # todo: (
            #     This is Xyngular specific, consider moving this to the
            #     xyn_sdk.core.common.RestClient subclass
            #  ).
            detail = response.json().get(&#39;detail&#39;)
        except (ValueError, AttributeError):
            detail = None

        raise XynRestError(
            f&#34;API result for url ({url}) returned &#34;
            f&#34;status ({status_code}), with detail &#34;
            f&#34;({detail}) with raw response &#34;
            f&#34;({response.text}) with objects ({request_objs}).&#34;
        )</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.parse_json_from_get_response"><code class="name flex">
<span>def <span class="ident">parse_json_from_get_response</span></span>(<span>self, *, url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, response: requests.models.Response) ‑> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>When we have a response for a GET request, this is called to parse the JSON out of it.</p>
<p>For a real-world example of a override of this method (among other overrides) see
<code>hubspot.api.common.RestClient</code>.</p>
<h2 id="parsing-error">Parsing Error</h2>
<p>First thing we look for are handling response-level errors and conditions,
such as 500 errors. Or situations where there is no valid JSON to extract from the
response (invalid JSON syntax).</p>
<p>By default if <code>response.status_code</code> is:</p>
<ul>
<li>404: Log warning.</li>
<li>401/403/5xx/4xx: Raise an XynRestError.<ul>
<li>We will try to parse JSON to get some more detail out of it to log with;
we then raise an XynRestError.</li>
</ul>
</li>
</ul>
<h2 id="parsing-json">Parsing JSON</h2>
<p>This basic REST <code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code> expects:
- For multiple results: a dict with a key that has a list of dicts,
or a list of dicts. We could have a list with just one dict in it.
- For a request that always has a single result: a single dict is usually what is needed.</p>
<p>For each of these dict(s), the standard dict-format is:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; {&quot;attr-name&quot;: &quot;attr-value&quot;}
</code></pre>
<p>If it's something else, this is normally handled in the
<code>xynlib.orm.base.api.BaseApi.update_from_json</code> / <code>xynlib.orm.base.api.BaseApi.json</code> methods
associated with Model via type-hint on <code>xynlib.orm.rest.model.RestModel.api</code>.
You can override theose methods to manipulate the json-dict you get passed
to the standard format before passing it to the <code>super()</code> implementation.
You can see an example of this in <code>hubspot.api.common.BaseApi.json</code>.</p>
<p>If the structure outside of the dict is diffrent, then that's handled in this
method unless the only diffrence is the key used to get the multiple results.
You can easily configure the key to use to get the multiple results list via
<code>xynlib.orm.base.structure.BaseStructure.multiple_results_json_path</code>.</p>
<p>Example of settting <code>xynlib.orm.base.structure.BaseStructure.multiple_results_json_path</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel_rest import RestModel
&gt;&gt;&gt;
&gt;&gt;&gt; class MyModel(
...     RestModel[&quot;MyModel&quot;],
...     multiple_results_json_path=&quot;response_list&quot;
... )
...     first_name: str
&gt;&gt;&gt;
&gt;&gt;&gt; # A response like this from API would now work correctly with MyModel:
&gt;&gt;&gt; {
...     &quot;response_list&quot;: [
...         {&quot;id&quot;: 1, &quot;first_name&quot;: &quot;Gordan&quot;}.
...         {&quot;id&quot;: 2, &quot;first_name&quot;: &quot;JD&quot;}
...     ]
... }
</code></pre>
<p>Most of the attributes <code>xynlib.orm.base.structure.BaseStructure</code> are configurable via
class arguments, like you see in the above example.
For more information on this see:</p>
<ul>
<li><code>xynlib.orm.base.structure.BaseStructure.configure_for_model_type</code></li>
<li><code>xynlib.orm.base.model.RestModel.__init_subclass__</code></li>
<li><code>xynlib.orm.base.model.RestModel</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>URL</code></dt>
<dd>The URL we got. Keep in mind the auth provider can add or modify URL if
needed,
but it won't be visible in the url passed here. Therefore, you can feel free to log
the url out if needed, as it should not contain any secrets.</dd>
<dt><strong><code>response</code></strong> :&ensp;<code>requests.Response</code></dt>
<dd>
<p>The request response, from the Requests library.
Dive into the JSON, and parse out enough to get a dict for a single object
or a dict with key to a list of dicts, or a list of dicts.</p>
<p>See general doc-comment for <code><a title="xmodel_rest.RestClient.parse_json_from_get_response" href="#xmodel_rest.RestClient.parse_json_from_get_response">RestClient.parse_json_from_get_response()</a></code> for more
details.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Optional[xynlib.orm.types.JsonDict]</code></dt>
<dd>None if 404-NotFound response,
otherwise a JsonDict.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>XynRestError</code></dt>
<dd>Raise if there is a 4xx error that is NOT a 404, or a &gt;=500 error.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_json_from_get_response(
        self,
        *,
        url: URL,
        response: requests.Response
) -&gt; Optional[JsonDict]:
    &#34;&#34;&#34;
    When we have a response for a GET request, this is called to parse the JSON out of it.

    For a real-world example of a override of this method (among other overrides) see
    `hubspot.api.common.RestClient`.

    ## Parsing Error

    First thing we look for are handling response-level errors and conditions,
    such as 500 errors. Or situations where there is no valid JSON to extract from the
    response (invalid JSON syntax).

    By default if `response.status_code` is:

    - 404: Log warning.
    - 401/403/5xx/4xx: Raise an XynRestError.
        - We will try to parse JSON to get some more detail out of it to log with;
            we then raise an XynRestError.

    ## Parsing JSON

    This basic REST `RestClient` expects:
    - For multiple results: a dict with a key that has a list of dicts,
        or a list of dicts. We could have a list with just one dict in it.
    - For a request that always has a single result: a single dict is usually what is needed.

    For each of these dict(s), the standard dict-format is:

    &gt;&gt;&gt; {&#34;attr-name&#34;: &#34;attr-value&#34;}

    If it&#39;s something else, this is normally handled in the
    `xynlib.orm.base.api.BaseApi.update_from_json` / `xynlib.orm.base.api.BaseApi.json` methods
    associated with Model via type-hint on `xynlib.orm.rest.model.RestModel.api`.
    You can override theose methods to manipulate the json-dict you get passed
    to the standard format before passing it to the `super()` implementation.
    You can see an example of this in `hubspot.api.common.BaseApi.json`.

    If the structure outside of the dict is diffrent, then that&#39;s handled in this
    method unless the only diffrence is the key used to get the multiple results.
    You can easily configure the key to use to get the multiple results list via
    `xynlib.orm.base.structure.BaseStructure.multiple_results_json_path`.

    Example of settting `xynlib.orm.base.structure.BaseStructure.multiple_results_json_path`:

    &gt;&gt;&gt; from xmodel_rest import RestModel
    &gt;&gt;&gt;
    &gt;&gt;&gt; class MyModel(
    ...     RestModel[&#34;MyModel&#34;],
    ...     multiple_results_json_path=&#34;response_list&#34;
    ... )
    ...     first_name: str
    &gt;&gt;&gt;
    &gt;&gt;&gt; # A response like this from API would now work correctly with MyModel:
    &gt;&gt;&gt; {
    ...     &#34;response_list&#34;: [
    ...         {&#34;id&#34;: 1, &#34;first_name&#34;: &#34;Gordan&#34;}.
    ...         {&#34;id&#34;: 2, &#34;first_name&#34;: &#34;JD&#34;}
    ...     ]
    ... }

    Most of the attributes `xynlib.orm.base.structure.BaseStructure` are configurable via
    class arguments, like you see in the above example.
    For more information on this see:

    - `xynlib.orm.base.structure.BaseStructure.configure_for_model_type`
    - `xynlib.orm.base.model.RestModel.__init_subclass__`
    - `xynlib.orm.base.model.RestModel`

    Args:
        url (URL): The URL we got. Keep in mind the auth provider can add or modify URL if
            needed,
            but it won&#39;t be visible in the url passed here. Therefore, you can feel free to log
            the url out if needed, as it should not contain any secrets.
        response (requests.Response): The request response, from the Requests library.
            Dive into the JSON, and parse out enough to get a dict for a single object
            or a dict with key to a list of dicts, or a list of dicts.

            See general doc-comment for `RestClient.parse_json_from_get_response` for more
            details.
    Returns:
        Optional[xynlib.orm.types.JsonDict]: None if 404-NotFound response,
            otherwise a JsonDict.
    Raises:
        XynRestError: Raise if there is a 4xx error that is NOT a 404, or a &gt;=500 error.
    &#34;&#34;&#34;
    status = response.status_code

    if status == 404:
        log.warning(
            f&#34;API result status 404 for GET on url ({url}). &#34;
            f&#34;Returning blank list/None.&#34;
        )
        return None

    if status == 401 or status == 403:
        try:
            detail = response.json().get(&#39;detail&#39;)
        except ValueError:
            detail = response.text

        raise XynRestError(
            f&#34;API result returned unauthorized ({status}) for url &#34;
            f&#34;({url}) detail: ({detail})&#34;
        )

    if status &gt;= 500:
        raise XynRestError(
            f&#34;API result status ({status}) &gt;= 500 for GET on url &#34;
            f&#34;({url}) with raw response text ({response.text}).&#34;
        )

    if status &gt;= 400:
        raise XynRestError(
            f&#34;API result status ({status}) is a 4xx (and NOT 404/401/403) for GET on url &#34;
            f&#34;({url}) for response ({response.text}).&#34;
        )

    try:
        return response.json()
    except ValueError as e:
        raise XynRestError(
            f&#34;Unparsable JSON in response for status ({status}) for url ({url}) with &#34;
            f&#34;response text ({response.text}).&#34;
        )</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.send_objs"><code class="name flex">
<span>def <span class="ident">send_objs</span></span>(<span>self, objs: Iterable[<a title="xmodel_rest.RestModel" href="#xmodel_rest.RestModel">RestModel</a>[M]], *, url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = None, send_limit: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends <code>objs</code> to the API as efficiently as possible. If you specify <code>url</code>, it will be
appended onto the final candidate url via <code>xynlib.url.URLMutable.append_url</code>.
If the url is still valid (via <code>xynlib.url.URL.is_valid</code>) then that's the final
url that will be used.</p>
<p>See <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> for details on how the base URL is found and then how
our passed in url is appended and final url is formatted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>Iterable[xynlib.orm.rest.model.RestModel]</code></dt>
<dd>Objects to send to API.
If an object has not changes and <code>RestClient.enable_send_changed_only</code> is <code>True</code>
then it will be skipped.
Otherwise the entire object is sent.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>xynlib.url.URLStr</code></dt>
<dd>url to append to final candidate url.</dd>
<dt><strong><code>send_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>How many objects to send at a time (batch size).
Leave as None to use the default. You can override it by passing a number here.</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_objs(
        self, objs: &#34;Iterable[RestModel[M]]&#34;, *, url: URLStr = None, send_limit: int = None
):
    &#34;&#34;&#34;
    Sends `objs` to the API as efficiently as possible. If you specify `url`, it will be
    appended onto the final candidate url via `xynlib.url.URLMutable.append_url`.
    If the url is still valid (via `xynlib.url.URL.is_valid`) then that&#39;s the final
    url that will be used.

    See `RestClient.url_for_endpoint` for details on how the base URL is found and then how
    our passed in url is appended and final url is formatted.

    Args:
        objs (Iterable[xynlib.orm.rest.model.RestModel]): Objects to send to API.
            If an object has not changes and `RestClient.enable_send_changed_only` is `True`
            then it will be skipped.  Otherwise the entire object is sent.

        url (xynlib.url.URLStr): url to append to final candidate url.

        send_limit (int): How many objects to send at a time (batch size).
            Leave as None to use the default. You can override it by passing a number here.

    Returns:

    &#34;&#34;&#34;
    url = URL.ensure_url(url)

    def model_to_request_item(obj: &#34;RestModel[M]&#34;) -&gt; &#34;Optional[Tuple[RestModel, JsonDict]]&#34;:
        json: JsonDict = obj.api.json(
            only_include_changes=self.enable_send_changes_only,
            log_output=True
        )
        if json is None:
            log.debug(f&#34;API Obj {obj} did not have any changes to send, skipping.&#34;)
            return None
        # Make a tuple and return it as one of the items to send to `_send_objs_to_url`.
        item = (obj, json)
        return item

    def request_item_to_model(item: Any):
        return item[0]

    def debug_log_item(item):
        log.debug(f&#34;Sending JSON ({item[1]})&#34;)

    starting_objects = list(xloop(objs))
    objs_by_endpoint = self._create_deque_verify_and_reset_http_state(starting_objects)
    self._do_http_method_on_objs(
        objects=objs_by_endpoint,
        url_generator=self.url_for_send,  # noqa: See note about python 3.8
        object_to_request_item=model_to_request_item,
        request_item_to_obj=request_item_to_model,
        log_request_item=debug_log_item,
        request_generator=self._send_objs_to_url,
        send_limit=send_limit,
        url=url
    )

    # If no unhandled error happened (ie: exception),
    # we will get to this point.
    for obj in starting_objects:
        obj.api.did_send()</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.url_for_delete"><code class="name flex">
<span>def <span class="ident">url_for_delete</span></span>(<span>self, *, url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, model_objs: Sequence[<a title="xmodel_rest.model.RestModel" href="model.html#xmodel_rest.model.RestModel">RestModel</a>]) ‑> <a title="xurls.url.URLMutable" href="../xurls/url.html#xurls.url.URLMutable">URLMutable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Simply calls <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> and returns the result; with
<code>xynlib.url.HTTPDelete</code>
as the only <code>methods</code> arg and singular_values set as <code>(True, None)</code> if there is more
than one <code>model_objs</code> or <code>(False,)</code> if there is only one object to delete.</p>
<p>See <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> for more details.
You may also glean some more insight from <code><a title="xmodel_rest.RestClient.url_for_send" href="#xmodel_rest.RestClient.url_for_send">RestClient.url_for_send()</a></code> and
<code><a title="xmodel_rest.RestClient.url_for_read" href="#xmodel_rest.RestClient.url_for_read">RestClient.url_for_read()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>xynlib.url.URL</code></dt>
<dd>This is passed to <code>url</code> arg on <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code>.
It's supposed to be the final url appended to the resulting URL via
<code>xynlib.url.URLMutable.append_url</code>.</dd>
<dt><strong><code>model_objs</code></strong> :&ensp;<code>Sequence[xynlib.orm.rest.model.RestModel]</code></dt>
<dd>Objects to delete.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xynlib.url.URLMutable</code></dt>
<dd>Final url used to delete the passed in objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_for_delete(
        self, *, url: URL, model_objs: Sequence[RestModel]
) -&gt; URLMutable:
    &#34;&#34;&#34;
    Simply calls `RestClient.url_for_endpoint` and returns the result; with
    `xynlib.url.HTTPDelete`
    as the only `methods` arg and singular_values set as `(True, None)` if there is more
    than one `model_objs` or `(False,)` if there is only one object to delete.

    See `RestClient.url_for_endpoint` for more details.
    You may also glean some more insight from `RestClient.url_for_send` and
    `RestClient.url_for_read`.

    Args:
        url (xynlib.url.URL): This is passed to `url` arg on `RestClient.url_for_endpoint`.
            It&#39;s supposed to be the final url appended to the resulting URL via
            `xynlib.url.URLMutable.append_url`.
        model_objs (Sequence[xynlib.orm.rest.model.RestModel]): Objects to delete.

    Returns:
        xynlib.url.URLMutable: Final url used to delete the passed in objects.

    &#34;&#34;&#34;
    have_multiple_models = len(model_objs) &gt; 1
    return self.url_for_endpoint(
        url=url,
        methods=(HTTPDelete,),
        singular_values=(False,) if have_multiple_models else (True, None),
        secondary_values=model_objs,
        raise_if_none=not have_multiple_models
    )</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.url_for_endpoint"><code class="name flex">
<span>def <span class="ident">url_for_endpoint</span></span>(<span>self, *, methods: Iterable[str], url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a> = None, root_url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a> = None, singular_values: Iterable[Optional[bool]] = None, secondary_values: Union[dict, <a title="xmodel_rest.model.RestModel" href="model.html#xmodel_rest.model.RestModel">RestModel</a>[~M], Sequence[<a title="xmodel_rest.model.RestModel" href="model.html#xmodel_rest.model.RestModel">RestModel</a>[~M]]] = None, raise_if_none: bool = True) ‑> Optional[<a title="xurls.url.URLMutable" href="../xurls/url.html#xurls.url.URLMutable">URLMutable</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Normally, this method is called from:</p>
<ul>
<li><code><a title="xmodel_rest.RestClient.url_for_read" href="#xmodel_rest.RestClient.url_for_read">RestClient.url_for_read()</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_send" href="#xmodel_rest.RestClient.url_for_send">RestClient.url_for_send()</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_delete" href="#xmodel_rest.RestClient.url_for_delete">RestClient.url_for_delete()</a></code></li>
</ul>
<p>To construct the final URL.</p>
<p>Returns a copy of full/appended <code>xynlib.url.URLMutable</code> for the endpoint for the api
passed, along
with the root_url and url passed in.</p>
<p>The resulting URL that is returned will only have one <code>xynlib.url.URL.methods</code>
assigned to it, which is the first method we found a valid url for in the order
in which you specify them. You can use this method to figure out what HTTP method is
needed.</p>
<p>Look at <code>xynlib.url.URL.is_valid</code> for more information about how <code>xynlib.url.URL</code>'s
are valid.</p>
<p><code>xynlib.url.URL</code> Construction Process
(when it says append, it's using <code>xynlib.url.URLMutable.append_url</code>):</p>
<ol>
<li>Start with passed in <code>root_url</code>, or a blank <code>xynlib.url.URL</code>
if <code>root_url</code> is <code>None</code> (default).</li>
<li>Append <code><a title="xmodel_rest.RestClient.base_api_url" href="#xmodel_rest.RestClient.base_api_url">RestClient.base_api_url</a></code> if not None, otherwise RestSettings.api_url.</li>
<li>Append <code><a title="xmodel_rest.RestClient.base_endpoint_url" href="#xmodel_rest.RestClient.base_endpoint_url">RestClient.base_endpoint_url</a></code>.</li>
<li>Append <code>xynlib.orm.rest.RestStructure.base_model_url</code> from
<code>xynlib.orm.base.api.BaseApi.structure</code> via <code><a title="xmodel_rest.RestClient.api" href="#xmodel_rest.RestClient.api">RestClient.api</a></code>.</li>
<li>Loop though singular_values, followed by methods, and finally each model_urls,
in that order.<ul>
<li>Append model url, and check if it's valid. If it is not, continue looping.</li>
<li>Return the first valid url that is found.</li>
</ul>
</li>
</ol>
<p>Take a look at docs for <code>xynlib.orm.rest.RestStructure.base_model_url</code> for some
more details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_url</code></strong></dt>
<dd>
<p>A url that is the starting-point for any generated candidate url that we
consider. If you don't provide one, a blank-url is the starting point.</p>
<p>Sometimes we have special base-url's depending on if we are trying to get or send
an object. An example of one is <code><a title="xmodel_rest.RestClient.root_read_url" href="#xmodel_rest.RestClient.root_read_url">RestClient.root_read_url</a></code>, which is passed in as
the <code>root_url</code> arg when attempting to do a get request via
<code><a title="xmodel_rest.RestClient.url_for_read" href="#xmodel_rest.RestClient.url_for_read">RestClient.url_for_read()</a></code>
(side note: we should have called it <code>root_url_for_read</code> probably).</p>
</dd>
<dt><strong><code>url</code></strong></dt>
<dd>
<p>After calculating a candidate endpoint url, we append this to it before checking
the url's validity. If the url is valid, we return this fully constructed
candidate url.</p>
<p>If None, then nothing will be appended to the final candidate endpoint url.</p>
</dd>
<dt><strong><code>methods</code></strong></dt>
<dd>Only use URLs where at least on of these methods are valid for it.
If None, methods are not considered when selecting URL.</dd>
<dt><strong><code>singular_values</code></strong></dt>
<dd>
<p>The order to try singular_values. Only use URLs where this matches
the singularity of the url. Will try urls in the order provided.</p>
<p>Example: (True, False) -&gt; So we look at singular url's first, and then
non-singular.</p>
<p>The default is a None for the iterable value [ie: <code>singular_values = None</code>];
this means singularity is preferred based on how many values are in the
url's 'id' query parameter. But it will ultimately consider all urls when
looking though url list.</p>
<p>If a value inside the iterable is None [ie: <code>(True, None)</code> or some such],
the <code>None</code> value will force us to look at all urls
[regardless of their singularity] based purely on their order.</p>
</dd>
<dt><strong><code>secondary_values</code></strong></dt>
<dd>Backup list of values to use if url can't satisfy a formatting
placeholder it's self.</dd>
<dt><strong><code>raise_if_none</code></strong></dt>
<dd>Raise an XynRestError instead of returning None when we can't find a
valid URL.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_for_endpoint(
        self,
        *,
        methods: Iterable[str],
        url: URL = None,
        root_url: URL = None,
        singular_values: Iterable[Union[bool, None]] = None,
        secondary_values: Union[dict, RestModel[M], Sequence[RestModel[M]]] = None,
        raise_if_none: bool = True
) -&gt; Optional[URLMutable]:
    &#34;&#34;&#34;
    Normally, this method is called from:

    - `RestClient.url_for_read`
    - `RestClient.url_for_send`
    - `RestClient.url_for_delete`

    To construct the final URL.

    Returns a copy of full/appended `xynlib.url.URLMutable` for the endpoint for the api
    passed, along
    with the root_url and url passed in.

    The resulting URL that is returned will only have one `xynlib.url.URL.methods`
    assigned to it, which is the first method we found a valid url for in the order
    in which you specify them. You can use this method to figure out what HTTP method is
    needed.

    Look at `xynlib.url.URL.is_valid` for more information about how `xynlib.url.URL`&#39;s
    are valid.

    `xynlib.url.URL` Construction Process
    (when it says append, it&#39;s using `xynlib.url.URLMutable.append_url`):

    1. Start with passed in `root_url`, or a blank `xynlib.url.URL`
       if `root_url` is `None` (default).
    2. Append `RestClient.base_api_url` if not None, otherwise RestSettings.api_url.
    3. Append `RestClient.base_endpoint_url`.
    4. Append `xynlib.orm.rest.RestStructure.base_model_url` from
       `xynlib.orm.base.api.BaseApi.structure` via `RestClient.api`.
    5. Loop though singular_values, followed by methods, and finally each model_urls,
       in that order.
        - Append model url, and check if it&#39;s valid. If it is not, continue looping.
        - Return the first valid url that is found.

    Take a look at docs for `xynlib.orm.rest.RestStructure.base_model_url` for some
    more details.

    Args:
        root_url: A url that is the starting-point for any generated candidate url that we
            consider. If you don&#39;t provide one, a blank-url is the starting point.

            Sometimes we have special base-url&#39;s depending on if we are trying to get or send
            an object. An example of one is `RestClient.root_read_url`, which is passed in as
            the `root_url` arg when attempting to do a get request via
            `RestClient.url_for_read`
            (side note: we should have called it `root_url_for_read` probably).

        url: After calculating a candidate endpoint url, we append this to it before checking
            the url&#39;s validity. If the url is valid, we return this fully constructed
            candidate url.

            If None, then nothing will be appended to the final candidate endpoint url.

        methods: Only use URLs where at least on of these methods are valid for it.
            If None, methods are not considered when selecting URL.

        singular_values: The order to try singular_values. Only use URLs where this matches
            the singularity of the url. Will try urls in the order provided.

            Example: (True, False) -&gt; So we look at singular url&#39;s first, and then
            non-singular.

            The default is a None for the iterable value [ie: `singular_values = None`];
            this means singularity is preferred based on how many values are in the
            url&#39;s &#39;id&#39; query parameter. But it will ultimately consider all urls when
            looking though url list.

            If a value inside the iterable is None [ie: `(True, None)` or some such],
            the `None` value will force us to look at all urls
            [regardless of their singularity] based purely on their order.

        secondary_values: Backup list of values to use if url can&#39;t satisfy a formatting
            placeholder it&#39;s self.

        raise_if_none: Raise an XynRestError instead of returning None when we can&#39;t find a
            valid URL.
    &#34;&#34;&#34;

    # TODO - TODO - TODO: return METHOD to use, and if response will contain obj data...

    api = self.api
    structure = api.structure

    if structure.base_model_url is False:
        raise XynRestError(
            f&#34;RestClient was asked to do something with api RestModel type ({api.model_type}),&#34;
            f&#34; but the model has a False for it&#39;s base_url, that means it does not have an &#34;
            f&#34;API endpoint the client ({self}) can use..&#34;
        )

    base_model_url = URL.ensure_url(structure.base_model_url)

    # May consider caching this in the future.
    api_url = self.base_api_url or api.settings.api_url

    # we do a copy here for efficiency/safety-purposes. We will get an error if we try
    # to modify it. We don&#39;t want to modify it accidentally after this point.
    base_url = (
        URLMutable(root_url)
        .append_url(api_url)
        .append_url(self.base_endpoint_url)
        .append_url(base_model_url).copy()
    )

    # Figure out a good default for singular_values if needed.
    if singular_values is None:
        #  For now we are assuming &#39;id&#39; as special throughout, if we do add standard
        #  generic way to remap id, pay attention to that here.
        #
        #  todo: When we must remap id, we do it via overriding `Api.json*` methods at the
        #        moment. I don&#39;t have a generic way to do it.
        #
        #   For now we assume if we have a single value, that the &#39;id&#39; in the query values
        #   is the key to use. We do this consistently across everything at the moment.
        #   The URL list of the model can put this &#39;id&#39; anywhere (see xynlib.url, formatting).
        id_value = api_url.query_value(&#39;id&#39;)
        singular_values = (None,)
        if id_value:
            if isinstance(id_value, list) and len(id_value) &gt; 0:
                singular_values = (len(id_value) == 1, None)
            else:
                singular_values = (True, None)

    all_candidate_urls_cache: List[URLMutable] = []

    # Generator that will cache the values so you can reuse generator again
    # without having to re-calculate the urls again.
    def all_urls():
        if all_candidate_urls_cache:
            for v in all_candidate_urls_cache:
                yield v
        else:
            for ep_url in structure.model_urls:
                # Make a copy, going through a list to try out on the base_url.
                # We append any url provided by caller, and then check validity.
                final_url = base_url.copy().append_url(ep_url).append_url(url)
                all_candidate_urls_cache.append(final_url)
                yield final_url

    for singular in singular_values:
        for method in methods:
            for candidate_url in all_urls():

                if singular is not None and candidate_url.singular != singular:
                    continue

                if not candidate_url.methods_contain(method):
                    continue

                if candidate_url.is_valid(
                        secondary_values=secondary_values, attach_values=True
                ):
                    candidate_url.methods = (method,)
                    return candidate_url

    if raise_if_none:
        raise XynRestError(
            f&#34;Could not find valid URL from base_url ({base_url}) + url ({url}) for API {api} &#34;
            f&#34;for methods ({methods}), singular ({singular_values}), &#34;
            f&#34;secondary values ({secondary_values}).&#34;
        )

    return None</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.url_for_next_page"><code class="name flex">
<span>def <span class="ident">url_for_next_page</span></span>(<span>self, original_url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, json_response: Dict[str, Any]) ‑> Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]</span>
</code></dt>
<dd>
<div class="desc"><p>This is called to get next url to call for next page of results in a GET request.
If you return <code>None</code>, then pagination will stop.</p>
<p>By default we just get <code>next</code> attribute in JSON response and return that.
You can see an alternative real-world example at
<code>hubspot.api.common.RestClient.url_for_next_page</code>. That shows how hubspot API does
pagination and how it's communicated to ORM library.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>original_url</code></strong> :&ensp;<code>xynlib.url.URL</code></dt>
<dd>The current url that was just requested,
as a URL object.</dd>
<dt><strong><code>json_response</code></strong> :&ensp;<code>xynlib.orm.types.JsonDict</code></dt>
<dd>The response as a JSON dict from the
requested_url.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xynlib.url.URLStr</code></dt>
<dd>Can either by a <code>xynlib.url.URL</code> or a url as a <code>str</code>.</dd>
<dt><code>None</code></dt>
<dd>pagination stops.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_for_next_page(
        self, original_url: URL, json_response: JsonDict
) -&gt; Optional[URLStr]:
    &#34;&#34;&#34;
    This is called to get next url to call for next page of results in a GET request.
    If you return `None`, then pagination will stop.

    By default we just get `next` attribute in JSON response and return that.
    You can see an alternative real-world example at
    `hubspot.api.common.RestClient.url_for_next_page`. That shows how hubspot API does
    pagination and how it&#39;s communicated to ORM library.

    Args:
        original_url (xynlib.url.URL): The current url that was just requested,
            as a URL object.

        json_response (xynlib.orm.types.JsonDict): The response as a JSON dict from the
            requested_url.

    Returns:
        xynlib.url.URLStr: Can either by a `xynlib.url.URL` or a url as a `str`.

        None: pagination stops.
    &#34;&#34;&#34;
    # Standard Xyngular API&#39;s have a &#39;next&#39; field that has a full URL to request next.
    return json_response.get(&#39;next&#39;, None)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.url_for_read"><code class="name flex">
<span>def <span class="ident">url_for_read</span></span>(<span>self, *, url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, top: int = None, fields: Sequence[str] = Default) ‑> <a title="xurls.url.URLMutable" href="../xurls/url.html#xurls.url.URLMutable">URLMutable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Given an url, top; returns the URL that should be requested for a read/get.</p>
<p><code><a title="xmodel_rest.RestClient.root_read_url" href="#xmodel_rest.RestClient.root_read_url">RestClient.root_read_url</a></code> is used a the root_url (see <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code>).</p>
<p>The <code>id</code> query value is used to determine if we should look for singular or non-singular
URL's first.
If that does not work, I look at all of them.
See <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> and it's <code>singular_values</code> Args doc for more details
about this (we pass in None for this arg to that method).</p>
<p>By default, look only for URL's that support url.HTTPGet.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Put in correct API error class below</p>
</div>
<p>If we can't find a valid url, will raise an XynRestError.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>xynlib.url.URL</code></dt>
<dd>Appended to endpoint url(s), first valid url will be used.</dd>
<dt><strong><code>fields</code></strong> :&ensp;<code>Sequence[str]</code></dt>
<dd>
<p>You can pass in a list of fields, which will be the only ones
returned in the objects.
The field 'id' will always be included, no need to add that one your self.</p>
<p>If <code>xynlib.orm.types.Default</code> or Empty List (default):
Then all fields will be retrieved except the ones ignored by default.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;<code>xynlib.orm.base.structure.BaseStructure.excluded_field_map</code> is used if</p>
<p>fields is left as Default as a way to exclude specific fields
by default.</p>
</div>
<p>If <code>None</code>: Nothing about what fields to include/exclude will be passed to API.
It should grab everything.</p>
</dd>
<dt><strong><code>top</code></strong></dt>
<dd>If provided, provides a 'max' of how many results pre-request should come back.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xynlib.url.URLMutable</code></dt>
<dd>Best url to use from among the candidate urls.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_for_read(
        self, *,
        url: URL,
        top: int = None,
        fields: FieldNames = Default
) -&gt; URLMutable:
    &#34;&#34;&#34;
    Given an url, top; returns the URL that should be requested for a read/get.

    `RestClient.root_read_url` is used a the root_url (see `RestClient.url_for_endpoint`).

    The `id` query value is used to determine if we should look for singular or non-singular
    URL&#39;s first.  If that does not work, I look at all of them.
    See `RestClient.url_for_endpoint` and it&#39;s `singular_values` Args doc for more details
    about this (we pass in None for this arg to that method).

    By default, look only for URL&#39;s that support url.HTTPGet.

    .. todo:: Put in correct API error class below

    If we can&#39;t find a valid url, will raise an XynRestError.

    Args:
        url (xynlib.url.URL): Appended to endpoint url(s), first valid url will be used.

        fields (Sequence[str]): You can pass in a list of fields, which will be the only ones
            returned in the objects.
            The field &#39;id&#39; will always be included, no need to add that one your self.

            If `xynlib.orm.types.Default` or Empty List (default):
            Then all fields will be retrieved except the ones ignored by default.

            .. note:: `xynlib.orm.base.structure.BaseStructure.excluded_field_map` is used if
                fields is left as Default as a way to exclude specific fields
                by default.

            If `None`: Nothing about what fields to include/exclude will be passed to API.
            It should grab everything.

        top: If provided, provides a &#39;max&#39; of how many results pre-request should come back.
    Returns:
        xynlib.url.URLMutable: Best url to use from among the candidate urls.
    &#34;&#34;&#34;
    api = self.api

    excluded_field_map = api.structure.excluded_field_map()
    only_fields: Optional[Set[str]] = None
    ignore_fields: Optional[Set[str]] = None

    extra_query: Query = {}

    if fields is not None:
        if fields and fields is not Default:
            only_fields = set(xloop(fields))
        elif excluded_field_map:
            # noinspection PyTypeChecker
            ignore_fields = excluded_field_map.keys()

    # todo: For now, assume fields are specified this way, split it out later when we need to.
    if only_fields:
        only_fields.add(&#39;id&#39;)
        # It may be ok with a `set`, but just use a `list` for now.
        extra_query[&#39;field__in&#39;] = list(only_fields)
    elif ignore_fields:
        extra_query[&#39;field!__in&#39;] = list(ignore_fields)

    # Append user provided url on-top of the extra_query, the passed in url overrides any
    # conflicting values provided.
    if extra_query:
        url = URLMutable(query=extra_query).append_url(url)

    final_url = self.url_for_endpoint(
        root_url=URL.ensure_url(self.root_read_url), url=url, methods=(HTTPGet,)
    )

    formatting_options = final_url.formatting_options or DefaultQueryValueListFormat

    limit_name = formatting_options.query_limit_key or &#34;limit&#34;
    max_limit = formatting_options.query_limit_max
    query_limit_value = None
    if limit_name in final_url.query:
        query_limit_value = final_url.query.get(limit_name)

    final_limit_value = None
    if top:
        # Top has the highest priority and will override anything passed into the query.
        if max_limit and top &gt; max_limit:
            # Some endpoints have a max query limit which we will respect here.
            final_limit_value = max_limit
        else:
            # The top value was fine, so we will add or override the limit in the query for
            # the final url.
            final_limit_value = top
    elif query_limit_value:
        # This will be overridden if it is higher than the configured max limit, otherwise we
        # will leave it alone within the final url.
        if max_limit and query_limit_value &gt; max_limit:
            final_limit_value = max_limit
    elif formatting_options.query_limit_always_include:
        # We want to set the limit, but we will not be able to if there was no top,
        # manual query limit, or max limit configured.
        # TODO: We may want to raise an exception saying the max_limit was not configured and
        #  that query_limit_always_include depends on that value. Or have a hardcoded value
        #  we default to.
        if max_limit:
            final_limit_value = max_limit

    if final_limit_value:
        final_url.query_add(limit_name, final_limit_value)

    return final_url</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestClient.url_for_send"><code class="name flex">
<span>def <span class="ident">url_for_send</span></span>(<span>self, *, model_objs: Sequence[<a title="xmodel_rest.model.RestModel" href="model.html#xmodel_rest.model.RestModel">RestModel</a>], url: <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a> = None) ‑> Union[<a title="xmodel_rest.client.GeneratedURL" href="client.html#xmodel_rest.client.GeneratedURL">GeneratedURL</a>, <a title="xmodel_rest.client.UseSingularValueType" href="client.html#xmodel_rest.client.UseSingularValueType">UseSingularValueType</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>We have more than one model object, we return UseSingularValue if we can't find a valid url
to indicate that a single model object should be tried instead of multiple.</p>
<p>If we only have a single, we will raise an exception.</p>
<p>If we send back a result, it's a <code>GeneratedURL</code>. This <code>GeneratedURL</code> contains the
<code>xurls.URL</code>
to use plus the model objects that are valid for this URL.</p>
<p>You must call us again
in the future with the other object(s) that did not make it the first time to get
their URL. If you call us back a second time with other objects in addition to the ones
that were previously skipped, we may still skip the previously skipped ones again. Just
keep calling us over and over and eventually everything will have a URL to send it with
or you will get an exception.</p>
<p>The RestModel classes have an ordered list of URLs attached to the class that we try to use
in order when we need to find a URL to send/get objects.</p>
<p>By default: We attempt to find a method/url using a prioritized method order.
We look for he first valid url in this prioritized order.
I use <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> to find the URL for each method in the priority list
below.
The first valid url (<code>orm.url.URL.is_valid</code>) is what is used.</p>
<p>The method priority list is:</p>
<ol>
<li><code>xynlib.url.HTTPPatch</code></li>
<li><code>xynlib.url.HTTPPost</code></li>
<li><code>xynlib.url.HTTPPut</code></li>
</ol>
<p>If a <code>xynlib.url.URL.is_valid</code> method/url is not found we go to the next method and try
again by calling <code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">RestClient.url_for_endpoint()</a></code> with the proper arguments.</p>
<p>If one is found, we will return a url to use that method/url first with all objects
that can use that method/url. It could be only 100 objects are supported in a single
request (as an example). So we may use the same method/url each time you call us as
we "paginate" though all the objects to send. We will do as many objects as we can as
you call us back with this same higher-priority url/method.</p>
<p>Eventually, all of the objects for this higher-priority url will have been gotten to
and what are left over (if any) are objects that need a different lower-priority
method/url.
When they are the only ones passed into this method, we will use that lower-priority
method/url.</p>
<p>This will keep happening until all objects have had a url to use with them.
If all the objects passed into this method can't find a <code>xynlib.url.URL.is_valid</code> url
to use, then we will raise an <code>xynlib.orm.errors.OrmError</code>.</p>
<p>If you pass us no model objects, we will also raise an <code>xynlib.orm.errors.OrmError</code>.
This usually means you meant to pass in some objcts but did not by mistake.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_objs</code></strong></dt>
<dd>RestModel objects to send.</dd>
<dt><strong><code>url</code></strong></dt>
<dd>URL to append to end of final URL. This final URL is checked for validity.
If it's valid, we will return it.
Otherwise we try other URL's.</dd>
</dl>
<p>Returns
UseSingularValue: We are requesting you call us back with a single model object.</p>
<pre><code>GeneratedURL: The URL and objects to send.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_for_send(
        self, *, model_objs: Sequence[RestModel], url: URL = None
        # todo: `GeneratedURL` revamp!!!!
) -&gt; Union[GeneratedURL, UseSingularValueType]:
    &#34;&#34;&#34;
    We have more than one model object, we return UseSingularValue if we can&#39;t find a valid url
    to indicate that a single model object should be tried instead of multiple.

    If we only have a single, we will raise an exception.

    If we send back a result, it&#39;s a `GeneratedURL`. This `GeneratedURL` contains the
    `xurls.URL`
    to use plus the model objects that are valid for this URL.

    You must call us again
    in the future with the other object(s) that did not make it the first time to get
    their URL. If you call us back a second time with other objects in addition to the ones
    that were previously skipped, we may still skip the previously skipped ones again. Just
    keep calling us over and over and eventually everything will have a URL to send it with
    or you will get an exception.

    The RestModel classes have an ordered list of URLs attached to the class that we try to use
    in order when we need to find a URL to send/get objects.

    By default: We attempt to find a method/url using a prioritized method order.
    We look for he first valid url in this prioritized order.
    I use `RestClient.url_for_endpoint` to find the URL for each method in the priority list
    below.
    The first valid url (`orm.url.URL.is_valid`) is what is used.

    The method priority list is:

    1. `xynlib.url.HTTPPatch`
    2. `xynlib.url.HTTPPost`
    3. `xynlib.url.HTTPPut`

    If a `xynlib.url.URL.is_valid` method/url is not found we go to the next method and try
    again by calling `RestClient.url_for_endpoint` with the proper arguments.

    If one is found, we will return a url to use that method/url first with all objects
    that can use that method/url. It could be only 100 objects are supported in a single
    request (as an example). So we may use the same method/url each time you call us as
    we &#34;paginate&#34; though all the objects to send. We will do as many objects as we can as
    you call us back with this same higher-priority url/method.

    Eventually, all of the objects for this higher-priority url will have been gotten to
    and what are left over (if any) are objects that need a different lower-priority
    method/url.
    When they are the only ones passed into this method, we will use that lower-priority
    method/url.

    This will keep happening until all objects have had a url to use with them.
    If all the objects passed into this method can&#39;t find a `xynlib.url.URL.is_valid` url
    to use, then we will raise an `xynlib.orm.errors.OrmError`.

    If you pass us no model objects, we will also raise an `xynlib.orm.errors.OrmError`.
    This usually means you meant to pass in some objcts but did not by mistake.

    Args:
        model_objs: RestModel objects to send.
        url: URL to append to end of final URL. This final URL is checked for validity.
            If it&#39;s valid, we will return it.  Otherwise we try other URL&#39;s.
    Returns
        UseSingularValue: We are requesting you call us back with a single model object.

        GeneratedURL: The URL and objects to send.
    &#34;&#34;&#34;
    # We first look for Patch, then Put, and finally a Post method.

    if not model_objs:
        raise XynRestError(
            &#34;For some reason we got passed no model objects when generating url.&#34;
        )

    have_multiple_models = len(model_objs) &gt; 1
    methods = [HTTPPatch]

    url = self.url_for_endpoint(
        url=url,
        methods=(HTTPPatch,),
        singular_values=(False,) if have_multiple_models else (True, None),
        secondary_values=model_objs,
        raise_if_none=False
    )

    if url:
        return GeneratedURL(url=url, models=model_objs)

    # Else, we have to figure out if we are creating/modifying objects to select correct
    # http method to use. We look for creation first.

    created = []
    updated = []
    for model in model_objs:
        if model.id is None:
            # We are creating the object, we have no id.
            created.append(model)
        else:
            updated.append(model)

    if created:
        # for now, we send back a single URL that indicates we are only creating.
        url = self.url_for_endpoint(
            url=url,
            methods=(HTTPPost,),
            singular_values=(False,) if have_multiple_models else (True, None),
            secondary_values=created,
            raise_if_none=not have_multiple_models
        )
        if not url:
            return UseSingularValue
        return GeneratedURL(url=url, models=created)

    url = self.url_for_endpoint(
        url=url,
        methods=(HTTPPut,),
        singular_values=(False,) if have_multiple_models else (True, None),
        secondary_values=updated,
        raise_if_none=not have_multiple_models
    )

    if not url:
        return UseSingularValue

    return GeneratedURL(url=url, models=updated)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel_rest.RestModel"><code class="flex name class">
<span>class <span class="ident">RestModel</span></span>
<span>(</span><span>*args, id=Default, **initial_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Intended to be used as general base-class for use with rest-api's.</p>
<p>Sets <code>xynlib.orm.base.model.BaseModel</code> to use the following classes:</p>
<ul>
<li><code><a title="xmodel_rest.RestApi" href="#xmodel_rest.RestApi">RestApi</a></code><ul>
<li><code><a title="xmodel_rest.RestAuth" href="#xmodel_rest.RestAuth">RestAuth</a></code></li>
<li><code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code></li>
<li><code><a title="xmodel_rest.RestStructure" href="#xmodel_rest.RestStructure">RestStructure</a></code></li>
</ul>
</li>
</ul>
<p>These classes are generally useful for rest-based API's.</p>
<p>Creates a new model object. The first/second params need to be passed as positional
arguments. The rest must be sent as key-word arguments. Everything is optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Specify the <code>BaseModel.id</code> attribute, if you know it. If left as Default, nothing
will be set on it. It could be set to something via args[0] (ie: a JSON dict).
If you do provide a value, it be set last after everything else has been set.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>
<p>I don't want to take names from what you could put into 'initial_values',
so I keep it as position-only *args. Once Python 3.8 comes out, we can use a
new feature where you can specify some arguments as positional-only and not
keyword-able.</p>
<h2 id="firstarg-if-dict">FirstArg - If Dict:</h2>
<p>If raw dictionary parsed from JSON string. It just calls
<code>self.api.update_from_json(args[0])</code> for you.</p>
<h2 id="firstart-if-basemodel">FirstArt - If BaseModel:</h2>
<p>If a <code>BaseModel</code>, will copy fields over that have the same name.
You can use this to duplicate a Model object, if you want to copy it.
Or can be used to copy fields from one model type into another,
on fields that are the same name.</p>
<p>Will ignore fields that are present on one but not the other.
Only copy fields that are on both models types.</p>
</dd>
<dt><strong><code>**initial_values</code></strong></dt>
<dd>Let's you specify other attribute values for convenience.
They will be set into the object the same way you would normally doing it:
ie: <code>model_obj.some_attr = v</code> is the same as <code>ModelClass(some_attr=v)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestModel(RemoteModel[M], lazy_loader=_lazy_load_types):
    &#34;&#34;&#34; Intended to be used as general base-class for use with rest-api&#39;s.

        Sets `xynlib.orm.base.model.BaseModel` to use the following classes:

        - `RestApi`
            - `RestAuth`
            - `RestClient`
            - `RestStructure`

        These classes are generally useful for rest-based API&#39;s.
    &#34;&#34;&#34;
    api: &#34;RestApi[M]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.remote.model.RemoteModel" href="../xmodel/remote/model.html#xmodel.remote.model.RemoteModel">RemoteModel</a></li>
<li><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.RestModel.api"><code class="name">var <span class="ident">api</span> : <a title="xmodel_rest.api.RestApi" href="api.html#xmodel_rest.api.RestApi">RestApi</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.<code><a title="xmodel.base.model.BaseModel.api" href="../xmodel/base/model.html#xmodel.base.model.BaseModel.api">api</a></code>
</p>
<div class="desc inherited"><p>Used to access the api class, which is used to retrieve/send objects to/from api …</p></div>
</dd>
<dt id="xmodel_rest.RestModel.id"><code class="name">var <span class="ident">id</span> : int</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.model.RemoteModel" href="../xmodel/remote/model.html#xmodel.remote.model.RemoteModel">RemoteModel</a></code>.<code><a title="xmodel.remote.model.RemoteModel.id" href="../xmodel/remote/model.html#xmodel.remote.model.RemoteModel.id">id</a></code>
</p>
<div class="desc inherited"><p>Primary identifier for object, used with API endpoint.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xmodel_rest.RestModel.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>*, lazy_loader: Callable[[Type[~M]], None] = None, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.model.RemoteModel" href="../xmodel/remote/model.html#xmodel.remote.model.RemoteModel">RemoteModel</a></code>.<code><a title="xmodel.remote.model.RemoteModel.__init_subclass__" href="../xmodel/base/model.html#xmodel.remote.model.RemoteModel.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><p>We take all arguments (except <code>lazy_loader</code>) passed into here and send them to the method
on our structure:
…</p></div>
</dd>
</dl>
</dd>
<dt id="xmodel_rest.RestSettings"><code class="flex name class">
<span>class <span class="ident">RestSettings</span></span>
</code></dt>
<dd>
<div class="desc"><p>A basic ConfigType subclass with a few basic features that are useful.</p>
<p>To see RestSettings class used by the Xyngular-API classes see:
<code>xyn_sdk.core.common.RestSettings</code>.</p>
<p>You can subclass this or <code>xynlib.orm.remote.settings.RestSettings</code> if you want a more basic
version for other types of client. But when using the <code>xynlib.orm.rest.client.RestClient</code>
it's expected to use <code><a title="xmodel_rest.RestSettings" href="#xmodel_rest.RestSettings">RestSettings</a></code> (or a subclass of <code><a title="xmodel_rest.RestSettings" href="#xmodel_rest.RestSettings">RestSettings</a></code>).</p>
<p>You can use a custom-subclass of <code><a title="xmodel_rest.RestSettings" href="#xmodel_rest.RestSettings">RestSettings</a></code> by
creating a custom
<code>xynlib.orm.base.api.BaseApi</code> subclass
and then setting the type-hint for <code>xynlib.orm.base.api.BaseApi.settings</code> to you custom
settings class.</p>
<p>For more details see
<a href="./api.html#use-of-type-hints-for-changing-used-type">Use of Type Hints for Changing Type Used</a></p>
<h2 id="details-when-using-xsettingssettings-with-restsettings">Details when using <code>xsettings.Settings</code> with RestSettings</h2>
<p>You can use a <code>xsettings.Settings</code> as part of your subclass,
just re-define the <code>root_url</code> and <code>base_api_url</code> as type-hints,
and add any others you need.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>I want to have this inherit from <code>xsettings.Settings</code>, but I need to
add support for inheritance from another <code>xsettings.Settings</code> class.
Should be easy to add in, just need to do it sometime.
Don't have time right now, so leaving this todo here for now.
It would allow us to remove the properties below,
as settings would automatically raise an exception with a nice message,
and it would allow sub-classes of this to inherit the settings-fields
so they don't have to redefine them again in their own Settings subclass.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestSettings(Dependency):
    &#34;&#34;&#34;
    A basic ConfigType subclass with a few basic features that are useful.

    To see RestSettings class used by the Xyngular-API classes see:
    `xyn_sdk.core.common.RestSettings`.

    You can subclass this or `xynlib.orm.remote.settings.RestSettings` if you want a more basic
    version for other types of client. But when using the `xynlib.orm.rest.client.RestClient`
    it&#39;s expected to use `RestSettings` (or a subclass of `RestSettings`).

    You can use a custom-subclass of `RestSettings` by  creating a custom
    `xynlib.orm.base.api.BaseApi` subclass
    and then setting the type-hint for `xynlib.orm.base.api.BaseApi.settings` to you custom
    settings class.

    For more details see
    [Use of Type Hints for Changing Type Used](./api.html#use-of-type-hints-for-changing-used-type)

    ## Details when using `xsettings.Settings` with RestSettings

    You can use a `xsettings.Settings` as part of your subclass,
    just re-define the `root_url` and `base_api_url` as type-hints,
    and add any others you need.


    .. todo:: I want to have this inherit from `xsettings.Settings`, but I need to
        add support for inheritance from another `xsettings.Settings` class.
        Should be easy to add in, just need to do it sometime.
        Don&#39;t have time right now, so leaving this todo here for now.
        It would allow us to remove the properties below,
        as settings would automatically raise an exception with a nice message,
        and it would allow sub-classes of this to inherit the settings-fields
        so they don&#39;t have to redefine them again in their own Settings subclass.
    &#34;&#34;&#34;

    root_url: URLStr = URLMutable()
    &#34;&#34;&#34; The basis for urls returned by `self.api_url`.
        You can set global defaults for all URL&#39;s that base them selves on this here.
    &#34;&#34;&#34;

    retry_requests: bool = Default
    &#34;&#34;&#34;
    If Default/True (default): Will retry some types of requests such as ones responding with
    specific 5xx errors; or if there is a connection or timeout error.

    They will be retried once before falling back on the standard library error handling.

    If False: Won&#39;t retry, will return result without retrying it.

    The class/default value is `Default`, to help support xyn-sdk, so that by default the Settings
    retriever/default values in Settings subclass will be consulted first.

    Eventually, we may create a xyn-settings v2 to handle this better, for now
    we need to keep it as `Default` at the class-level here.

    TODO: In the future if needed: This could be a `Union[Callable, bool]`, where you could assign
    a callable that would be able to decide with logic based on the response it&#39;s handed if we
    should immediately retry the full/entire request or not.
    &#34;&#34;&#34;

    # Must put value here so pdoc3 will see the docs for it,
    # so using a property to do that and still get ability to raise an exception if not found.
    # I would have LOVED to use `xsettings.Settings` field
    # instead, but I can&#39;t until a upgrade it with an ability to use a parent Settings.
    # I have a todo (see class doc-comment above) to do that.
    @property
    def base_api_url(self) -&gt; URLStr:
        &#34;&#34;&#34;
        The basis for every BaseApi URL. When you call `RestSettings.api_url`,
        the `RestSettings.root_url` is taken and `RestSettings.base_api_url` is appended to it.

        Sub-classes and/or instances of `RestSettings` class need to set this with something.
        I would recommend using something like this in a Config sub-class:

        `base_api_url` = `ConfigVar`(&#34;ENV_OR_CONFIG_VAR_NAME&#34;)

        &gt;&gt;&gt; from xsettings import Settings
        &gt;&gt;&gt; class MySettings(Settings, RestSettings):
        ...     # Tip: Settings will auto-convert str to URL if needed!
        ...     base_api_url: URL
        &gt;&gt;&gt;
        &gt;&gt;&gt; class MyApi(BaseApi[M]):
        ...     # Tell my BaseApi subclass to use my custom settings
        ...     settings: MySettings
        &#34;&#34;&#34;
        if self._base_api_url is not None:
            return self._base_api_url

        # AttributeError works with Settings, in case sub-class inherits from Settings,
        # it will inform Settings to try and retrieve value it&#39;s self if it can.
        raise AttributeError(
            f&#39;Object {self} must have a non-None `base_api_url` attribute on it,&#39;
            f&#39;it is needed as a basic RestSettings setting value.&#39;
        )

    _base_api_url = None

    @base_api_url.setter
    def base_api_url(self, value):
        # See above base_api_url getter for doc/comments/details.
        self._base_api_url = value

    @property
    def api_url(self) -&gt; URL:
        &#34;&#34;&#34;
        Returns a new URL with base_url plus base_api_url appended to it.

        This property should be used as the base url that all other urls are appended on for
        all rest api calls using the `xynlib.orm.rest.RestClient`, in general.

        You may have a config that does not need this, because it&#39;s a configuring some
        other aspect of the system.  In that case you can ignore this.

        I put this property here so I know I could always call it on a generic ConfigType.
        &#34;&#34;&#34;
        url = self.base_api_url
        assert url, f&#34;Had no configured url for base api url for ({self}).&#34;
        return URL.ensure_url(self.root_url).copy_mutable().append_url(url)

    def copy(self: T) -&gt; T:
        return deepcopy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.RestSettings.retry_requests"><code class="name">var <span class="ident">retry_requests</span> : bool</code></dt>
<dd>
<div class="desc"><p>If Default/True (default): Will retry some types of requests such as ones responding with
specific 5xx errors; or if there is a connection or timeout error.</p>
<p>They will be retried once before falling back on the standard library error handling.</p>
<p>If False: Won't retry, will return result without retrying it.</p>
<p>The class/default value is <code>Default</code>, to help support xyn-sdk, so that by default the Settings
retriever/default values in Settings subclass will be consulted first.</p>
<p>Eventually, we may create a xyn-settings v2 to handle this better, for now
we need to keep it as <code>Default</code> at the class-level here.</p>
<p>TODO: In the future if needed: This could be a <code>Union[Callable, bool]</code>, where you could assign
a callable that would be able to decide with logic based on the response it's handed if we
should immediately retry the full/entire request or not.</p></div>
</dd>
<dt id="xmodel_rest.RestSettings.root_url"><code class="name">var <span class="ident">root_url</span> : Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]</code></dt>
<dd>
<div class="desc"><p>The basis for urls returned by <code>self.api_url</code>.
You can set global defaults for all URL's that base them selves on this here.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xmodel_rest.RestSettings.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>thread_sharable=Default, attributes_to_skip_while_copying: Optional[Iterable[str]] = Default, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__init_subclass__" href="../xinject/dependency.html#xinject.dependency.Dependency.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>thread_sharable</code></strong></dt>
<dd>If <code>False</code>: While a dependency is lazily auto-created, we will
ensure we do it per-thread, and not make it visible …</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.RestSettings.grab"><code class="name flex">
<span>def <span class="ident">grab</span></span>(<span>) ‑> ~T</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.grab" href="../xinject/dependency.html#xinject.dependency.Dependency.grab">grab</a></code>
</p>
<div class="desc inherited"><p>Gets a potentially shared dependency from the current <code>udpend.context.XContext</code> …</p></div>
</dd>
<dt id="xmodel_rest.RestSettings.proxy"><code class="name flex">
<span>def <span class="ident">proxy</span></span>(<span>) ‑> ~R</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy">proxy</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current object of <code>cls</code> …</p></div>
</dd>
<dt id="xmodel_rest.RestSettings.proxy_attribute"><code class="name flex">
<span>def <span class="ident">proxy_attribute</span></span>(<span>attribute_name: str) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.proxy_attribute" href="../xinject/dependency.html#xinject.dependency.Dependency.proxy_attribute">proxy_attribute</a></code>
</p>
<div class="desc inherited"><p>Returns a proxy-object, that when and attribute is asked for, it will
proxy it to the current attribute value on the current object of <code>cls</code> …</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel_rest.RestSettings.api_url"><code class="name">var <span class="ident">api_url</span> : <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a></code></dt>
<dd>
<div class="desc"><p>Returns a new URL with base_url plus base_api_url appended to it.</p>
<p>This property should be used as the base url that all other urls are appended on for
all rest api calls using the <code>xynlib.orm.rest.RestClient</code>, in general.</p>
<p>You may have a config that does not need this, because it's a configuring some
other aspect of the system.
In that case you can ignore this.</p>
<p>I put this property here so I know I could always call it on a generic ConfigType.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def api_url(self) -&gt; URL:
    &#34;&#34;&#34;
    Returns a new URL with base_url plus base_api_url appended to it.

    This property should be used as the base url that all other urls are appended on for
    all rest api calls using the `xynlib.orm.rest.RestClient`, in general.

    You may have a config that does not need this, because it&#39;s a configuring some
    other aspect of the system.  In that case you can ignore this.

    I put this property here so I know I could always call it on a generic ConfigType.
    &#34;&#34;&#34;
    url = self.base_api_url
    assert url, f&#34;Had no configured url for base api url for ({self}).&#34;
    return URL.ensure_url(self.root_url).copy_mutable().append_url(url)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestSettings.base_api_url"><code class="name">var <span class="ident">base_api_url</span> : Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]</code></dt>
<dd>
<div class="desc"><p>The basis for every BaseApi URL. When you call <code><a title="xmodel_rest.RestSettings.api_url" href="#xmodel_rest.RestSettings.api_url">RestSettings.api_url</a></code>,
the <code><a title="xmodel_rest.RestSettings.root_url" href="#xmodel_rest.RestSettings.root_url">RestSettings.root_url</a></code> is taken and <code><a title="xmodel_rest.RestSettings.base_api_url" href="#xmodel_rest.RestSettings.base_api_url">RestSettings.base_api_url</a></code> is appended to it.</p>
<p>Sub-classes and/or instances of <code><a title="xmodel_rest.RestSettings" href="#xmodel_rest.RestSettings">RestSettings</a></code> class need to set this with something.
I would recommend using something like this in a Config sub-class:</p>
<p><code>base_api_url</code> = <code>ConfigVar</code>("ENV_OR_CONFIG_VAR_NAME")</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xsettings import Settings
&gt;&gt;&gt; class MySettings(Settings, RestSettings):
...     # Tip: Settings will auto-convert str to URL if needed!
...     base_api_url: URL
&gt;&gt;&gt;
&gt;&gt;&gt; class MyApi(BaseApi[M]):
...     # Tell my BaseApi subclass to use my custom settings
...     settings: MySettings
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_api_url(self) -&gt; URLStr:
    &#34;&#34;&#34;
    The basis for every BaseApi URL. When you call `RestSettings.api_url`,
    the `RestSettings.root_url` is taken and `RestSettings.base_api_url` is appended to it.

    Sub-classes and/or instances of `RestSettings` class need to set this with something.
    I would recommend using something like this in a Config sub-class:

    `base_api_url` = `ConfigVar`(&#34;ENV_OR_CONFIG_VAR_NAME&#34;)

    &gt;&gt;&gt; from xsettings import Settings
    &gt;&gt;&gt; class MySettings(Settings, RestSettings):
    ...     # Tip: Settings will auto-convert str to URL if needed!
    ...     base_api_url: URL
    &gt;&gt;&gt;
    &gt;&gt;&gt; class MyApi(BaseApi[M]):
    ...     # Tell my BaseApi subclass to use my custom settings
    ...     settings: MySettings
    &#34;&#34;&#34;
    if self._base_api_url is not None:
        return self._base_api_url

    # AttributeError works with Settings, in case sub-class inherits from Settings,
    # it will inform Settings to try and retrieve value it&#39;s self if it can.
    raise AttributeError(
        f&#39;Object {self} must have a non-None `base_api_url` attribute on it,&#39;
        f&#39;it is needed as a basic RestSettings setting value.&#39;
    )</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestSettings.obj"><code class="name">var <span class="ident">obj</span> : <a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.obj" href="../xinject/dependency.html#xinject.dependency.Dependency.obj">obj</a></code>
</p>
<div class="desc inherited"><p>class property/attribute that will return the current dependency for the subclass
it's asked on by calling <code>Dependency.grab</code>, passing no extra …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.RestSettings.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__call__" href="../xinject/dependency.html#xinject.dependency.Dependency.__call__">__call__</a></code>
</p>
<div class="desc inherited"><p>This makes Resource subclasses have an ability to be used as function decorators
by default unless this method is overriden to provide some other …</p></div>
</dd>
<dt id="xmodel_rest.RestSettings.__copy__"><code class="name flex">
<span>def <span class="ident">__copy__</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xinject.dependency.Dependency" href="../xinject/dependency.html#xinject.dependency.Dependency">Dependency</a></code>.<code><a title="xinject.dependency.Dependency.__copy__" href="../xinject/dependency.html#xinject.dependency.Dependency.__copy__">__copy__</a></code>
</p>
<div class="desc inherited"><p>Basic shallow copy protection
(I am wondering if I should just remove this default copy code) …</p></div>
</dd>
<dt id="xmodel_rest.RestSettings.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self: ~T) ‑> ~T</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self: T) -&gt; T:
    return deepcopy(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel_rest.RestStructure"><code class="flex name class">
<span>class <span class="ident">RestStructure</span></span>
<span>(</span><span>*, parent: Optional[ForwardRef('RemoteStructure')], field_type: Type[~F])</span>
</code></dt>
<dd>
<div class="desc"><p>Rest version fo base <code>xynlib.orm.base.structure.BaseStructure</code> class.
Adds extra common attributes that are used by:</p>
<ul>
<li><code>xynlib.orm.rest.api.RestApi</code></li>
<li><code>xynlib.orm.rest.client.RestClient</code></li>
</ul>
<p>See <code><a title="xmodel_rest.RestStructure.configure_for_model_type" href="#xmodel_rest.RestStructure.configure_for_model_type">RestStructure.configure_for_model_type()</a></code> for class arguments specific to Rest models.</p>
<p>See <a href="../#basic-model-example">Basic BaseModel Example</a> for an example of what class arguments
are.</p>
<p>See parent <code>xynlib.orm.base.structure.BaseStructure</code> for more options that are common among all
model types (regardless if they are rest or dynamo).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestStructure(RemoteStructure[F]):
    &#34;&#34;&#34;
    Rest version fo base `xynlib.orm.base.structure.BaseStructure` class.
    Adds extra common attributes that are used by:

    - `xynlib.orm.rest.api.RestApi`
    - `xynlib.orm.rest.client.RestClient`

    See `RestStructure.configure_for_model_type` for class arguments specific to Rest models.

    See [Basic BaseModel Example](../#basic-model-example) for an example of what class arguments
    are.

    See parent `xynlib.orm.base.structure.BaseStructure` for more options that are common among all
    model types (regardless if they are rest or dynamo).
    &#34;&#34;&#34;

    def configure_for_model_type(
            self,
            *,
            # todo: consider a different name for `base_url`, the structure object calls this
            #  attribute the `endpoint_base_url` right now.
            base_url: URLStr = Default,
            urls: List[URLStr] = Default,
            multiple_results_json_path: str = Default,
            **kwargs
    ):
        &#34;&#34;&#34;

        Args:
            **kwargs: For other/base arguments, see super-class method
                `xynlib.orm.base.structure.BaseStructure`.

            base_url (xynlib.url.URLStr): This is appended to
                `xynlib.orm.rest.settings.RestSettings.api_url` as urls
                are constructed from `urls` passed in to determine if the URL is valid and should
                be used.

            urls (List[xynlib.url.URLStr]): List of URL&#39;s to traverse, in order.
                Generally speaking, the system will go though these URL&#39;s in order, the first valid
                URL that is found is the one that is selected. If you don&#39;t provide these then
                we use `DefaultModelURLs`.

                The `xynlib.url.URL.methods` are used to match up the operation, and then
                the URL is valid if it can be formatted with the avalaible information on
                the BaseModel or in URL query.

                Look at `xynlib.orm.rest.RestClient.url_for_endpoint` for more information about
                how the URL find/construction process takes place. This list eventually gets passed
                to the `xynlib.orm.rest.RestClient.url_for_endpoint` method.
                That method runs though this list and determines which URL to use.

                Look at `xynlib.url.URL.is_valid` for more information about how a URL is valid.

            multiple_results_json_path (str): Many API&#39;s have a key that is used to contain
                the results, specially if there are more than one of them.
                This allows for pagination and other meta data to be passed back in the response.
                The default value for this is `&#34;results&#34;`.
        &#34;&#34;&#34;
        super().configure_for_model_type(**kwargs)

        if multiple_results_json_path is not Default:
            self.multiple_results_json_path = multiple_results_json_path

        # Inherit from parent if Default.
        if base_url is not Default:
            self.base_model_url = base_url

        # We inherit the `urls` from parent if they are not provided directly by user.
        if urls is Default:
            if self.model_urls is None:
                self.model_urls = DefaultModelURLs
        else:
            self.model_urls = [*urls]

    multiple_results_json_path = &#34;results&#34;

    _base_model_url: URL = None

    @property
    def base_model_url(self) -&gt; URL:
        &#34;&#34;&#34;
        Used to store endpoint or the most common portion of all the endpoint urls.
        ie: &#39;point_events&#39;, or other such pieces of the URL.

        The endpoint is the part after the version and namespace in the context/base_path
        that client gets on init, eg: `/v1/presclub/{endpoint}`.

        Example:
          &#39;point_events&#39; could be returned, which could ultimately create this URL:
          /v1/presclub/point_events

          The `xynlib.orm.base.client.BaseClient` provides the version and namespace part of the
          `xynlib.url.URL`.
          So the proper RestClient combined with this endpoint method is how the URL is
          constructed.
        &#34;&#34;&#34;
        return self._base_model_url

    @base_model_url.setter
    def base_model_url(self, value: Union[URLStr, bool]):
        self._base_model_url = URL(value) if value else None

    _model_urls: Tuple[URL] = None

    @property
    def model_urls(self) -&gt; Tuple[URL]:
        &#34;&#34;&#34;
        If you need more than one endpoint url, use this. Every URL in this list will be appended
        to the `self.base_endpoint_url` when it&#39;s used.

        For more details on how the final url is found and constructed see
        `xynlib.orm.rest.RestClient.url_for_endpoint`.

        If you don&#39;t provide any endpoint_urls, then we will create a few standard ones
        automatically, such as &#34;/{id}&#34; (for getting a singular object via id).

        See `DefaultModelURLs` for the default list.

        When routing to the correct url, the first url that provides a valid path for the needed
        method + singular state will be used.  You can use path parameters, and order them to most
        specific to least specific, as we try to get a URL in the order they are defined.

        See:

        - `xynlib.url.URL`: for more details on how path formatting, methods, singular work.
        - `xynlib.orm.rest.RestClient.url_for_endpoint`: details on how final `xynlib.url.URL`
            is constructed.
        &#34;&#34;&#34;
        return self._model_urls

    @model_urls.setter
    def model_urls(self, value: Iterable[URLStr]):
        self._model_urls = tuple(URL.ensure_url(v).copy() for v in value) if value else None

    @property
    def have_api_endpoint(self) -&gt; bool:
        &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
            That&#39;s determined right now via seeing if we have any model_urls or not.

            .. todo:: Consider changing this to use
                `xynlib.orm.base.structure.BaseStructure.have_usable_id`
        &#34;&#34;&#34;
        return bool(self.model_urls)

    @property
    def endpoint_description(self):
        return self.base_model_url</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></li>
<li><a title="xmodel.base.structure.BaseStructure" href="../xmodel/base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.RestStructure.api_options"><code class="name">var <span class="ident">api_options</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.api_options" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure.api_options">api_options</a></code>
</p>
<div class="desc inherited"><p>When defined at class (in a subclass) level: …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.field_type"><code class="name">var <span class="ident">field_type</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.field_type" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.field_type">field_type</a></code>
</p>
<div class="desc inherited"><p>Field type that this structure will use when auto-generating <code>xmodel.fields.Field</code>'s.
User defined Fields on a model-class will keep whatever type the …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.internal_shared_api_values"><code class="name">var <span class="ident">internal_shared_api_values</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.internal_shared_api_values" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.internal_shared_api_values">internal_shared_api_values</a></code>
</p>
<div class="desc inherited"><p>A place an <code><a title="xmodel.base.api.BaseApi" href="../xmodel/base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> object can use to share values BaseModel-class wide
(ie: for all BaseModel's of a specific type) …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.max_query_by_id"><code class="name">var <span class="ident">max_query_by_id</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.max_query_by_id" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure.max_query_by_id">max_query_by_id</a></code>
</p>
<div class="desc inherited"><p>You can easily change this per-model via model class argument <code>max_query_by_id</code>
(see <code>RemoteStructure.configure_for_model_type</code> for more details) …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.model_cls"><code class="name">var <span class="ident">model_cls</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.model_cls" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.model_cls">model_cls</a></code>
</p>
<div class="desc inherited"><p>The model's class we are defining the structure for.
This is typed as some sort of <code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
.
This is NOT generically typed …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.multiple_results_json_path"><code class="name">var <span class="ident">multiple_results_json_path</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel_rest.RestStructure.base_model_url"><code class="name">var <span class="ident">base_model_url</span> : <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a></code></dt>
<dd>
<div class="desc"><p>Used to store endpoint or the most common portion of all the endpoint urls.
ie: 'point_events', or other such pieces of the URL.</p>
<p>The endpoint is the part after the version and namespace in the context/base_path
that client gets on init, eg: <code>/v1/presclub/{endpoint}</code>.</p>
<h2 id="example">Example</h2>
<p>'point_events' could be returned, which could ultimately create this URL:
/v1/presclub/point_events</p>
<p>The <code>xynlib.orm.base.client.BaseClient</code> provides the version and namespace part of the
<code>xynlib.url.URL</code>.
So the proper RestClient combined with this endpoint method is how the URL is
constructed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_model_url(self) -&gt; URL:
    &#34;&#34;&#34;
    Used to store endpoint or the most common portion of all the endpoint urls.
    ie: &#39;point_events&#39;, or other such pieces of the URL.

    The endpoint is the part after the version and namespace in the context/base_path
    that client gets on init, eg: `/v1/presclub/{endpoint}`.

    Example:
      &#39;point_events&#39; could be returned, which could ultimately create this URL:
      /v1/presclub/point_events

      The `xynlib.orm.base.client.BaseClient` provides the version and namespace part of the
      `xynlib.url.URL`.
      So the proper RestClient combined with this endpoint method is how the URL is
      constructed.
    &#34;&#34;&#34;
    return self._base_model_url</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestStructure.endpoint_description"><code class="name">var <span class="ident">endpoint_description</span></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.endpoint_description" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.endpoint_description">endpoint_description</a></code>
</p>
<div class="desc inherited"><p>Gives some sort of basic descriptive string that contains the path/table-name/etc
that basically indicates the api endpoint being used …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endpoint_description(self):
    return self.base_model_url</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestStructure.field_map"><code class="name">var <span class="ident">field_map</span> : Mapping[str, ~F]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.field_map" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.field_map">field_map</a></code>
</p>
<div class="desc inherited"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Map of <code>xmodel.fields.Field.name</code> to
<code>xmodel.fields.Field</code> objects.</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.RestStructure.fields"><code class="name">var <span class="ident">fields</span> : List[~F]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.fields" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.fields">fields</a></code>
</p>
<div class="desc inherited"><p>Returns:
List[xmodel.fields.Field]: list of field objects.</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.have_api_endpoint"><code class="name">var <span class="ident">have_api_endpoint</span> : bool</code></dt>
<dd>
<div class="desc"><p>Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
That's determined right now via seeing if we have any model_urls or not.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Consider changing this to use
<code>xynlib.orm.base.structure.BaseStructure.have_usable_id</code></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def have_api_endpoint(self) -&gt; bool:
    &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
        That&#39;s determined right now via seeing if we have any model_urls or not.

        .. todo:: Consider changing this to use
            `xynlib.orm.base.structure.BaseStructure.have_usable_id`
    &#34;&#34;&#34;
    return bool(self.model_urls)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestStructure.model_urls"><code class="name">var <span class="ident">model_urls</span> : Tuple[<a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>]</code></dt>
<dd>
<div class="desc"><p>If you need more than one endpoint url, use this. Every URL in this list will be appended
to the <code>self.base_endpoint_url</code> when it's used.</p>
<p>For more details on how the final url is found and constructed see
<code>xynlib.orm.rest.RestClient.url_for_endpoint</code>.</p>
<p>If you don't provide any endpoint_urls, then we will create a few standard ones
automatically, such as "/{id}" (for getting a singular object via id).</p>
<p>See <code>DefaultModelURLs</code> for the default list.</p>
<p>When routing to the correct url, the first url that provides a valid path for the needed
method + singular state will be used.
You can use path parameters, and order them to most
specific to least specific, as we try to get a URL in the order they are defined.</p>
<p>See:</p>
<ul>
<li><code>xynlib.url.URL</code>: for more details on how path formatting, methods, singular work.</li>
<li><code>xynlib.orm.rest.RestClient.url_for_endpoint</code>: details on how final <code>xynlib.url.URL</code>
is constructed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model_urls(self) -&gt; Tuple[URL]:
    &#34;&#34;&#34;
    If you need more than one endpoint url, use this. Every URL in this list will be appended
    to the `self.base_endpoint_url` when it&#39;s used.

    For more details on how the final url is found and constructed see
    `xynlib.orm.rest.RestClient.url_for_endpoint`.

    If you don&#39;t provide any endpoint_urls, then we will create a few standard ones
    automatically, such as &#34;/{id}&#34; (for getting a singular object via id).

    See `DefaultModelURLs` for the default list.

    When routing to the correct url, the first url that provides a valid path for the needed
    method + singular state will be used.  You can use path parameters, and order them to most
    specific to least specific, as we try to get a URL in the order they are defined.

    See:

    - `xynlib.url.URL`: for more details on how path formatting, methods, singular work.
    - `xynlib.orm.rest.RestClient.url_for_endpoint`: details on how final `xynlib.url.URL`
        is constructed.
    &#34;&#34;&#34;
    return self._model_urls</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.RestStructure.configure_for_model_type"><code class="name flex">
<span>def <span class="ident">configure_for_model_type</span></span>(<span>self, *, base_url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = Default, urls: List[Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None]] = Default, multiple_results_json_path: str = Default, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>For other/base arguments, see super-class method
<code>xynlib.orm.base.structure.BaseStructure</code>.</dd>
<dt><strong><code>base_url</code></strong> :&ensp;<code>xynlib.url.URLStr</code></dt>
<dd>This is appended to
<code>xynlib.orm.rest.settings.RestSettings.api_url</code> as urls
are constructed from <code>urls</code> passed in to determine if the URL is valid and should
be used.</dd>
<dt><strong><code>urls</code></strong> :&ensp;<code>List[xynlib.url.URLStr]</code></dt>
<dd>
<p>List of URL's to traverse, in order.
Generally speaking, the system will go though these URL's in order, the first valid
URL that is found is the one that is selected. If you don't provide these then
we use <code>DefaultModelURLs</code>.</p>
<p>The <code>xynlib.url.URL.methods</code> are used to match up the operation, and then
the URL is valid if it can be formatted with the avalaible information on
the BaseModel or in URL query.</p>
<p>Look at <code>xynlib.orm.rest.RestClient.url_for_endpoint</code> for more information about
how the URL find/construction process takes place. This list eventually gets passed
to the <code>xynlib.orm.rest.RestClient.url_for_endpoint</code> method.
That method runs though this list and determines which URL to use.</p>
<p>Look at <code>xynlib.url.URL.is_valid</code> for more information about how a URL is valid.</p>
</dd>
<dt><strong><code>multiple_results_json_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Many API's have a key that is used to contain
the results, specially if there are more than one of them.
This allows for pagination and other meta data to be passed back in the response.
The default value for this is <code>"results"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_for_model_type(
        self,
        *,
        # todo: consider a different name for `base_url`, the structure object calls this
        #  attribute the `endpoint_base_url` right now.
        base_url: URLStr = Default,
        urls: List[URLStr] = Default,
        multiple_results_json_path: str = Default,
        **kwargs
):
    &#34;&#34;&#34;

    Args:
        **kwargs: For other/base arguments, see super-class method
            `xynlib.orm.base.structure.BaseStructure`.

        base_url (xynlib.url.URLStr): This is appended to
            `xynlib.orm.rest.settings.RestSettings.api_url` as urls
            are constructed from `urls` passed in to determine if the URL is valid and should
            be used.

        urls (List[xynlib.url.URLStr]): List of URL&#39;s to traverse, in order.
            Generally speaking, the system will go though these URL&#39;s in order, the first valid
            URL that is found is the one that is selected. If you don&#39;t provide these then
            we use `DefaultModelURLs`.

            The `xynlib.url.URL.methods` are used to match up the operation, and then
            the URL is valid if it can be formatted with the avalaible information on
            the BaseModel or in URL query.

            Look at `xynlib.orm.rest.RestClient.url_for_endpoint` for more information about
            how the URL find/construction process takes place. This list eventually gets passed
            to the `xynlib.orm.rest.RestClient.url_for_endpoint` method.
            That method runs though this list and determines which URL to use.

            Look at `xynlib.url.URL.is_valid` for more information about how a URL is valid.

        multiple_results_json_path (str): Many API&#39;s have a key that is used to contain
            the results, specially if there are more than one of them.
            This allows for pagination and other meta data to be passed back in the response.
            The default value for this is `&#34;results&#34;`.
    &#34;&#34;&#34;
    super().configure_for_model_type(**kwargs)

    if multiple_results_json_path is not Default:
        self.multiple_results_json_path = multiple_results_json_path

    # Inherit from parent if Default.
    if base_url is not Default:
        self.base_model_url = base_url

    # We inherit the `urls` from parent if they are not provided directly by user.
    if urls is Default:
        if self.model_urls is None:
            self.model_urls = DefaultModelURLs
    else:
        self.model_urls = [*urls]</code></pre>
</details>
</dd>
<dt id="xmodel_rest.RestStructure.excluded_field_map"><code class="name flex">
<span>def <span class="ident">excluded_field_map</span></span>(<span>self) ‑> Dict[str, ~F]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.excluded_field_map" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.excluded_field_map">excluded_field_map</a></code>
</p>
<div class="desc inherited"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Mapping of <code>xmodel.fields.Field.name</code> to
field objects that are excluded …</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.RestStructure.field_exists"><code class="name flex">
<span>def <span class="ident">field_exists</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.field_exists" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.field_exists">field_exists</a></code>
</p>
<div class="desc inherited"><p>Return <code>True</code> if the field with <code>name</code> exists on the model, otherwise <code>False</code>.</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, name: str) ‑> Optional[~F]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.get_field" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.get_field">get_field</a></code>
</p>
<div class="desc inherited"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Field name to query on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xmodel.fields.Field</code></dt>
<dd>If field object exists with <code>name</code> …</dd>
</dl></div>
</dd>
<dt id="xmodel_rest.RestStructure.get_unwraped_typehint"><code class="name flex">
<span>def <span class="ident">get_unwraped_typehint</span></span>(<span>self, field_name: str)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.get_unwraped_typehint" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.get_unwraped_typehint">get_unwraped_typehint</a></code>
</p>
<div class="desc inherited"><p>This is now done for you on <code>xmodel.fields.Field.type_hint</code>, so you can just grab it
directly your self now …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.has_id_field"><code class="name flex">
<span>def <span class="ident">has_id_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.has_id_field" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure.has_id_field">has_id_field</a></code>
</p>
<div class="desc inherited"><p>Defaults to False, returns True for RemoteStructure,
What this property is really saying is if you can do a foreign-key to the related
object/model …</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.id_cache_key"><code class="name flex">
<span>def <span class="ident">id_cache_key</span></span>(<span>self, _id)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.id_cache_key" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.id_cache_key">id_cache_key</a></code>
</p>
<div class="desc inherited"><p>Returns a proper key to use for <code>xmodel.base.client.BaseClient.cache_get</code>
and other caching methods for id-based lookup of an object.</p></div>
</dd>
<dt id="xmodel_rest.RestStructure.is_field_a_child"><code class="name flex">
<span>def <span class="ident">is_field_a_child</span></span>(<span>self, child_field_name, *, and_has_id=False)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.structure.RemoteStructure" href="../xmodel/remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></code>.<code><a title="xmodel.remote.structure.RemoteStructure.is_field_a_child" href="../xmodel/base/structure.html#xmodel.remote.structure.RemoteStructure.is_field_a_child">is_field_a_child</a></code>
</p>
<div class="desc inherited"><p>True if the field is a child, otherwise False.
Will still return <code>False</code> if
<code>and_has_id</code> argument is <code>True</code> and the related type is configured to not …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#rest-specificrelate-classes">Rest Specific/Relate Classes</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="xmodel_rest.api" href="api.html">xmodel_rest.api</a></code></li>
<li><code><a title="xmodel_rest.auth" href="auth.html">xmodel_rest.auth</a></code></li>
<li><code><a title="xmodel_rest.client" href="client.html">xmodel_rest.client</a></code></li>
<li><code><a title="xmodel_rest.default_model_urls" href="default_model_urls.html">xmodel_rest.default_model_urls</a></code></li>
<li><code><a title="xmodel_rest.errors" href="errors.html">xmodel_rest.errors</a></code></li>
<li><code><a title="xmodel_rest.model" href="model.html">xmodel_rest.model</a></code></li>
<li><code><a title="xmodel_rest.session" href="session.html">xmodel_rest.session</a></code></li>
<li><code><a title="xmodel_rest.settings" href="settings.html">xmodel_rest.settings</a></code></li>
<li><code><a title="xmodel_rest.structure" href="structure.html">xmodel_rest.structure</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel_rest.RestApi" href="#xmodel_rest.RestApi">RestApi</a></code></h4>
<ul class="">
<li><code><a title="xmodel_rest.RestApi.auth" href="#xmodel_rest.RestApi.auth">auth</a></code></li>
<li><code><a title="xmodel_rest.RestApi.client" href="#xmodel_rest.RestApi.client">client</a></code></li>
<li><code><a title="xmodel_rest.RestApi.context" href="../xmodel/base/api.html#xmodel_rest.RestApi.context">context</a></code></li>
<li><code><a title="xmodel_rest.RestApi.default_converters" href="../xmodel/base/api.html#xmodel_rest.RestApi.default_converters">default_converters</a></code></li>
<li><code><a title="xmodel_rest.RestApi.delete" href="../xmodel/remote/api.html#xmodel_rest.RestApi.delete">delete</a></code></li>
<li><code><a title="xmodel_rest.RestApi.did_send" href="../xmodel/remote/api.html#xmodel_rest.RestApi.did_send">did_send</a></code></li>
<li><code><a title="xmodel_rest.RestApi.fields_to_pop_for_json" href="../xmodel/base/api.html#xmodel_rest.RestApi.fields_to_pop_for_json">fields_to_pop_for_json</a></code></li>
<li><code><a title="xmodel_rest.RestApi.forget_original_json_state" href="../xmodel/base/api.html#xmodel_rest.RestApi.forget_original_json_state">forget_original_json_state</a></code></li>
<li><code><a title="xmodel_rest.RestApi.get" href="../xmodel/remote/api.html#xmodel_rest.RestApi.get">get</a></code></li>
<li><code><a title="xmodel_rest.RestApi.get_child_without_lazy_lookup" href="../xmodel/base/api.html#xmodel_rest.RestApi.get_child_without_lazy_lookup">get_child_without_lazy_lookup</a></code></li>
<li><code><a title="xmodel_rest.RestApi.get_via_id" href="../xmodel/remote/api.html#xmodel_rest.RestApi.get_via_id">get_via_id</a></code></li>
<li><code><a title="xmodel_rest.RestApi.have_changes" href="../xmodel/base/api.html#xmodel_rest.RestApi.have_changes">have_changes</a></code></li>
<li><code><a title="xmodel_rest.RestApi.json" href="../xmodel/remote/api.html#xmodel_rest.RestApi.json">json</a></code></li>
<li><code><a title="xmodel_rest.RestApi.list_of_attrs_to_repr" href="../xmodel/remote/api.html#xmodel_rest.RestApi.list_of_attrs_to_repr">list_of_attrs_to_repr</a></code></li>
<li><code><a title="xmodel_rest.RestApi.model" href="#xmodel_rest.RestApi.model">model</a></code></li>
<li><code><a title="xmodel_rest.RestApi.model_type" href="../xmodel/base/api.html#xmodel_rest.RestApi.model_type">model_type</a></code></li>
<li><code><a title="xmodel_rest.RestApi.option_all_for_name" href="../xmodel/remote/api.html#xmodel_rest.RestApi.option_all_for_name">option_all_for_name</a></code></li>
<li><code><a title="xmodel_rest.RestApi.option_for_name" href="../xmodel/remote/api.html#xmodel_rest.RestApi.option_for_name">option_for_name</a></code></li>
<li><code><a title="xmodel_rest.RestApi.options" href="../xmodel/remote/api.html#xmodel_rest.RestApi.options">options</a></code></li>
<li><code><a title="xmodel_rest.RestApi.response_state" href="../xmodel/remote/api.html#xmodel_rest.RestApi.response_state">response_state</a></code></li>
<li><code><a title="xmodel_rest.RestApi.send" href="#xmodel_rest.RestApi.send">send</a></code></li>
<li><code><a title="xmodel_rest.RestApi.settings" href="#xmodel_rest.RestApi.settings">settings</a></code></li>
<li><code><a title="xmodel_rest.RestApi.should_include_field_in_json" href="../xmodel/base/api.html#xmodel_rest.RestApi.should_include_field_in_json">should_include_field_in_json</a></code></li>
<li><code><a title="xmodel_rest.RestApi.structure" href="#xmodel_rest.RestApi.structure">structure</a></code></li>
<li><code><a title="xmodel_rest.RestApi.update_from_json" href="../xmodel/remote/api.html#xmodel_rest.RestApi.update_from_json">update_from_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel_rest.RestAuth" href="#xmodel_rest.RestAuth">RestAuth</a></code></h4>
<ul class="two-column">
<li><code><a title="xmodel_rest.RestAuth.__call__" href="../xinject/dependency.html#xmodel_rest.RestAuth.__call__">__call__</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.__copy__" href="../xinject/dependency.html#xmodel_rest.RestAuth.__copy__">__copy__</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.__init_subclass__" href="../xinject/dependency.html#xmodel_rest.RestAuth.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.grab" href="../xinject/dependency.html#xmodel_rest.RestAuth.grab">grab</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.obj" href="#xmodel_rest.RestAuth.obj">obj</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.proxy" href="../xinject/dependency.html#xmodel_rest.RestAuth.proxy">proxy</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.proxy_attribute" href="../xinject/dependency.html#xmodel_rest.RestAuth.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.refresh_token" href="#xmodel_rest.RestAuth.refresh_token">refresh_token</a></code></li>
<li><code><a title="xmodel_rest.RestAuth.requests_callable" href="#xmodel_rest.RestAuth.requests_callable">requests_callable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel_rest.RestClient" href="#xmodel_rest.RestClient">RestClient</a></code></h4>
<ul class="">
<li><code><a title="xmodel_rest.RestClient.api" href="#xmodel_rest.RestClient.api">api</a></code></li>
<li><code><a title="xmodel_rest.RestClient.auth" href="#xmodel_rest.RestClient.auth">auth</a></code></li>
<li><code><a title="xmodel_rest.RestClient.base_api_url" href="#xmodel_rest.RestClient.base_api_url">base_api_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.base_endpoint_url" href="#xmodel_rest.RestClient.base_endpoint_url">base_endpoint_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.cache_get" href="../xmodel/remote/client.html#xmodel_rest.RestClient.cache_get">cache_get</a></code></li>
<li><code><a title="xmodel_rest.RestClient.cache_remove" href="../xmodel/remote/client.html#xmodel_rest.RestClient.cache_remove">cache_remove</a></code></li>
<li><code><a title="xmodel_rest.RestClient.cache_set" href="../xmodel/remote/client.html#xmodel_rest.RestClient.cache_set">cache_set</a></code></li>
<li><code><a title="xmodel_rest.RestClient.cache_weak_get" href="../xmodel/remote/client.html#xmodel_rest.RestClient.cache_weak_get">cache_weak_get</a></code></li>
<li><code><a title="xmodel_rest.RestClient.cache_weak_set" href="../xmodel/remote/client.html#xmodel_rest.RestClient.cache_weak_set">cache_weak_set</a></code></li>
<li><code><a title="xmodel_rest.RestClient.clear_caches" href="../xmodel/remote/client.html#xmodel_rest.RestClient.clear_caches">clear_caches</a></code></li>
<li><code><a title="xmodel_rest.RestClient.default_send_batch_size" href="#xmodel_rest.RestClient.default_send_batch_size">default_send_batch_size</a></code></li>
<li><code><a title="xmodel_rest.RestClient.delete_obj" href="#xmodel_rest.RestClient.delete_obj">delete_obj</a></code></li>
<li><code><a title="xmodel_rest.RestClient.delete_objs" href="#xmodel_rest.RestClient.delete_objs">delete_objs</a></code></li>
<li><code><a title="xmodel_rest.RestClient.enable_send_changes_only" href="#xmodel_rest.RestClient.enable_send_changes_only">enable_send_changes_only</a></code></li>
<li><code><a title="xmodel_rest.RestClient.format_body_for_delete" href="#xmodel_rest.RestClient.format_body_for_delete">format_body_for_delete</a></code></li>
<li><code><a title="xmodel_rest.RestClient.format_body_for_get" href="#xmodel_rest.RestClient.format_body_for_get">format_body_for_get</a></code></li>
<li><code><a title="xmodel_rest.RestClient.format_body_for_send" href="#xmodel_rest.RestClient.format_body_for_send">format_body_for_send</a></code></li>
<li><code><a title="xmodel_rest.RestClient.get" href="#xmodel_rest.RestClient.get">get</a></code></li>
<li><code><a title="xmodel_rest.RestClient.get_url" href="#xmodel_rest.RestClient.get_url">get_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.method_status_to_raise_by_default" href="#xmodel_rest.RestClient.method_status_to_raise_by_default">method_status_to_raise_by_default</a></code></li>
<li><code><a title="xmodel_rest.RestClient.parse_errors_from_send_response" href="#xmodel_rest.RestClient.parse_errors_from_send_response">parse_errors_from_send_response</a></code></li>
<li><code><a title="xmodel_rest.RestClient.parse_json_from_get_response" href="#xmodel_rest.RestClient.parse_json_from_get_response">parse_json_from_get_response</a></code></li>
<li><code><a title="xmodel_rest.RestClient.root_read_url" href="#xmodel_rest.RestClient.root_read_url">root_read_url</a></code></li>
<li><code><a title="xmodel_rest.RestClient.send_objs" href="#xmodel_rest.RestClient.send_objs">send_objs</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_delete" href="#xmodel_rest.RestClient.url_for_delete">url_for_delete</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_endpoint" href="#xmodel_rest.RestClient.url_for_endpoint">url_for_endpoint</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_next_page" href="#xmodel_rest.RestClient.url_for_next_page">url_for_next_page</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_read" href="#xmodel_rest.RestClient.url_for_read">url_for_read</a></code></li>
<li><code><a title="xmodel_rest.RestClient.url_for_send" href="#xmodel_rest.RestClient.url_for_send">url_for_send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel_rest.RestModel" href="#xmodel_rest.RestModel">RestModel</a></code></h4>
<ul class="">
<li><code><a title="xmodel_rest.RestModel.__init_subclass__" href="../xmodel/base/model.html#xmodel_rest.RestModel.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xmodel_rest.RestModel.api" href="#xmodel_rest.RestModel.api">api</a></code></li>
<li><code><a title="xmodel_rest.RestModel.id" href="../xmodel/remote/model.html#xmodel_rest.RestModel.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel_rest.RestSettings" href="#xmodel_rest.RestSettings">RestSettings</a></code></h4>
<ul class="two-column">
<li><code><a title="xmodel_rest.RestSettings.__call__" href="../xinject/dependency.html#xmodel_rest.RestSettings.__call__">__call__</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.__copy__" href="../xinject/dependency.html#xmodel_rest.RestSettings.__copy__">__copy__</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.__init_subclass__" href="../xinject/dependency.html#xmodel_rest.RestSettings.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.api_url" href="#xmodel_rest.RestSettings.api_url">api_url</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.base_api_url" href="#xmodel_rest.RestSettings.base_api_url">base_api_url</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.copy" href="#xmodel_rest.RestSettings.copy">copy</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.grab" href="../xinject/dependency.html#xmodel_rest.RestSettings.grab">grab</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.obj" href="../xinject/dependency.html#xmodel_rest.RestSettings.obj">obj</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.proxy" href="../xinject/dependency.html#xmodel_rest.RestSettings.proxy">proxy</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.proxy_attribute" href="../xinject/dependency.html#xmodel_rest.RestSettings.proxy_attribute">proxy_attribute</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.retry_requests" href="#xmodel_rest.RestSettings.retry_requests">retry_requests</a></code></li>
<li><code><a title="xmodel_rest.RestSettings.root_url" href="#xmodel_rest.RestSettings.root_url">root_url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel_rest.RestStructure" href="#xmodel_rest.RestStructure">RestStructure</a></code></h4>
<ul class="">
<li><code><a title="xmodel_rest.RestStructure.api_options" href="../xmodel/remote/structure.html#xmodel_rest.RestStructure.api_options">api_options</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.base_model_url" href="#xmodel_rest.RestStructure.base_model_url">base_model_url</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.configure_for_model_type" href="#xmodel_rest.RestStructure.configure_for_model_type">configure_for_model_type</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.endpoint_description" href="#xmodel_rest.RestStructure.endpoint_description">endpoint_description</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.excluded_field_map" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.excluded_field_map">excluded_field_map</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.field_exists" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.field_exists">field_exists</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.field_map" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.field_map">field_map</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.field_type" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.field_type">field_type</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.fields" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.fields">fields</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.get_field" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.get_field">get_field</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.get_unwraped_typehint" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.get_unwraped_typehint">get_unwraped_typehint</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.has_id_field" href="../xmodel/remote/structure.html#xmodel_rest.RestStructure.has_id_field">has_id_field</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.have_api_endpoint" href="#xmodel_rest.RestStructure.have_api_endpoint">have_api_endpoint</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.id_cache_key" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.id_cache_key">id_cache_key</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.internal_shared_api_values" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.internal_shared_api_values">internal_shared_api_values</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.is_field_a_child" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.is_field_a_child">is_field_a_child</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.max_query_by_id" href="../xmodel/remote/structure.html#xmodel_rest.RestStructure.max_query_by_id">max_query_by_id</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.model_cls" href="../xmodel/base/structure.html#xmodel_rest.RestStructure.model_cls">model_cls</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.model_urls" href="#xmodel_rest.RestStructure.model_urls">model_urls</a></code></li>
<li><code><a title="xmodel_rest.RestStructure.multiple_results_json_path" href="#xmodel_rest.RestStructure.multiple_results_json_path">multiple_results_json_path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>