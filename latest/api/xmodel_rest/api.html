<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel_rest.api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xmodel_rest.api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from xinject import XContext
from .client import RestClient
from .errors import XynRestError
from .settings import RestSettings
from xmodel.remote import RemoteApi, RemoteModel
from typing import TypeVar, List, Tuple, Iterable, Union, Type, get_type_hints, TYPE_CHECKING
from logging import getLogger
from xurls.url import URLStr
from xmodel import Field
from abc import ABC
from .structure import RestStructure
from .auth import RestAuth
from xsentinels import Default
from xurls.url import HTTPGet, HTTPPatch, HTTPDelete, URL
from .auth import RestAuth
from .auth import RestAuth
from typing import TypeVar
from .model import RestModel


# It&#39;s really bound to `RestModel`, but I need an easier way to tie into lazy-loading
# BaseModel.__init_subclass__ system, so I can lazy-load my own stuff first before it does.
# Decided it was an exercise for future day. We can live with it for now.
M = TypeVar(&#34;M&#34;, bound=RemoteModel)


class RestApi(RemoteApi[M]):
    &#34;&#34;&#34; Base `xynlib.orm.base.api.BaseApi` subclass generally used by Rest API&#39;s.

        Things specific and common to rest api&#39;s should go in this class.

        See parent `xynlib.orm.base.api.BaseApi` for things in common among all API&#39;s.
    &#34;&#34;&#34;

    # Telling system about the default/base rest types we want to use with `RestApi`.
    client: RestClient[M]
    structure: RestStructure[Field]
    auth: RestAuth
    settings: RestSettings

    # todo: decide if we should just remove the below, not strictly needed, more of a convenience.
    #
    # Only used for IDE so it knows what type should be here, not used to know which Model to
    # allocate object.
    # This is because RestModel will tell/pass this into RestApi via `__init__`,
    # it happens when a RestModel/BaseModel is created (in BaseModel.__init__).
    model: RestModel[M]

    def send(self, url: URLStr = None):
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        Convenience method to send this single object to API, it simply calls
        `xynlib.orm.base.client.Client.send_objs` with a single object in the list
        (via `xynlib.orm.base.api.BaseApi.model`).

        If you want to send multiple objects, call `xynlib.orm.base.client.Client.send_objs`.

        Example is below, it uses a made-up rest model called &#39;SomeRestModelSubclass&#39;.

        (I did not provide all details it would need to use the made-up/imagained rest-api;
        trying to illisrate a basic point here is all.
        If you want more details on how to make a real full/valid rest-model subclass
        see #INSERT-README-LINK#.)

        &gt;&gt;&gt; from xmodel_rest import RestModel
        &gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&#34;....etc....&#34;):
        ...     pass  # Some attributes from the rest-api go here
        &gt;&gt;&gt; obj1 = SomeRestModelSubclass()
        &gt;&gt;&gt; obj2 = SomeRestModelSubclass()
        &gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])

        If you pass in a `url` paramater to the `send_objs` method, the url gets appended to the
        final constructed url before the url gets validated.

        If the url is validated, it will use that final url [with passed in `url` this appended].
        For more information about how URL&#39;s are appended to each-other see:
        `xurls.url.URLMutable.append_url`.

        The response from API will update all the values on this object with the results
        of the change [all fields will be updated] and with the latest values from API.

        You can check for errors on model object via `xmodel.remote.api.response_state`, ie:

        &gt;&gt;&gt; from xynlib.orm import BaseModel
        &gt;&gt;&gt; obj: BaseModel
        &gt;&gt;&gt; # Check response_state to see if it had an error:
        &gt;&gt;&gt; obj.api.response_state.had_error
        False
        &#34;&#34;&#34;
        # Redirect to client.send_objs:
        self.client.send_objs([self.model], url=url)

    # This is a resource-type, see `def auth()` doc-comment below for more details.
    # Subclasses can override this type-hint, and `RestApi` will allocate the new
    # type instead automatically, on demand.
    #
    # The type-hints inform this class what type of objects to create when `auth` along
    # with other special attributes such as `client` and `structure` are needed/asked-for.
    #
    # You can override the type by making your own type-hint on a sub-class.
    # See xmodel.base.api.BaseApi and xmodel.remote.api.RemoteApi for its various special
    # type-hinted attributes for more details, it has more detailed comments/documentation on it.
    auth: RestAuth

    @property
    def _auth(self):
        &#34;&#34;&#34;
        Treated a `xyn_resaource.context.Resource`, a context resource for the purposes of sharing
        auth credentials. The type-hint assoicated with `auth: XYZ` will be used to grab
        a resource of that type from the current context each time we are asked.

        Thus resource is the auth object used by your `xmodel.base.client.BaseClient` subclass,
        (such as `xynlib.orm.rest.RestClient`),
        to set what type should be used for this, in your BaseClient sub-class, make a type-hint
        like below.

        Let&#39;s say you have an auth class you want to use:

        &gt;&gt;&gt; import xmodel.base.auth
        &gt;&gt;&gt; import xmodel
        &gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
        ...     pass

        You can set a type-hint for it like so, and it will be automatiaclly used when needed:

        &gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
        ...     auth: MyCoolAuthClass

        Doing that is enough, `xynlib.orm.rest.RestClient` class will see the type-hint and will
        grab one of that type from the XContext and return it.
        In the example above, it would be a `MyCoolAuthClass` type.

        The type-hint is lazily cached in self for fast lookup in the future.

        To see details on what the Auth object should do,
        see `xmodel.base.auth.BaseAuth`.
        &#34;&#34;&#34;

        auth_type: Type[RestAuth] = self._auth_type
        if not auth_type:
            # Will get all type-hints, and ensure they are valid type refrences
            # (otherwise will error out)
            auth_type = get_type_hints(type(self)).get(&#39;auth&#39;, RestAuth)
            self._auth_type = auth_type

        # Auth has tokens we want to try and share, treat it as a resource.
        return auth_type.grab()

    _settings_type: Type[RestSettings] = None

    @property
    def _settings(self):
        &#34;&#34;&#34; The config object that this api uses, can be customized per-model. All you have to
            do is this to make it a different type:

            &gt;&gt;&gt; import xmodel
            &gt;&gt;&gt;
            &gt;&gt;&gt; class MySettings(BaseSettings):
            ...     my_custom_var: str = xmodel.ConfigVar(
            ...         &#34;MY_CUSTOM_ENVIRONMENTAL_VAR&#34;,
            ...         &#34;default&#34;
            ...     )
            &gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
            ...     settings: MySettings
            &gt;&gt;&gt; class MyModel(xmodel.model.BaseModel[&#39;MyModel&#39;]):
            ...     api: MyApi

            The type-hints are enough to tell the system what types to use. They also will
            tell any IDE in use about what type it should be, for type-completion.
            So it&#39;s sort of doing double-duty!
        &#34;&#34;&#34;
        config_type = self._settings_type
        if not config_type:
            config_type = get_type_hints(type(self)).get(&#39;settings&#39;, None)
            self._settings_type = config_type  # Cache config-type.
            if config_type is None:
                raise XynRestError(
                    f&#34;BaseClient subclass type is undefined for model class ({self.model_type}), &#34;
                    f&#34;a type-hint for &#39;client&#39; on BaseApi class must be in place for me to know &#34;
                    f&#34;what type to get.&#34;
                )

        return XContext.current(for_type=config_type)

    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. This gets around it since pycharm
    # can&#39;t figure out what&#39;s going on here.
    auth = _auth
    settings = _settings</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel_rest.api.RestApi"><code class="flex name class">
<span>class <span class="ident">RestApi</span></span>
<span>(</span><span>*, api: BaseApi[M] = None, model: <a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base <code>xynlib.orm.base.api.BaseApi</code> subclass generally used by Rest API's.</p>
<p>Things specific and common to rest api's should go in this class.</p>
<p>See parent <code>xynlib.orm.base.api.BaseApi</code> for things in common among all API's.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;You can probably skip the rest (below)</p>
<p>Most of the time you don't create <code>BaseApi</code> objects your self, and so for most people
you can skip the following unless you want to know more about internal details.</p>
</div>
<h1 id="init-method-specifics">Init Method Specifics</h1>
<p>Normally you would not create an <code>BaseApi</code> object directly your self.
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s know how to do this automatically.
It happens in <code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="../xmodel/base/model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code>.</p>
<p>Details about how the arguments you can pass are below.</p>
<h2 id="basemodel-class-construction">BaseModel Class Construction:</h2>
<p>If you provide an <code>api</code> arg without a <code>model</code> arg; we will copy the <code>BaseApi.structure</code>
into new object, resetting the error status, and internal <code>BaseApi._state</code> to None.
This <code>api</code> object is supposed to be the parent BaseModel's class api object.</p>
<p>If both <code>api</code> arg + <code>model</code> arg are <code>None</code>, the BaseModel is the root/generic BaseModel
(ie: it has no parent BaseModel).</p>
<p>This is what is done by BaseModel classes while the class is lazily loading and
creating/configuring the BaseModel class and it's associated <code>BaseApi</code> object
(accessible via <code><a title="xmodel.base.model.BaseModel.api" href="../xmodel/base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>)</p>
<h2 id="basemodel-instance-creation">BaseModel Instance Creation:</h2>
<p>If you also pass in a <code>model</code> arg; this get you a special copy of the api you passed in
for use just with that BaseModel instance. The model <code>BaseApi._state</code> will be allocated
internally in the init'd BaseApi object. This is how a <code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance get's it's own associated <code>BaseApi</code> object
(that's a different instance vs the one set on BaseModel class when the BaseModel class
was originally constructed).</p>
<p>All params are optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>
<p>The "parent" BaseApi obj to copy the basic structure from as a starting point,
etc.
The superclasses BaseApi class is passed via this arg.
This is only used when allocating a new <code>BaseApi</code> object for a new
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> class (not an instance, a model class/type).
This BaseApi object is used for the class-level BaseModel api object;
ie: via "ModelClass.api"</p>
<p>See above "BaseModel Class Construction" for more details.</p>
</dd>
<dt><strong><code>model</code></strong></dt>
<dd>
<p>BaseModel to associate new BaseApi obj with.
This is only used to create a new BaseApi object for a
<code><a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance for an already-existing type. ie: for BaseModel object instances.</p>
<p>See above "BaseModel Instance Creation" for more details.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RestApi(RemoteApi[M]):
    &#34;&#34;&#34; Base `xynlib.orm.base.api.BaseApi` subclass generally used by Rest API&#39;s.

        Things specific and common to rest api&#39;s should go in this class.

        See parent `xynlib.orm.base.api.BaseApi` for things in common among all API&#39;s.
    &#34;&#34;&#34;

    # Telling system about the default/base rest types we want to use with `RestApi`.
    client: RestClient[M]
    structure: RestStructure[Field]
    auth: RestAuth
    settings: RestSettings

    # todo: decide if we should just remove the below, not strictly needed, more of a convenience.
    #
    # Only used for IDE so it knows what type should be here, not used to know which Model to
    # allocate object.
    # This is because RestModel will tell/pass this into RestApi via `__init__`,
    # it happens when a RestModel/BaseModel is created (in BaseModel.__init__).
    model: RestModel[M]

    def send(self, url: URLStr = None):
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        Convenience method to send this single object to API, it simply calls
        `xynlib.orm.base.client.Client.send_objs` with a single object in the list
        (via `xynlib.orm.base.api.BaseApi.model`).

        If you want to send multiple objects, call `xynlib.orm.base.client.Client.send_objs`.

        Example is below, it uses a made-up rest model called &#39;SomeRestModelSubclass&#39;.

        (I did not provide all details it would need to use the made-up/imagained rest-api;
        trying to illisrate a basic point here is all.
        If you want more details on how to make a real full/valid rest-model subclass
        see #INSERT-README-LINK#.)

        &gt;&gt;&gt; from xmodel_rest import RestModel
        &gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&#34;....etc....&#34;):
        ...     pass  # Some attributes from the rest-api go here
        &gt;&gt;&gt; obj1 = SomeRestModelSubclass()
        &gt;&gt;&gt; obj2 = SomeRestModelSubclass()
        &gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])

        If you pass in a `url` paramater to the `send_objs` method, the url gets appended to the
        final constructed url before the url gets validated.

        If the url is validated, it will use that final url [with passed in `url` this appended].
        For more information about how URL&#39;s are appended to each-other see:
        `xurls.url.URLMutable.append_url`.

        The response from API will update all the values on this object with the results
        of the change [all fields will be updated] and with the latest values from API.

        You can check for errors on model object via `xmodel.remote.api.response_state`, ie:

        &gt;&gt;&gt; from xynlib.orm import BaseModel
        &gt;&gt;&gt; obj: BaseModel
        &gt;&gt;&gt; # Check response_state to see if it had an error:
        &gt;&gt;&gt; obj.api.response_state.had_error
        False
        &#34;&#34;&#34;
        # Redirect to client.send_objs:
        self.client.send_objs([self.model], url=url)

    # This is a resource-type, see `def auth()` doc-comment below for more details.
    # Subclasses can override this type-hint, and `RestApi` will allocate the new
    # type instead automatically, on demand.
    #
    # The type-hints inform this class what type of objects to create when `auth` along
    # with other special attributes such as `client` and `structure` are needed/asked-for.
    #
    # You can override the type by making your own type-hint on a sub-class.
    # See xmodel.base.api.BaseApi and xmodel.remote.api.RemoteApi for its various special
    # type-hinted attributes for more details, it has more detailed comments/documentation on it.
    auth: RestAuth

    @property
    def _auth(self):
        &#34;&#34;&#34;
        Treated a `xyn_resaource.context.Resource`, a context resource for the purposes of sharing
        auth credentials. The type-hint assoicated with `auth: XYZ` will be used to grab
        a resource of that type from the current context each time we are asked.

        Thus resource is the auth object used by your `xmodel.base.client.BaseClient` subclass,
        (such as `xynlib.orm.rest.RestClient`),
        to set what type should be used for this, in your BaseClient sub-class, make a type-hint
        like below.

        Let&#39;s say you have an auth class you want to use:

        &gt;&gt;&gt; import xmodel.base.auth
        &gt;&gt;&gt; import xmodel
        &gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
        ...     pass

        You can set a type-hint for it like so, and it will be automatiaclly used when needed:

        &gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
        ...     auth: MyCoolAuthClass

        Doing that is enough, `xynlib.orm.rest.RestClient` class will see the type-hint and will
        grab one of that type from the XContext and return it.
        In the example above, it would be a `MyCoolAuthClass` type.

        The type-hint is lazily cached in self for fast lookup in the future.

        To see details on what the Auth object should do,
        see `xmodel.base.auth.BaseAuth`.
        &#34;&#34;&#34;

        auth_type: Type[RestAuth] = self._auth_type
        if not auth_type:
            # Will get all type-hints, and ensure they are valid type refrences
            # (otherwise will error out)
            auth_type = get_type_hints(type(self)).get(&#39;auth&#39;, RestAuth)
            self._auth_type = auth_type

        # Auth has tokens we want to try and share, treat it as a resource.
        return auth_type.grab()

    _settings_type: Type[RestSettings] = None

    @property
    def _settings(self):
        &#34;&#34;&#34; The config object that this api uses, can be customized per-model. All you have to
            do is this to make it a different type:

            &gt;&gt;&gt; import xmodel
            &gt;&gt;&gt;
            &gt;&gt;&gt; class MySettings(BaseSettings):
            ...     my_custom_var: str = xmodel.ConfigVar(
            ...         &#34;MY_CUSTOM_ENVIRONMENTAL_VAR&#34;,
            ...         &#34;default&#34;
            ...     )
            &gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
            ...     settings: MySettings
            &gt;&gt;&gt; class MyModel(xmodel.model.BaseModel[&#39;MyModel&#39;]):
            ...     api: MyApi

            The type-hints are enough to tell the system what types to use. They also will
            tell any IDE in use about what type it should be, for type-completion.
            So it&#39;s sort of doing double-duty!
        &#34;&#34;&#34;
        config_type = self._settings_type
        if not config_type:
            config_type = get_type_hints(type(self)).get(&#39;settings&#39;, None)
            self._settings_type = config_type  # Cache config-type.
            if config_type is None:
                raise XynRestError(
                    f&#34;BaseClient subclass type is undefined for model class ({self.model_type}), &#34;
                    f&#34;a type-hint for &#39;client&#39; on BaseApi class must be in place for me to know &#34;
                    f&#34;what type to get.&#34;
                )

        return XContext.current(for_type=config_type)

    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. This gets around it since pycharm
    # can&#39;t figure out what&#39;s going on here.
    auth = _auth
    settings = _settings</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></li>
<li><a title="xmodel.base.api.BaseApi" href="../xmodel/base/api.html#xmodel.base.api.BaseApi">BaseApi</a></li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel_rest.api.RestApi.default_converters"><code class="name">var <span class="ident">default_converters</span> : Dict[Type[Any], <a title="xmodel.base.fields.Converter" href="../xmodel/base/fields.html#xmodel.base.fields.Converter">Converter</a>]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.default_converters" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.default_converters">default_converters</a></code>
</p>
<div class="desc inherited"><p>For an overview of type-converts, see
<a href="./#type-converters">Type Converters Overview</a> …</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel_rest.api.RestApi.auth"><code class="name">var <span class="ident">auth</span> : <a title="xmodel_rest.auth.RestAuth" href="auth.html#xmodel_rest.auth.RestAuth">RestAuth</a></code></dt>
<dd>
<div class="desc"><p>Treated a <code>xyn_resaource.context.Resource</code>, a context resource for the purposes of sharing
auth credentials. The type-hint assoicated with <code>auth: XYZ</code> will be used to grab
a resource of that type from the current context each time we are asked.</p>
<p>Thus resource is the auth object used by your <code>xmodel.base.client.BaseClient</code> subclass,
(such as <code>xynlib.orm.rest.RestClient</code>),
to set what type should be used for this, in your BaseClient sub-class, make a type-hint
like below.</p>
<p>Let's say you have an auth class you want to use:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import xmodel.base.auth
&gt;&gt;&gt; import xmodel
&gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
...     pass
</code></pre>
<p>You can set a type-hint for it like so, and it will be automatiaclly used when needed:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
...     auth: MyCoolAuthClass
</code></pre>
<p>Doing that is enough, <code>xynlib.orm.rest.RestClient</code> class will see the type-hint and will
grab one of that type from the XContext and return it.
In the example above, it would be a <code>MyCoolAuthClass</code> type.</p>
<p>The type-hint is lazily cached in self for fast lookup in the future.</p>
<p>To see details on what the Auth object should do,
see <code>xmodel.base.auth.BaseAuth</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _auth(self):
    &#34;&#34;&#34;
    Treated a `xyn_resaource.context.Resource`, a context resource for the purposes of sharing
    auth credentials. The type-hint assoicated with `auth: XYZ` will be used to grab
    a resource of that type from the current context each time we are asked.

    Thus resource is the auth object used by your `xmodel.base.client.BaseClient` subclass,
    (such as `xynlib.orm.rest.RestClient`),
    to set what type should be used for this, in your BaseClient sub-class, make a type-hint
    like below.

    Let&#39;s say you have an auth class you want to use:

    &gt;&gt;&gt; import xmodel.base.auth
    &gt;&gt;&gt; import xmodel
    &gt;&gt;&gt; class MyCoolAuthClass(xmodel.base.auth.RelationAuth)
    ...     pass

    You can set a type-hint for it like so, and it will be automatiaclly used when needed:

    &gt;&gt;&gt; class MyApi(xmodel.RemoteApi):
    ...     auth: MyCoolAuthClass

    Doing that is enough, `xynlib.orm.rest.RestClient` class will see the type-hint and will
    grab one of that type from the XContext and return it.
    In the example above, it would be a `MyCoolAuthClass` type.

    The type-hint is lazily cached in self for fast lookup in the future.

    To see details on what the Auth object should do,
    see `xmodel.base.auth.BaseAuth`.
    &#34;&#34;&#34;

    auth_type: Type[RestAuth] = self._auth_type
    if not auth_type:
        # Will get all type-hints, and ensure they are valid type refrences
        # (otherwise will error out)
        auth_type = get_type_hints(type(self)).get(&#39;auth&#39;, RestAuth)
        self._auth_type = auth_type

    # Auth has tokens we want to try and share, treat it as a resource.
    return auth_type.grab()</code></pre>
</details>
</dd>
<dt id="xmodel_rest.api.RestApi.client"><code class="name">var <span class="ident">client</span> : <a title="xmodel_rest.client.RestClient" href="client.html#xmodel_rest.client.RestClient">RestClient</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.client" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.client">client</a></code>
</p>
<div class="desc inherited"><p>Returns an appropriate concrete <code><a title="xmodel.remote.client.RemoteClient" href="../xmodel/remote/client.html#xmodel.remote.client.RemoteClient">RemoteClient</a></code> subclass.
We figure out the proper client object to use based on the type-hint for …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.context"><code class="name">var <span class="ident">context</span> : <a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.context" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.context">context</a></code>
</p>
<div class="desc inherited"><p>BaseApi context to use when asking this object to send/delete/etc its self to/from
service …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.have_changes"><code class="name">var <span class="ident">have_changes</span> : bool</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.have_changes" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.have_changes">have_changes</a></code>
</p>
<div class="desc inherited"><p>Is True if <code>self.json(only_include_changes=True)</code> is not None;
see json() method for more details.</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.model"><code class="name">var <span class="ident">model</span> : <a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.model" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.model">model</a></code>
</p>
<div class="desc inherited"><p>REQUIRES associated model object [see doc text below] …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.model_type"><code class="name">var <span class="ident">model_type</span> : Type[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.model_type" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.model_type">model_type</a></code>
</p>
<div class="desc inherited"><p>The same BaseApi class is meant to be re-used for any number of Models,
and so a BaseModel specifies it's BaseApi type as generic <code>BaseApi[M]</code>. In …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.options"><code class="name">var <span class="ident">options</span> : <a title="xmodel.remote.options.ApiOptions" href="../xmodel/remote/options.html#xmodel.remote.options.ApiOptions">ApiOptions</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.options" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.options">options</a></code>
</p>
<div class="desc inherited"><p>A set of options you can modify for the current context. If a particular option
inside the options object is not set, Options object may look at the …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.response_state"><code class="name">var <span class="ident">response_state</span> : <a title="xmodel.remote.response_state.ResponseState" href="../xmodel/remote/response_state.html#xmodel.remote.response_state.ResponseState">ResponseState</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.response_state" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.response_state">response_state</a></code>
</p>
<div class="desc inherited"><p>Returns the HTTP/Communication state of the api object …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.settings"><code class="name">var <span class="ident">settings</span> : <a title="xmodel_rest.settings.RestSettings" href="settings.html#xmodel_rest.settings.RestSettings">RestSettings</a></code></dt>
<dd>
<div class="desc"><p>The config object that this api uses, can be customized per-model. All you have to
do is this to make it a different type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import xmodel
&gt;&gt;&gt;
&gt;&gt;&gt; class MySettings(BaseSettings):
...     my_custom_var: str = xmodel.ConfigVar(
...         &quot;MY_CUSTOM_ENVIRONMENTAL_VAR&quot;,
...         &quot;default&quot;
...     )
&gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
...     settings: MySettings
&gt;&gt;&gt; class MyModel(xmodel.model.BaseModel['MyModel']):
...     api: MyApi
</code></pre>
<p>The type-hints are enough to tell the system what types to use. They also will
tell any IDE in use about what type it should be, for type-completion.
So it's sort of doing double-duty!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _settings(self):
    &#34;&#34;&#34; The config object that this api uses, can be customized per-model. All you have to
        do is this to make it a different type:

        &gt;&gt;&gt; import xmodel
        &gt;&gt;&gt;
        &gt;&gt;&gt; class MySettings(BaseSettings):
        ...     my_custom_var: str = xmodel.ConfigVar(
        ...         &#34;MY_CUSTOM_ENVIRONMENTAL_VAR&#34;,
        ...         &#34;default&#34;
        ...     )
        &gt;&gt;&gt; class MyApi(xmodel.BaseApi[M]):
        ...     settings: MySettings
        &gt;&gt;&gt; class MyModel(xmodel.model.BaseModel[&#39;MyModel&#39;]):
        ...     api: MyApi

        The type-hints are enough to tell the system what types to use. They also will
        tell any IDE in use about what type it should be, for type-completion.
        So it&#39;s sort of doing double-duty!
    &#34;&#34;&#34;
    config_type = self._settings_type
    if not config_type:
        config_type = get_type_hints(type(self)).get(&#39;settings&#39;, None)
        self._settings_type = config_type  # Cache config-type.
        if config_type is None:
            raise XynRestError(
                f&#34;BaseClient subclass type is undefined for model class ({self.model_type}), &#34;
                f&#34;a type-hint for &#39;client&#39; on BaseApi class must be in place for me to know &#34;
                f&#34;what type to get.&#34;
            )

    return XContext.current(for_type=config_type)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.api.RestApi.structure"><code class="name">var <span class="ident">structure</span> : <a title="xmodel_rest.structure.RestStructure" href="structure.html#xmodel_rest.structure.RestStructure">RestStructure</a>[<a title="xmodel.base.fields.Field" href="../xmodel/base/fields.html#xmodel.base.fields.Field">Field</a>]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.structure" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.structure">structure</a></code>
</p>
<div class="desc inherited"><p>Contain things that don't vary among the model instances;
ie: This is the same object and applies to all instances of a particular BaseModel class …</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel_rest.api.RestApi.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.delete" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.delete">delete</a></code>
</p>
<div class="desc inherited"><p>REQUIRES associated model object [see self.model] …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.did_send"><code class="name flex">
<span>def <span class="ident">did_send</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.did_send" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.did_send">did_send</a></code>
</p>
<div class="desc inherited"><p>self.client will call us here after someone attempts to send us (a specific model),
you and use <code>RelationApi.model</code> to grab the model that it happened …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.fields_to_pop_for_json"><code class="name flex">
<span>def <span class="ident">fields_to_pop_for_json</span></span>(<span>self, json: dict, field_objs: List[<a title="xmodel.base.fields.Field" href="../xmodel/base/fields.html#xmodel.base.fields.Field">Field</a>], log_output: bool) ‑> Set[Any]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.fields_to_pop_for_json" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.fields_to_pop_for_json">fields_to_pop_for_json</a></code>
</p>
<div class="desc inherited"><p>Goes through the list of fields (field_objs) to determine which ones have not changed in
order to pop them out of the json representation. This method …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.forget_original_json_state"><code class="name flex">
<span>def <span class="ident">forget_original_json_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.forget_original_json_state" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.forget_original_json_state">forget_original_json_state</a></code>
</p>
<div class="desc inherited"><p>If called, we forget/reset the orginal json state, which is a combination
of all the json that this object has been updated with over it's lifetime …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, query: Dict[str, Union[str, int, datetime.date, xurls.url._FormattedQueryValue, None, Iterable[Union[str, int, datetime.date, xurls.url._FormattedQueryValue]]]] = None, *, top: int = None, fields: Optional[Sequence[str]] = Default) ‑> Optional[Iterable[~M]]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.get" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.get">get</a></code>
</p>
<div class="desc inherited"><p>Important: Right now we return a list, but it might be just a generator in the future,
treat the return type as a true Iterable, something you can't …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.get_child_without_lazy_lookup"><code class="name flex">
<span>def <span class="ident">get_child_without_lazy_lookup</span></span>(<span>self, child_field_name, *, false_if_not_set=False) ‑> Union[<a title="xmodel.base.model.BaseModel" href="../xmodel/base/model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M], None, bool, <a title="xsentinels.null.NullType" href="../xsentinels/null.html#xsentinels.null.NullType">NullType</a>]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.get_child_without_lazy_lookup" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.get_child_without_lazy_lookup">get_child_without_lazy_lookup</a></code>
</p>
<div class="desc inherited"><p>REQUIRES associated model object [see self.model] …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.get_via_id"><code class="name flex">
<span>def <span class="ident">get_via_id</span></span>(<span>self, id: Union[int, str, List[Union[int, str]], Dict[str, Union[str, int]], List[Dict[str, Union[str, int]]]], fields: Sequence[str] = Default, id_field: str = None, aux_query: Dict[str, Union[str, int, datetime.date, xurls.url._FormattedQueryValue, None, Iterable[Union[str, int, datetime.date, xurls.url._FormattedQueryValue]]]] = None) ‑> Union[Iterable[~M], ~M, None]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.get_via_id" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.get_via_id">get_via_id</a></code>
</p>
<div class="desc inherited"><p>This method would have probably been better named <code>get_via_key</code> …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, only_include_changes: bool = False, log_output: bool = False) ‑> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.json" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.json">json</a></code>
</p>
<div class="desc inherited"><p><code><a title="xmodel.base.api.BaseApi.json" href="../xmodel/base/api.html#xmodel.base.api.BaseApi.json">BaseApi.json()</a></code> to see superclass's documentation for this method …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.list_of_attrs_to_repr"><code class="name flex">
<span>def <span class="ident">list_of_attrs_to_repr</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.list_of_attrs_to_repr" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.list_of_attrs_to_repr">list_of_attrs_to_repr</a></code>
</p>
<div class="desc inherited"><p>" REQUIRES associated model object [see self.model] …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.option_all_for_name"><code class="name flex">
<span>def <span class="ident">option_all_for_name</span></span>(<span>self, option_attribute_name) ‑> List[Any]</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.option_all_for_name" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.option_all_for_name">option_all_for_name</a></code>
</p>
<div class="desc inherited"><p>Gets a particular option attribute by name in a particular prioritized order …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.option_for_name"><code class="name flex">
<span>def <span class="ident">option_for_name</span></span>(<span>self, option_attribute_name) ‑> Any</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.option_for_name" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.option_for_name">option_for_name</a></code>
</p>
<div class="desc inherited"><p>Returns the first option returned from self.option_all_for_name for the
<code>option_attribute_name</code> that is passed in; otherwise None …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, url: Union[str, <a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a>, None] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see self.model].</p>
<p>Convenience method to send this single object to API, it simply calls
<code>xynlib.orm.base.client.Client.send_objs</code> with a single object in the list
(via <code>xynlib.orm.base.api.BaseApi.model</code>).</p>
<p>If you want to send multiple objects, call <code>xynlib.orm.base.client.Client.send_objs</code>.</p>
<p>Example is below, it uses a made-up rest model called 'SomeRestModelSubclass'.</p>
<p>(I did not provide all details it would need to use the made-up/imagained rest-api;
trying to illisrate a basic point here is all.
If you want more details on how to make a real full/valid rest-model subclass
see #INSERT-README-LINK#.)</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel_rest import RestModel
&gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&quot;....etc....&quot;):
...     pass  # Some attributes from the rest-api go here
&gt;&gt;&gt; obj1 = SomeRestModelSubclass()
&gt;&gt;&gt; obj2 = SomeRestModelSubclass()
&gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])
</code></pre>
<p>If you pass in a <code>url</code> paramater to the <code>send_objs</code> method, the url gets appended to the
final constructed url before the url gets validated.</p>
<p>If the url is validated, it will use that final url [with passed in <code>url</code> this appended].
For more information about how URL's are appended to each-other see:
<code><a title="xurls.url.URLMutable.append_url" href="../xurls/url.html#xurls.url.URLMutable.append_url">URLMutable.append_url()</a></code>.</p>
<p>The response from API will update all the values on this object with the results
of the change [all fields will be updated] and with the latest values from API.</p>
<p>You can check for errors on model object via <code>xmodel.remote.api.response_state</code>, ie:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xynlib.orm import BaseModel
&gt;&gt;&gt; obj: BaseModel
&gt;&gt;&gt; # Check response_state to see if it had an error:
&gt;&gt;&gt; obj.api.response_state.had_error
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, url: URLStr = None):
    &#34;&#34;&#34; REQUIRES associated model object [see self.model].

    Convenience method to send this single object to API, it simply calls
    `xynlib.orm.base.client.Client.send_objs` with a single object in the list
    (via `xynlib.orm.base.api.BaseApi.model`).

    If you want to send multiple objects, call `xynlib.orm.base.client.Client.send_objs`.

    Example is below, it uses a made-up rest model called &#39;SomeRestModelSubclass&#39;.

    (I did not provide all details it would need to use the made-up/imagained rest-api;
    trying to illisrate a basic point here is all.
    If you want more details on how to make a real full/valid rest-model subclass
    see #INSERT-README-LINK#.)

    &gt;&gt;&gt; from xmodel_rest import RestModel
    &gt;&gt;&gt; class SomeRestModelSubclass(RestModel, base_url=&#34;....etc....&#34;):
    ...     pass  # Some attributes from the rest-api go here
    &gt;&gt;&gt; obj1 = SomeRestModelSubclass()
    &gt;&gt;&gt; obj2 = SomeRestModelSubclass()
    &gt;&gt;&gt; RestModel.api.client.send_objs([obj1, obj2])

    If you pass in a `url` paramater to the `send_objs` method, the url gets appended to the
    final constructed url before the url gets validated.

    If the url is validated, it will use that final url [with passed in `url` this appended].
    For more information about how URL&#39;s are appended to each-other see:
    `xurls.url.URLMutable.append_url`.

    The response from API will update all the values on this object with the results
    of the change [all fields will be updated] and with the latest values from API.

    You can check for errors on model object via `xmodel.remote.api.response_state`, ie:

    &gt;&gt;&gt; from xynlib.orm import BaseModel
    &gt;&gt;&gt; obj: BaseModel
    &gt;&gt;&gt; # Check response_state to see if it had an error:
    &gt;&gt;&gt; obj.api.response_state.had_error
    False
    &#34;&#34;&#34;
    # Redirect to client.send_objs:
    self.client.send_objs([self.model], url=url)</code></pre>
</details>
</dd>
<dt id="xmodel_rest.api.RestApi.should_include_field_in_json"><code class="name flex">
<span>def <span class="ident">should_include_field_in_json</span></span>(<span>self, new_value: Any, old_value: Any, field: str) ‑> bool</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.should_include_field_in_json" href="../xmodel/base/api.html#xmodel.remote.api.RemoteApi.should_include_field_in_json">should_include_field_in_json</a></code>
</p>
<div class="desc inherited"><p>Returns True if the the value for field should be included in the JSON.
This only gets called if only_include_changes is True when passed to …</p></div>
</dd>
<dt id="xmodel_rest.api.RestApi.update_from_json"><code class="name flex">
<span>def <span class="ident">update_from_json</span></span>(<span>self, json: Union[Dict[str, Any], Mapping[~KT, +VT_co]])</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.remote.api.RemoteApi" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></code>.<code><a title="xmodel.remote.api.RemoteApi.update_from_json" href="../xmodel/remote/api.html#xmodel.remote.api.RemoteApi.update_from_json">update_from_json</a></code>
</p>
<div class="desc inherited"><p><code><a title="xmodel.base.api.BaseApi.update_from_json" href="../xmodel/base/api.html#xmodel.base.api.BaseApi.update_from_json">BaseApi.update_from_json()</a></code> to see superclass's documentation
for this method …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xmodel_rest" href="index.html">xmodel_rest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel_rest.api.RestApi" href="#xmodel_rest.api.RestApi">RestApi</a></code></h4>
<ul class="">
<li><code><a title="xmodel_rest.api.RestApi.auth" href="#xmodel_rest.api.RestApi.auth">auth</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.client" href="#xmodel_rest.api.RestApi.client">client</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.context" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.context">context</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.default_converters" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.default_converters">default_converters</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.delete" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.delete">delete</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.did_send" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.did_send">did_send</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.fields_to_pop_for_json" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.fields_to_pop_for_json">fields_to_pop_for_json</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.forget_original_json_state" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.forget_original_json_state">forget_original_json_state</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.get" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.get">get</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.get_child_without_lazy_lookup" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.get_child_without_lazy_lookup">get_child_without_lazy_lookup</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.get_via_id" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.get_via_id">get_via_id</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.have_changes" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.have_changes">have_changes</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.json" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.json">json</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.list_of_attrs_to_repr" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.list_of_attrs_to_repr">list_of_attrs_to_repr</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.model" href="#xmodel_rest.api.RestApi.model">model</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.model_type" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.model_type">model_type</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.option_all_for_name" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.option_all_for_name">option_all_for_name</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.option_for_name" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.option_for_name">option_for_name</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.options" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.options">options</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.response_state" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.response_state">response_state</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.send" href="#xmodel_rest.api.RestApi.send">send</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.settings" href="#xmodel_rest.api.RestApi.settings">settings</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.should_include_field_in_json" href="../xmodel/base/api.html#xmodel_rest.api.RestApi.should_include_field_in_json">should_include_field_in_json</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.structure" href="#xmodel_rest.api.RestApi.structure">structure</a></code></li>
<li><code><a title="xmodel_rest.api.RestApi.update_from_json" href="../xmodel/remote/api.html#xmodel_rest.api.RestApi.update_from_json">update_from_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>