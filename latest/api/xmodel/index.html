<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel API documentation</title>
<meta name="description" content="Provides easy way to map dict to/from Full-Fledged &#39;JsonModel&#39; object â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>xmodel</code></h1>
</header>
<section id="section-intro">
<p>Provides easy way to map dict to/from Full-Fledged 'JsonModel' object.</p>
<p>Also, an abstract RemoteModel interface used in xmodel-rest and xmodel-dynamo along with
some common code.</p>
<div class="admonition important">
<p class="admonition-title">Important:&ensp;Doc-comments in varius classes have out-of-date/broken refs; will be fixed soon.</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important:&ensp;Docs Below Are OUT OF DATE!!!</p>
<p>Most of the docs below belong int xmodel-rest and xmodel-dynamo.
We will revamp them soon, and put more into the README.md as well.
Currently, I would look at the docs above or README.md for info on how to use
<code><a title="xmodel.JsonModel" href="#xmodel.JsonModel">JsonModel</a></code> class, which is the main-class of this library.</p>
</div>
<h1 id="old-docs-below-need-a-lot-of-updates-orm-is-old-reference">Old Docs Below - Need A Lot Of Updates (ORM is old reference)</h1>
<p>Used to be called the ORM library, that reference will be removed/updated as we get the docs
back in shape here soon. For now, they are older references that may not be entirely accurate
anymore.</p>
<h2 id="orm-library-overview">ORM Library Overview</h2>
<p>Library is intended to be used as a way to consolidate and standardize how we work with Model
classes
that can represent data from various different locations.
It can be used as an easy way
to communicate to/from our various places where we store models/information.</p>
<p>Right now this includes:</p>
<ul>
<li>Our own API's, such as Account, Auth and Founder's club API's.</li>
<li>Dynamo tables.</li>
<li>Big commerce</li>
<li>Hubspot</li>
</ul>
<p>Some reasons to use orm:</p>
<ul>
<li>The foundation for <code>xmodel-rest</code> library's Model objects.<ul>
<li>Let's us easily map objects into/out of various rest API's.</li>
<li>Handles breaking up requests to get objects by id transparently into
several sub-requests.</li>
<li>Does pagination for you automatically</li>
<li>Can lazily and prefetch0in-bulk child objects.</li>
</ul>
</li>
<li>Useful for accessing generally restful API's.<ul>
<li>hubspot and bigcommerce projects use to to access their services api.</li>
</ul>
</li>
<li>Consistant interface, works the same wherever it's used
(vs one-off methods inside the project doing the same things in diffrent ways).</li>
<li><code>xmodel.dynamo</code>: A library to map objects into Dynamo, we consolidated code from
a few diffrent projects<ul>
<li>Easily map objects into and out of Dynamo.</li>
<li>No need to duplicate code for things like paginating the results.</li>
<li>Add features or fix bugs in library, all other projects that use it benefit.</li>
<li>Can figure out best way to query dynamo for you automatically.</li>
</ul>
</li>
</ul>
<p>Some of the Models classes are kept directly in their respective projects (such as with hubspot).
In these cases, you can import that project as a Library to utilize it's Model's and to also
utilize it's other code/processes (which probably work closely with the Model's in question).</p>
<h2 id="model-fields">Model Fields</h2>
<p>You can create your own Models. For a real example, see <code>hubspot.api.api.Contact</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;(side-note: We should have put it in "hubspot.api.contact.Contact" or some such).</p>
</div>
<p>Here is a basic Model below that I will use for illustrative purposes.
It's a basic model that is using the standard functionality, with the only customization
being the <code>base_url</code> which is one of elements that construct's the url/path to it's endpoint.</p>
<h3 id="basic-model-example">Basic Model Example</h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel import Field, BaseModel
&gt;&gt;&gt; import datetime as dt
&gt;&gt;&gt;
&gt;&gt;&gt; class MyModel(
...    BaseModel['MyModel'],  # &lt;-- Need to put class name as type-var value
...                           #     (use str to forward ref)
...    base_url=&quot;accounts&quot;  # &lt;-- Class argument passed to underlying Structure object.
... ):
...    my_attribute: str  # &lt;-- Automatically maps to API without extra effort
...    created_at: dt.datetime  # &lt;-- Can auto-convert other types for you
...
...    other_attribute: int = Field(read_only=True)  # &lt;-- Customize options
...
...    _will_not_map_to_api: int  # &lt;-- Anything that begins with '_' won't map
...    also_will_not_map = None  # &lt;-- No type-hint, 'Field' not auto-created
</code></pre>
<h3 id="type-hints">Type-hints</h3>
<p>When Model classes are created, they will lazily find type-hinted attributes and determine
if a <code>xmodel.fields.Field</code> should automatically be created for them.
A <code>xmodel.fields.Field</code> is what is used by the sdk to map an attribute into it's corresponding
JSON field that is sent/retrieved from the API service.</p>
<p>You can specify other types, such as datetime/date types.
The SDK has a default converter in place for datetime/date types.
You can define other default converters, see <a href="#type-converters">Type Converters</a> for more details.
Converters can also be used on a per-field basis via <code>xmodel.fields.Field.converter</code>.</p>
<p>The Model will enforce these type-hints, and use a converter if needed and one is available.</p>
<p>For example, if you try do do this:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; obj = MyModel()
&gt;&gt;&gt; obj.my_attribute = 123
&gt;&gt;&gt; obj.my_attribute
&quot;123&quot;
</code></pre>
<p>Notice how the output of the attribute is a str now and not an int. The Model will automatically
realize that it needs to be a string and try to convert it into a string for you.
If this is unsuccessful, it will raise an exception.</p>
<p>When this model is initialized from JSON, it does the same conversions. When grabbing this
object from the API it will automatically create the Model from the JSON it receives from API.</p>
<p>If you wish, you can also pass in your own dict structure when creating an object. The <code>Dict</code>
could have come from a JSON string.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import json
&gt;&gt;&gt; parsed_values = json.loads('{&quot;my_attribute&quot;: 1234}')
&gt;&gt;&gt; obj = MyModel(parsed_values)
&gt;&gt;&gt; obj.my_attribute
&quot;1234&quot;
</code></pre>
<h3 id="field-objects">Field Objects</h3>
<p>A <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> has a set of <code>xmodel.fields.Field</code>'s that define how each
field will map to an attribute to/from JSON, which we currently use for all of our APIs.
See <a href="#json">JSON</a> for more details.</p>
<p>You can get a list of <code>xmodel.fields.Field</code>'s via <code>xmodel.base.api.BaseApi.fields</code>.
This will allow you do iterate over all the fields the system will use when interacting
with JSON documents.</p>
<p>If you don't allocate a <code>xmodel.fields.Field</code> object directly on the Class at class definition
time we will auto-generate them for you. It will only do this for fields that have a type-hint.
If there is no type-hint, we won't auto-allocate a Field for it, and hence we won't
map it to/from the <a href="#json">JSON</a>, enforce the types or auto-convert them.
See <a href="#type-hints">Type Hints</a>.</p>
<h4 id="field-subclasses">Field Subclasses</h4>
<p>You can have your own Field sub-class if you wish. To guarantee all auto-generated fields
use you class, you can set the type on <code>xmodel.base.structure.Structure.field_type</code>.</p>
<p>This needs to be set before any Model class that uses it is initialized.
You can do that by subclassing <code>xmodel.base.structure.Structure</code> and setting it at class
definition time. You then tell your BaseApi's to use your new structure.</p>
<p>For an example of doing all of this and also creating a custom <code>xmodel.fields.Field</code> subclass,
see <code>xmodel.dynamo.DynField</code>. We use this in our Dynamo-related code to put additional
options on model Fields that are only really useful for Dynamo models.</p>
<p>But the general idea is this:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel import BaseStructure.....
# todo: Finish this example.
</code></pre>
<h3 id="json">JSON</h3>
<p>Right now all of our API's accept and return JSON.
The Models handle JSON natively.
This means you can also use Model's
to more easily deal with JSON without necessarily having to use any of the
<code>xmodel.rest.RestClient</code> aspects (send/receive).
This is what we did with Dynamo at first, we simply grabbed the json via <code>xmodel.base.api.json</code>
and send that directly into boto.
Later on we put together a special <code>xmodel.dynamo.DynClient</code>
to automatically send/receive it via boto (wraps boto).</p>
<p>Some the the reasons why it may be easier is due to the Model's in combination with the Fields.
You can easily define a mapping and automatic type-conversion with only a simple Model defintion.</p>
<div class="admonition hint">
<p class="admonition-title">Hint:&ensp;What about API's that use a non-JSON format?</p>
<p>If we ever have an API that has some other format, we would have a
<code>xmodel.rest.RestClient</code> subclass that would handle mapping it to/from the JSON that
we use on the Models. After RestClient gets a response, it would make a Dict out of it as if
it got it from JSON and give that to the Model; and vic-versa (map from Dict into API format).</p>
</div>
<h2 id="modelapi">Model.api</h2>
<p>You can also export or update an existing <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> object via methods
under a special attribute <code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>. This attribute has a reserved name
on every Model. This attribute is how the Model interfaces with the rest of the SDK.
That way the rest of the namespace for the Model attributes is available for use by Model subclass.</p>
<p>You can update an object via a dict from parse JSON via
<code><a title="xmodel.base.api.BaseApi.update_from_json" href="base/api.html#xmodel.base.api.BaseApi.update_from_json">BaseApi.update_from_json()</a></code>.
Exporting JSON is easily done via <code><a title="xmodel.base.api.BaseApi.json" href="base/api.html#xmodel.base.api.BaseApi.json">BaseApi.json()</a></code>.
Both of these methods
accept/return a <code>xmodel.types.JsonDict</code>, which is just a <code>dict</code> with <code>str</code>
keys and <code>Any</code> value.</p>
<p><code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> is also how you can easily get/send objects to/from the
API service.</p>
<p>There are various ways to change/customize a model, keep reading further.</p>
<h2 id="baseapi-class">BaseApi Class</h2>
<p>One of the more important classes is <code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code>.</p>
<p>For an overview of the class see <a href="./api.html#api-class-overview">BaseApi Class Overview</a>
api.html#use-of-type-hints-for-changing-used-type</p>
<p>The class is a sort of central hub, it's where you can specify which types are allocated
for each sub-class. This is done via type-hints (typehints are read and used to allocate
correct class).</p>
<p>For more details see
<a href="./api.html#use-of-type-hints-for-changing-used-type">Use of Type Hints for Changing Type Used</a></p>
<h3 id="type-converters">Type Converters</h3>
<p>The mapping of basic types to their converter function lives at
<code><a title="xmodel.base.api.BaseApi.default_converters" href="base/api.html#xmodel.base.api.BaseApi.default_converters">BaseApi.default_converters</a></code>. Normally you could customize this by
by subclassing <code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> with your own version for you Model(s).
You can also change it dynamically via adjusting <code><a title="xmodel.base.api.BaseApi.default_converters" href="base/api.html#xmodel.base.api.BaseApi.default_converters">BaseApi.default_converters</a></code>.</p>
<p>For the default converter map, see <code>xmodel.converters.DEFAULT_CONVERTERS</code>.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<h2 id="this-is-how-i-want-it-to-work-in-the-future">This is how I want it to work in the future:</h2>
<p>Something to keep in mind is when the xmodel.base.api.BaseApi converts a type, and it needs
a lookup a default converter it uses <code>xmodel.base.api.BaseApi.get_default_converter</code>.
This method first checks it's self, and if type to convert is not in dict, it will check
the superclasses default converters and so on until one is found.</p>
<p>This means you can override a type conversion from a super class, or let it be used if it works
as needed. One example of this is how hubspot uses a time-stamp integer to communicate time
but most other systems use the normal ISO date/time format. So for the BaseApi class that all
hubspot Model's use, they have the datetime converter overriden with a special Hubspot version.</p>
</div>
<p>You can also set a converter per-field via a callback on a <code>xmodel.fields.Field</code> object.</p>
<p>All converters have a calling convention, see <code>xmodel.fields.Converter</code> for details.</p>
<h2 id="restclient-class">RestClient Class</h2>
<div class="admonition todo">
<dl>
<dt>TODO</dt>
<dd>
<p>Section is unfinished, needs to be fleshed out more.</p>
</dd>
</dl>
</div>
<p>The config object that this api uses, can be customized per-model. All you have to
do is this to make it a different type::</p>
<pre><code>class MyClient():
    # Customize RestClient class in some way....
    my_custom_var: str = ConfigVar("MY_CUSTOM_ENVIRONMENTAL_VAR", "default")

class MyApi(base.BaseApi[T]):
    client: MyClient

class MyModel(base.model['MyModel'], endpoint_url="custom/path"):
    api: MyApi
</code></pre>
<p>The type-hints are enough to tell the system what types to use. They also will
tell any IDE in use about what type it should be, for type-completion.
So it's sort of doing double-duty to both tell IDE what it is and tell class what type to allocate
for the attribute when creating the class/object.</p>
<p>.. todo: Make changing default_converters work as expected [api-class vs api-instance];
and then talk about te default type-converters here.</p>
<h2 id="related-child-models">Related Child Model's</h2>
<p>Going back to this example (from end of the <a href="#orm-library-overview">ORM Library Overview</a> section):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt; account = Account.api.get_via_id(3)
&gt;&gt;&gt; print(account.account_no)
&quot;3&quot;
</code></pre>
<p>We will look at the this Account model more closely, it has a good example of using child objects.
Here is a simplified version of the Account Model:</p>
<pre><code class="language-python">class PhoneNumber(AccountModel['PhoneNumber'], base_url=&quot;account/phone_numbers&quot;):
    account_id: int
    number: str
    description: str
    is_active: bool

class Account(AccountModel['Account'], base_url=&quot;accounts&quot;):
    # Configure a more specific api to use with the Accounts endpoint.
    api: AccountsEndpointApi[Account]

    # This is generally very useful for Account objects,
    # don't exclude updated_at by default.
    updated_at: dt.datetime = Field(exclude=False)

    account_no: str
    first_name: str
    last_name: str
    preferred_name: str
    preferred_phone_number: PhoneNumber
    preferred_address: Address
</code></pre>
<p>Here is an example of getting that objects preferred phone number:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(account.preferred_phone_number.number)
&quot;8015551234&quot;
</code></pre>
<p>By default <code>preferred_phone_number</code> is currently <code>None</code> (internally),
so the system knows that the <code>PhoneNumber</code> object has not been retrieved from the API yet.
It also knows the id for the preferred_phone_number. It's stored on the account object via
<code>preferred_phone_number_id</code> (via JSON from api).
The ORM stored this number internally when the object was fetched.</p>
<p>If you define a field like this in the object:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; preferred_phone_number_id: int
</code></pre>
<p>Instead of storing the number internally, it would store it here instead
(and you can get/set it as needed).
You can also get/set it by setting the <code>id</code> field of the child object, like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; obj: Account
&gt;&gt;&gt; obj.preferred_phone_number.id
123456
</code></pre>
<p>If this <code>id</code> is known to the Model, meaning that it was fetched when the object was retrieved
from api (or set to something via <code>preferred_phone_number_id</code>); The sdk can lazily lookup
the object on demand when it's asked for.
It knows <code>preferred_phone_number</code> is a <code>PhoneNumber</code> model type
(and that it's also associated with a diffrent api endpoint) and it knows the id,
so it simply asks for it on demand/lazily via <code>ChildType.api.get_via_id</code>
(aka: <code>xmodel.base.api.BaseApi.get_via_id</code>).</p>
<p>It automatically takes this `preferred_phone_number_id`` and looks-up the preferred phone number
on the spot when you ask for it:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; obj.preferred_phone_number
</code></pre>
<p>This object is stored under <code>preferred_phone_number</code> so in the future it already has the object
when something asks for it again.</p>
<h3 id="auto-prefetch-children">Auto Prefetch Children</h3>
<p>You can also pre-fetch these child objects in bulk if you have a collection of model objects (such
as a <code>List</code> of <code>some_lib.account.Account</code>'s) via <code>xmodel.children.bulk_request_lazy_children</code>.
This is much more efficient if you have a lot of objects because it can grab many of the children
pre-request.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>At some point the xmodel-rest will probably fetch many child objects lazily in bulk.
When someone accesses one lazily, it could grab more for other Model objects that don't have
their children fetched yet. We just put in a weak-ref cache, so using this we could
find the ones that we have fetched in the past and and are still around.
We could fetch their children too at the same time in the same request in bulk
(ie: so we fetch original child requested, along with 50 more or so via a single request).</p>
</div>
<p>You can also have the xmodel do this automatically as it receives pages of objects via
<code>xmodel.options.ApiOptions.auto_get_child_objects</code> like so:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Account.api.options.auto_get_child_objects = True
</code></pre>
<p>This sets this option for this Model type in the current <code><a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code>.
If you make a new XContext, and then throw the XContext away, it will revert these option changes.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xinject.context import XContext
&gt;&gt;&gt;
&gt;&gt;&gt; # Starts out as False....
&gt;&gt;&gt; assert not Account.api.options.auto_get_child_objects
&gt;&gt;&gt;
&gt;&gt;&gt; with XContext():
...     Account.api.options.auto_get_child_objects = True
...     # Returned generator will 'remember' the options at time of creation
...     accounts_gen_with_children_pre_fetched = Account.api.get(top=100)
&gt;&gt;&gt;
&gt;&gt;&gt; # After XContext is gone, it reverts back to what it was before
&gt;&gt;&gt; assert not Account.api.options.auto_get_child_objects
</code></pre>
<p>You can use this to grab all of the accounts. The below returns a Generator and will grab a page
of Account objects at a time, but still returning each object individually via the generator.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; [account.id for account in Account.api.get()]
[1, 2, 3, 4, 5, 118, 127, ...]
</code></pre>
<p>This is to help limit memory usage. It will also allow the sdk to asynchronously grab multiple
pages in the future [pre-fetch them] without changing the sdk's public interface to other projects.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Asynchronously pre-fetch pages of objects as the generator iterates though result set.</p>
</div>
<h2 id="caching">Caching</h2>
<p>There is a strong-ref and weak-ref caching system in the ORM you can take advantage of,
depending on the situation.</p>
<p>By default, they are both disabled.
They are explicitly an opt-in feature.</p>
<h3 id="strong-ref-caching">Strong-Ref Caching</h3>
<p>You can enable strong-ref caching in three ways currently:</p>
<ul>
<li>
<p>Set it on directly on <code>xmodel.base.api.BaseApi.options.cache_by_id=True</code></p>
</li>
<li>
<p>Set <code>cache_by_id=True</code> as one of the model classes options, like so:</p>
</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel import ApiOptions
&gt;&gt;&gt; class MyModel(RestModel['MyModel'], api_options=ApiOptions(cache_by_id=True)):
...     account_id: int
...     number: str
...     description: str
...     is_active: bool
</code></pre>
<ul>
<li>Via a subclass of a structure, such as <code>xmodel.rest.RestStructure</code>,
and setting it's <code>xmodel.base.structure.BaseStructure.api_options</code> to a default set
that are used by default for new Model sub-classes that use that Structure subclass.
Here is an example:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; from typing import TypeVar
&gt;&gt;&gt; from xmodel import Field
&gt;&gt;&gt;
&gt;&gt;&gt; F = TypeVar(name=&quot;F&quot;, bound=Field)
&gt;&gt;&gt; class AlwaysEnableCacheByIDStructure(RestStructure[F]):
...     # todo: Have ability to set a default value for api_options on the Api class
...     #   Right now you can only set this on a Model or Structure class.
...     api_options = ApiOptions(cache_by_id=True)
</code></pre>
<p>The strong cache is useful for caching objects that almost never change.</p>
<h3 id="weak-ref-caching">Weak-Ref Caching</h3>
<p>Caching objects weakly is also disabled by default.</p>
<p>The weak-caching is nice, because there are situations where various object will reference
the same object. Take for instance order and order-lines.
The order-lines would have a
one-to-one relationship back to the order object, and there is no need to lookup the same
order object over and over again if you ask each order-line for it's order-object.</p>
<p>This is where the weak-cache can shine. The ORM can store temporary references to objects
by 'id' and check this cache to retrieve them later instead of having to do an actual
fetch-request.</p>
<p>Another place this can be useful is when query objects that are in a tree.
And objects parent could be referenced by several children.</p>
<p>You can enable weak-caching via the <code>xmodel.weak_cache_pool.WeakCachePool</code>.
<code><a title="xmodel" href="#xmodel">xmodel</a></code> imports this, so you can import it easily via:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel import WeakCachePool
</code></pre>
<p>There is an enable property on it that you set to <code>True</code> to enable the caching.
See <code>xmodel.weak_cache_pool.WeakCachePool.enable</code>.</p>
<p>It's a <code>xinject.context.Dependency</code>, and so can be used like any other normal resource.
You can set the enable property on the current resource to make it more permently on.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; WeakCachePool.grab().enabled = True
</code></pre>
<p>Or you can temporarly enable it by creating a new <code>xmodel.weak_cache_pool.WeakCachePool</code>
object and activating it temporarily.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel import WeakCachePool
&gt;&gt;&gt; @WeakCachePool(enabled=True)
&gt;&gt;&gt; def lambda_event_handler(event, context):
...    pass
</code></pre>
<p>The most recent WeakCachePool is the one that is used, and the weak refrences are stored inside it.
So when a WeakCachePool is deactivated and thrown-away, it will forgot anything that was weakly
cached in it. Same thing happens when activating a new WeakCachePool, it will not use the
previous pool for anything until the new WeakCachePool is deactivated.</p>
<p>This means, when you activate a new WeakCachePool, you are gurateed to always request new
objects instead of using previously cached ones.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Provides easy way to map dict to/from Full-Fledged &#39;JsonModel&#39; object.

Also, an abstract RemoteModel interface used in xmodel-rest and xmodel-dynamo along with
some common code.

.. important:: Doc-comments in varius classes have out-of-date/broken refs; will be fixed soon.


.. important:: Docs Below Are OUT OF DATE!!!
    Most of the docs below belong int xmodel-rest and xmodel-dynamo.
    We will revamp them soon, and put more into the README.md as well.
    Currently, I would look at the docs above or README.md for info on how to use
    `JsonModel` class, which is the main-class of this library.


# Old Docs Below - Need A Lot Of Updates (ORM is old reference)

Used to be called the ORM library, that reference will be removed/updated as we get the docs
back in shape here soon. For now, they are older references that may not be entirely accurate
anymore.

## ORM Library Overview
[orm-library-overview]: #orm-library-overview

Library is intended to be used as a way to consolidate and standardize how we work with Model
classes  that can represent data from various different locations.  It can be used as an easy way
to communicate to/from our various places where we store models/information.

Right now this includes:

- Our own API&#39;s, such as Account, Auth and Founder&#39;s club API&#39;s.
- Dynamo tables.
- Big commerce
- Hubspot

Some reasons to use orm:

- The foundation for `xmodel-rest` library&#39;s Model objects.
    - Let&#39;s us easily map objects into/out of various rest API&#39;s.
    - Handles breaking up requests to get objects by id transparently into
        several sub-requests.
    - Does pagination for you automatically
    - Can lazily and prefetch0in-bulk child objects.
- Useful for accessing generally restful API&#39;s.
    - hubspot and bigcommerce projects use to to access their services api.
- Consistant interface, works the same wherever it&#39;s used
    (vs one-off methods inside the project doing the same things in diffrent ways).
- `xmodel.dynamo`: A library to map objects into Dynamo, we consolidated code from
    a few diffrent projects
    - Easily map objects into and out of Dynamo.
    - No need to duplicate code for things like paginating the results.
    - Add features or fix bugs in library, all other projects that use it benefit.
    - Can figure out best way to query dynamo for you automatically.

Some of the Models classes are kept directly in their respective projects (such as with hubspot).
In these cases, you can import that project as a Library to utilize it&#39;s Model&#39;s and to also
utilize it&#39;s other code/processes (which probably work closely with the Model&#39;s in question).

## Model Fields
[model-fields]: #model-fields

You can create your own Models. For a real example, see `hubspot.api.api.Contact`.

.. note:: (side-note: We should have put it in &#34;hubspot.api.contact.Contact&#34; or some such).

Here is a basic Model below that I will use for illustrative purposes.
It&#39;s a basic model that is using the standard functionality, with the only customization
being the `base_url` which is one of elements that construct&#39;s the url/path to it&#39;s endpoint.

### Basic Model Example
[model-fields]: #basic-model-example

&gt;&gt;&gt; from xmodel import Field, BaseModel
&gt;&gt;&gt; import datetime as dt
&gt;&gt;&gt;
&gt;&gt;&gt; class MyModel(
...    BaseModel[&#39;MyModel&#39;],  # &lt;-- Need to put class name as type-var value
...                           #     (use str to forward ref)
...    base_url=&#34;accounts&#34;  # &lt;-- Class argument passed to underlying Structure object.
... ):
...    my_attribute: str  # &lt;-- Automatically maps to API without extra effort
...    created_at: dt.datetime  # &lt;-- Can auto-convert other types for you
...
...    other_attribute: int = Field(read_only=True)  # &lt;-- Customize options
...
...    _will_not_map_to_api: int  # &lt;-- Anything that begins with &#39;_&#39; won&#39;t map
...    also_will_not_map = None  # &lt;-- No type-hint, &#39;Field&#39; not auto-created

### Type-hints
[type-hints]: #type-hints

When Model classes are created, they will lazily find type-hinted attributes and determine
if a `xmodel.fields.Field` should automatically be created for them.
A `xmodel.fields.Field` is what is used by the sdk to map an attribute into it&#39;s corresponding
JSON field that is sent/retrieved from the API service.

You can specify other types, such as datetime/date types.
The SDK has a default converter in place for datetime/date types.
You can define other default converters, see [Type Converters](#type-converters) for more details.
Converters can also be used on a per-field basis via `xmodel.fields.Field.converter`.

The Model will enforce these type-hints, and use a converter if needed and one is available.

For example, if you try do do this:


&gt;&gt;&gt; obj = MyModel()
&gt;&gt;&gt; obj.my_attribute = 123
&gt;&gt;&gt; obj.my_attribute
&#34;123&#34;


Notice how the output of the attribute is a str now and not an int. The Model will automatically
realize that it needs to be a string and try to convert it into a string for you.
If this is unsuccessful, it will raise an exception.

When this model is initialized from JSON, it does the same conversions. When grabbing this
object from the API it will automatically create the Model from the JSON it receives from API.

If you wish, you can also pass in your own dict structure when creating an object. The `Dict`
could have come from a JSON string.

&gt;&gt;&gt; import json
&gt;&gt;&gt; parsed_values = json.loads(&#39;{&#34;my_attribute&#34;: 1234}&#39;)
&gt;&gt;&gt; obj = MyModel(parsed_values)
&gt;&gt;&gt; obj.my_attribute
&#34;1234&#34;

### Field Objects
[field-objects]: #field-objects

A `xmodel.base.model.BaseModel` has a set of `xmodel.fields.Field`&#39;s that define how each
field will map to an attribute to/from JSON, which we currently use for all of our APIs.
See [JSON](#json) for more details.

You can get a list of `xmodel.fields.Field`&#39;s via `xmodel.base.api.BaseApi.fields`.
This will allow you do iterate over all the fields the system will use when interacting
with JSON documents.

If you don&#39;t allocate a `xmodel.fields.Field` object directly on the Class at class definition
time we will auto-generate them for you. It will only do this for fields that have a type-hint.
If there is no type-hint, we won&#39;t auto-allocate a Field for it, and hence we won&#39;t
map it to/from the [JSON](#json), enforce the types or auto-convert them.
See [Type Hints](#type-hints).

#### Field Subclasses

You can have your own Field sub-class if you wish. To guarantee all auto-generated fields
use you class, you can set the type on `xmodel.base.structure.Structure.field_type`.

This needs to be set before any Model class that uses it is initialized.
You can do that by subclassing `xmodel.base.structure.Structure` and setting it at class
definition time. You then tell your BaseApi&#39;s to use your new structure.

For an example of doing all of this and also creating a custom `xmodel.fields.Field` subclass,
see `xmodel.dynamo.DynField`. We use this in our Dynamo-related code to put additional
options on model Fields that are only really useful for Dynamo models.

But the general idea is this:

&gt;&gt;&gt; from xmodel import BaseStructure.....
# todo: Finish this example.

### JSON
[JSON]: #JSON

Right now all of our API&#39;s accept and return JSON.
The Models handle JSON natively.  This means you can also use Model&#39;s
to more easily deal with JSON without necessarily having to use any of the
`xmodel.rest.RestClient` aspects (send/receive).
This is what we did with Dynamo at first, we simply grabbed the json via `xmodel.base.api.json`
and send that directly into boto.
Later on we put together a special `xmodel.dynamo.DynClient`
to automatically send/receive it via boto (wraps boto).

Some the the reasons why it may be easier is due to the Model&#39;s in combination with the Fields.
You can easily define a mapping and automatic type-conversion with only a simple Model defintion.

.. hint:: What about API&#39;s that use a non-JSON format?
    If we ever have an API that has some other format, we would have a
    `xmodel.rest.RestClient` subclass that would handle mapping it to/from the JSON that
    we use on the Models. After RestClient gets a response, it would make a Dict out of it as if
    it got it from JSON and give that to the Model; and vic-versa (map from Dict into API format).


## Model.api

You can also export or update an existing `xmodel.base.model.BaseModel` object via methods
under a special attribute `xmodel.base.model.BaseModel.api`. This attribute has a reserved name
on every Model. This attribute is how the Model interfaces with the rest of the SDK.
That way the rest of the namespace for the Model attributes is available for use by Model subclass.

You can update an object via a dict from parse JSON via
`xmodel.base.api.BaseApi.update_from_json`.
Exporting JSON is easily done via `xmodel.base.api.BaseApi.json`.  Both of these methods
accept/return a `xmodel.types.JsonDict`, which is just a `dict` with `str`
keys and `Any` value.

`xmodel.base.model.BaseModel.api` is also how you can easily get/send objects to/from the
API service.


There are various ways to change/customize a model, keep reading further.

## BaseApi Class

One of the more important classes is `xmodel.base.api.BaseApi`.

For an overview of the class see [BaseApi Class Overview](./api.html#api-class-overview)
api.html#use-of-type-hints-for-changing-used-type

The class is a sort of central hub, it&#39;s where you can specify which types are allocated
for each sub-class. This is done via type-hints (typehints are read and used to allocate
correct class).

For more details see
[Use of Type Hints for Changing Type Used](./api.html#use-of-type-hints-for-changing-used-type)

### Type Converters
[type-converters]: #type-converters

The mapping of basic types to their converter function lives at
`xmodel.base.api.BaseApi.default_converters`. Normally you could customize this by
by subclassing `xmodel.base.api.BaseApi` with your own version for you Model(s).
You can also change it dynamically via adjusting `xmodel.base.api.BaseApi.default_converters`.

For the default converter map, see `xmodel.converters.DEFAULT_CONVERTERS`.

.. todo::
    ## This is how I want it to work in the future:

    Something to keep in mind is when the xmodel.base.api.BaseApi converts a type, and it needs
    a lookup a default converter it uses `xmodel.base.api.BaseApi.get_default_converter`.
    This method first checks it&#39;s self, and if type to convert is not in dict, it will check
    the superclasses default converters and so on until one is found.

    This means you can override a type conversion from a super class, or let it be used if it works
    as needed. One example of this is how hubspot uses a time-stamp integer to communicate time
    but most other systems use the normal ISO date/time format. So for the BaseApi class that all
    hubspot Model&#39;s use, they have the datetime converter overriden with a special Hubspot version.

You can also set a converter per-field via a callback on a `xmodel.fields.Field` object.

All converters have a calling convention, see `xmodel.fields.Converter` for details.

## RestClient Class

.. todo::: Section is unfinished, needs to be fleshed out more.

The config object that this api uses, can be customized per-model. All you have to
do is this to make it a different type::


    class MyClient():
        # Customize RestClient class in some way....
        my_custom_var: str = ConfigVar(&#34;MY_CUSTOM_ENVIRONMENTAL_VAR&#34;, &#34;default&#34;)

    class MyApi(base.BaseApi[T]):
        client: MyClient

    class MyModel(base.model[&#39;MyModel&#39;], endpoint_url=&#34;custom/path&#34;):
        api: MyApi


The type-hints are enough to tell the system what types to use. They also will
tell any IDE in use about what type it should be, for type-completion.
So it&#39;s sort of doing double-duty to both tell IDE what it is and tell class what type to allocate
for the attribute when creating the class/object.

.. todo: Make changing default_converters work as expected [api-class vs api-instance];
    and then talk about te default type-converters here.

## Related Child Model&#39;s
[child-models]: #child-models

Going back to this example (from end of the [ORM Library Overview](#orm-library-overview) section):

&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt; account = Account.api.get_via_id(3)
&gt;&gt;&gt; print(account.account_no)
&#34;3&#34;

We will look at the this Account model more closely, it has a good example of using child objects.
Here is a simplified version of the Account Model:

```python
class PhoneNumber(AccountModel[&#39;PhoneNumber&#39;], base_url=&#34;account/phone_numbers&#34;):
    account_id: int
    number: str
    description: str
    is_active: bool

class Account(AccountModel[&#39;Account&#39;], base_url=&#34;accounts&#34;):
    # Configure a more specific api to use with the Accounts endpoint.
    api: AccountsEndpointApi[Account]

    # This is generally very useful for Account objects,
    # don&#39;t exclude updated_at by default.
    updated_at: dt.datetime = Field(exclude=False)

    account_no: str
    first_name: str
    last_name: str
    preferred_name: str
    preferred_phone_number: PhoneNumber
    preferred_address: Address
```

Here is an example of getting that objects preferred phone number:

&gt;&gt;&gt; print(account.preferred_phone_number.number)
&#34;8015551234&#34;

By default `preferred_phone_number` is currently `None` (internally),
so the system knows that the `PhoneNumber` object has not been retrieved from the API yet.
It also knows the id for the preferred_phone_number. It&#39;s stored on the account object via
`preferred_phone_number_id` (via JSON from api).
The ORM stored this number internally when the object was fetched.

If you define a field like this in the object:

&gt;&gt;&gt; preferred_phone_number_id: int

Instead of storing the number internally, it would store it here instead
(and you can get/set it as needed).
You can also get/set it by setting the `id` field of the child object, like so:

&gt;&gt;&gt; obj: Account
&gt;&gt;&gt; obj.preferred_phone_number.id
123456

If this `id` is known to the Model, meaning that it was fetched when the object was retrieved
from api (or set to something via `preferred_phone_number_id`); The sdk can lazily lookup
the object on demand when it&#39;s asked for.
It knows `preferred_phone_number` is a `PhoneNumber` model type
(and that it&#39;s also associated with a diffrent api endpoint) and it knows the id,
so it simply asks for it on demand/lazily via `ChildType.api.get_via_id`
(aka: `xmodel.base.api.BaseApi.get_via_id`).


It automatically takes this `preferred_phone_number_id`` and looks-up the preferred phone number
on the spot when you ask for it:

&gt;&gt;&gt; obj.preferred_phone_number

This object is stored under `preferred_phone_number` so in the future it already has the object
when something asks for it again.

### Auto Prefetch Children
[auto-prefetch-children]: #auto-prefetch-children

You can also pre-fetch these child objects in bulk if you have a collection of model objects (such
as a `List` of `some_lib.account.Account`&#39;s) via `xmodel.children.bulk_request_lazy_children`.
This is much more efficient if you have a lot of objects because it can grab many of the children
pre-request.

.. todo:: At some point the xmodel-rest will probably fetch many child objects lazily in bulk.
    When someone accesses one lazily, it could grab more for other Model objects that don&#39;t have
    their children fetched yet. We just put in a weak-ref cache, so using this we could
    find the ones that we have fetched in the past and and are still around.
    We could fetch their children too at the same time in the same request in bulk
    (ie: so we fetch original child requested, along with 50 more or so via a single request).


You can also have the xmodel do this automatically as it receives pages of objects via
`xmodel.options.ApiOptions.auto_get_child_objects` like so:

&gt;&gt;&gt; Account.api.options.auto_get_child_objects = True

This sets this option for this Model type in the current `xinject.context.XContext`.
If you make a new XContext, and then throw the XContext away, it will revert these option changes.

&gt;&gt;&gt; from xinject.context import XContext
&gt;&gt;&gt;
&gt;&gt;&gt; # Starts out as False....
&gt;&gt;&gt; assert not Account.api.options.auto_get_child_objects
&gt;&gt;&gt;
&gt;&gt;&gt; with XContext():
...     Account.api.options.auto_get_child_objects = True
...     # Returned generator will &#39;remember&#39; the options at time of creation
...     accounts_gen_with_children_pre_fetched = Account.api.get(top=100)
&gt;&gt;&gt;
&gt;&gt;&gt; # After XContext is gone, it reverts back to what it was before
&gt;&gt;&gt; assert not Account.api.options.auto_get_child_objects

You can use this to grab all of the accounts. The below returns a Generator and will grab a page
of Account objects at a time, but still returning each object individually via the generator.

&gt;&gt;&gt; [account.id for account in Account.api.get()]
[1, 2, 3, 4, 5, 118, 127, ...]

This is to help limit memory usage. It will also allow the sdk to asynchronously grab multiple
pages in the future [pre-fetch them] without changing the sdk&#39;s public interface to other projects.

.. todo:: Asynchronously pre-fetch pages of objects as the generator iterates though result set.

## Caching

There is a strong-ref and weak-ref caching system in the ORM you can take advantage of,
depending on the situation.

By default, they are both disabled.  They are explicitly an opt-in feature.

### Strong-Ref Caching

You can enable strong-ref caching in three ways currently:

-  Set it on directly on `xmodel.base.api.BaseApi.options.cache_by_id=True`

-  Set `cache_by_id=True` as one of the model classes options, like so:

&gt;&gt;&gt; from xmodel import ApiOptions
&gt;&gt;&gt; class MyModel(RestModel[&#39;MyModel&#39;], api_options=ApiOptions(cache_by_id=True)):
...     account_id: int
...     number: str
...     description: str
...     is_active: bool


-  Via a subclass of a structure, such as `xmodel.rest.RestStructure`,
   and setting it&#39;s `xmodel.base.structure.BaseStructure.api_options` to a default set
   that are used by default for new Model sub-classes that use that Structure subclass.
   Here is an example:

&gt;&gt;&gt; from typing import TypeVar
&gt;&gt;&gt; from xmodel import Field
&gt;&gt;&gt;
&gt;&gt;&gt; F = TypeVar(name=&#34;F&#34;, bound=Field)
&gt;&gt;&gt; class AlwaysEnableCacheByIDStructure(RestStructure[F]):
...     # todo: Have ability to set a default value for api_options on the Api class
...     #   Right now you can only set this on a Model or Structure class.
...     api_options = ApiOptions(cache_by_id=True)

The strong cache is useful for caching objects that almost never change.


### Weak-Ref Caching

Caching objects weakly is also disabled by default.

The weak-caching is nice, because there are situations where various object will reference
the same object. Take for instance order and order-lines.  The order-lines would have a
one-to-one relationship back to the order object, and there is no need to lookup the same
order object over and over again if you ask each order-line for it&#39;s order-object.

This is where the weak-cache can shine. The ORM can store temporary references to objects
by &#39;id&#39; and check this cache to retrieve them later instead of having to do an actual
fetch-request.

Another place this can be useful is when query objects that are in a tree.
And objects parent could be referenced by several children.

You can enable weak-caching via the `xmodel.weak_cache_pool.WeakCachePool`.
`xmodel` imports this, so you can import it easily via:

&gt;&gt;&gt; from xmodel import WeakCachePool

There is an enable property on it that you set to `True` to enable the caching.
See `xmodel.weak_cache_pool.WeakCachePool.enable`.

It&#39;s a `xinject.context.Dependency`, and so can be used like any other normal resource.
You can set the enable property on the current resource to make it more permently on.

&gt;&gt;&gt; WeakCachePool.grab().enabled = True

Or you can temporarly enable it by creating a new `xmodel.weak_cache_pool.WeakCachePool`
object and activating it temporarily.

&gt;&gt;&gt; from xmodel import WeakCachePool
&gt;&gt;&gt; @WeakCachePool(enabled=True)
&gt;&gt;&gt; def lambda_event_handler(event, context):
...    pass

The most recent WeakCachePool is the one that is used, and the weak refrences are stored inside it.
So when a WeakCachePool is deactivated and thrown-away, it will forgot anything that was weakly
cached in it. Same thing happens when activating a new WeakCachePool, it will not use the
previous pool for anything until the new WeakCachePool is deactivated.

This means, when you activate a new WeakCachePool, you are gurateed to always request new
objects instead of using previously cached ones.

&#34;&#34;&#34;

from .base import (
    BaseModel, BaseApi, BaseStructure
)
from .base.fields import Field, Converter
from .errors import XModelError
from .json import JsonModel
from .remote.weak_cache_pool import WeakCachePool


__all__ = [
    &#39;BaseModel&#39;,
    &#39;BaseApi&#39;,
    &#39;BaseStructure&#39;,
    &#39;Field&#39;,
    &#39;Converter&#39;,
    &#39;XModelError&#39;,
    &#39;JsonModel&#39;
]

__version__ = &#39;0.2.0&#39;</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="xmodel.base" href="base/index.html">xmodel.base</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel.common" href="common/index.html">xmodel.common</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel.converters" href="converters.html">xmodel.converters</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel.errors" href="errors.html">xmodel.errors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel.json" href="json.html">xmodel.json</a></code></dt>
<dd>
<div class="desc"><p>The purpose of the JsonModel is to be able to create model classes from json data we have
retrieved from somewhere that is not an API endpoint or as a â€¦</p></div>
</dd>
<dt><code class="name"><a title="xmodel.remote" href="remote/index.html">xmodel.remote</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel.BaseApi"><code class="flex name class">
<span>class <span class="ident">BaseApi</span></span>
<span>(</span><span>*, api:Â <a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a>[M]Â =Â None, model:Â <a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a>Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is a sort of "Central Hub" that ties all intrested parties together.</p>
<p>You can get the correct instance via <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.</p>
<p>In order to reduce any name-collisions for other normal Model attributes, everything
related to the BaseApi that the <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> needs is gotten though via
this class.</p>
<p>You can get the BaseApi instance related to the model via
<code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; obj = BaseModel.api.get_via_id(1)
</code></pre>
<p>For more information see <a href="#api-class-overview">BaseApi Class Overview</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;You can probably skip the rest (below)</p>
<p>Most of the time you don't create <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code> objects your self, and so for most people
you can skip the following unless you want to know more about internal details.</p>
</div>
<h1 id="init-method-specifics">Init Method Specifics</h1>
<p>Normally you would not create an <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code> object directly your self.
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s know how to do this automatically.
It happens in <code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="base/model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code>.</p>
<p>Details about how the arguments you can pass are below.</p>
<h2 id="basemodel-class-construction">BaseModel Class Construction:</h2>
<p>If you provide an <code>api</code> arg without a <code>model</code> arg; we will copy the <code><a title="xmodel.BaseApi.structure" href="#xmodel.BaseApi.structure">BaseApi.structure</a></code>
into new object, resetting the error status, and internal <code>BaseApi._state</code> to None.
This <code>api</code> object is supposed to be the parent BaseModel's class api object.</p>
<p>If both <code>api</code> arg + <code>model</code> arg are <code>None</code>, the BaseModel is the root/generic BaseModel
(ie: it has no parent BaseModel).</p>
<p>This is what is done by BaseModel classes while the class is lazily loading and
creating/configuring the BaseModel class and it's associated <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code> object
(accessible via <code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>)</p>
<h2 id="basemodel-instance-creation">BaseModel Instance Creation:</h2>
<p>If you also pass in a <code>model</code> arg; this get you a special copy of the api you passed in
for use just with that BaseModel instance. The model <code>BaseApi._state</code> will be allocated
internally in the init'd BaseApi object. This is how a <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance get's it's own associated <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code> object
(that's a different instance vs the one set on BaseModel class when the BaseModel class
was originally constructed).</p>
<p>All params are optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>
<p>The "parent" BaseApi obj to copy the basic structure from as a starting point,
etc.
The superclasses BaseApi class is passed via this arg.
This is only used when allocating a new <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code> object for a new
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> class (not an instance, a model class/type).
This BaseApi object is used for the class-level BaseModel api object;
ie: via "ModelClass.api"</p>
<p>See above "BaseModel Class Construction" for more details.</p>
</dd>
<dt><strong><code>model</code></strong></dt>
<dd>
<p>BaseModel to associate new BaseApi obj with.
This is only used to create a new BaseApi object for a
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance for an already-existing type. ie: for BaseModel object instances.</p>
<p>See above "BaseModel Instance Creation" for more details.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseApi(Generic[M]):
    &#34;&#34;&#34;
        This class is a sort of &#34;Central Hub&#34; that ties all intrested parties together.

        You can get the correct instance via `xmodel.base.model.BaseModel`.

        In order to reduce any name-collisions for other normal Model attributes, everything
        related to the BaseApi that the `xmodel.base.model.BaseModel` needs is gotten though via
        this class.

        You can get the BaseApi instance related to the model via
        `xmodel.base.model.BaseModel.api`.

        Example:

        &gt;&gt;&gt; obj = BaseModel.api.get_via_id(1)

        For more information see [BaseApi Class Overview](#api-class-overview).
    &#34;&#34;&#34;

    # Defaults Types to use. When you sub-class BaseApi, you can declare/override these type-hints
    # and specify a different type... The system will allocate and use that new type instead
    # for you automatically on any instances created of the class.
    #
    # The BaseAuth won&#39;t modify the request to add auth; so it&#39;s safe to use as the base default.
    #
    # These are implemented via `@property` methods further below, but these are the type-hints.
    #
    # The properties and the __init__ method all use these type-hints in order to use the correct
    # type for each one on-demand as needed. For details on each one, see the @property method(s).
    #
    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. I get around this bug by using a
    # different initial-name for the property by pre-pending a `_` to it,
    # and then setting it to the correct name later.
    #
    # Example: `structure = _structure` is done after `def _structure(...)` is defined.

    # See `_structure` method for docs and method that gets this value.
    structure: BaseStructure[Field]

    @property
    def _structure(self):
        &#34;&#34;&#34;
        Contain things that don&#39;t vary among the model instances;
        ie: This is the same object and applies to all instances of a particular BaseModel class.

        This object has a list of `xmodel.fields.Field` that apply to the
        `xmodel.base.model.BaseModel` you can get via
        `xmodel.base.structure.Structure.fields`; for example.

        This is currently created in `BaseApi.__init__`.

        BaseApi instance for a BaseModel is only created when first asked for via
        `xmodel.base.model.BaseModel.api`.

        Returns:
            BaseStructure: Structure with correct field and model type in it.
        &#34;&#34;&#34;
        return self._structure

    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. This gets around it since pycharm
    # can&#39;t figure out what&#39;s going on here.
    structure = _structure

    _structure = None
    &#34;&#34;&#34; See `BaseApi.structure`.
    &#34;&#34;&#34;

    # ------------------------------
    # --------- Properties ---------

    default_converters: Dict[Type[Any], Converter] = None
    &#34;&#34;&#34;
    For an overview of type-converts, see
    [Type Converters Overview](./#type-converters).

    The class attribute defaults to `None`, but an instance/object will always have
    some sort of dict in place (happens during init call).

    Notice the `todo` note in the [overview](./#type-converters). I want it to work that way in the
    future (so via `BaseApi.set_default_converter` and `BaseApi.get_default_converter`).
    It&#39;s something coming in the future. For now you&#39;ll need to override
    `default_converters` and/or change it directly.

    You can provide your own values for this directly in a sub-class,
    when an BaseApi or subclass is created, we will merge converters in this order,
    with things later in the order taking precedence and override it:

    1. `xmodel.converters.DEFAULT_CONVERTERS`
    2. `BaseApi.default_converters` from `xmodel.base.model.BaseModel.api` from parent model.
        The parent model is the one the model is directly inheriting from.
    3. Finally, `BaseApi.default_converters` from the BaseApi subclass&#39;s class attribute
       (only looks on type/class directly for `default_converters`).

    It takes this final mapping and sets it on `self.default_converters`,
    and will be inherited as explained on on line number `2` above in the future.

    Default converters we have defined at the moment:

    - `xmodel.converters.convert_json_date`
    - `xmodel.converters.convert_json_datetime`
    - And a set of basic converters via `xmodel.converters.ConvertBasicType`, supports:
        - float
        - bool
        - str
        - int

    See `xmodel.converters.DEFAULT_CONVERTERS` to see the default converters map/dict.

    Maps type-hint to a default converter.  This converter will be used for `TypeValue.convert`
    when the model BaseStructure is create if none is provided for it at field definition time
    for a particular type-hint. If a type-hint is not in this converter, no convert is
    called for it.

    You don&#39;t need to provide one of these for a `xmodel.base.model.BaseModel` type-hint,
    as the system knows to call json/update_from_json on those types of objects.

    The default value provides a way to convert to/from a dt.date/dt.datetime and a string.
    &#34;&#34;&#34;

    # def set_default_converter(self, type, converter):
    #     &#34;&#34;&#34; NOT IMPLEMENTED YET -
    #     .. Todo:: Josh: These were here to look up a converter from a parent if a child does not
    #         have one  I have not figured out what I want to do here quite yet...
    #
    #         See todo at [Type Converters](./#type-converters) for an explanation of what this may
    #         be in the future.
    #
    #     &#34;&#34;&#34;
    #     raise NotImplementedError()
    #
    # def get_default_converter(self, type) -&gt; Optional[Converter]:
    #     &#34;&#34;&#34; NOT IMPLEMENTED YET -
    #     .. Todo:: Josh: These were here to look up a converter from a parent if a child does not
    #         have one  I have not figured out what I want to do here quite yet...
    #
    #         See todo at [Type Converters](./#type-converters) for an explanation of what this may
    #         be in the future.
    #     &#34;&#34;&#34;
    #     raise NotImplementedError()

    # ------------------------------
    # --------- Properties ---------

    @property
    def model_type(self) -&gt; Type[M]:
        &#34;&#34;&#34; The same BaseApi class is meant to be re-used for any number of Models,
            and so a BaseModel specifies it&#39;s BaseApi type as generic `BaseApi[M]`. In this case
            is the BaseModel it&#39;s self.  That way we can have the type-system aware that different
            instances of the same BaseApi class can specify different associated BaseModel classes.

            This property will return the BaseModel type/class associated with this BaseApi
            instance.
        &#34;&#34;&#34;
        # noinspection PyTypeChecker
        return self.structure.model_cls

    # ---------------------------
    # --------- Methods ---------

    # noinspection PyMissingConstructor
    def __init__(self, *, api: &#34;BaseApi[M]&#34; = None, model: BaseModel = None):
        &#34;&#34;&#34;

        .. warning:: You can probably skip the rest (below)
            Most of the time you don&#39;t create `BaseApi` objects your self, and so for most people
            you can skip the following unless you want to know more about internal details.

        # Init Method Specifics

        Normally you would not create an `BaseApi` object directly your self.
        `xmodel.base.model.BaseModel`&#39;s know how to do this automatically.
        It happens in `xmodel.base.model.BaseModel.__init_subclass__`.

        Details about how the arguments you can pass are below.

        ## BaseModel Class Construction:

        If you provide an `api` arg without a `model` arg; we will copy the `BaseApi.structure`
        into new object, resetting the error status, and internal `BaseApi._state` to None.
        This `api` object is supposed to be the parent BaseModel&#39;s class api object.

        If both `api` arg + `model` arg are `None`, the BaseModel is the root/generic BaseModel
        (ie: it has no parent BaseModel).

        This is what is done by BaseModel classes while the class is lazily loading and
        creating/configuring the BaseModel class and it&#39;s associated `BaseApi` object
        (accessible via `xmodel.base.model.BaseModel.api`)

        ## BaseModel Instance Creation:

        If you also pass in a `model` arg; this get you a special copy of the api you passed in
        for use just with that BaseModel instance. The model `BaseApi._state` will be allocated
        internally in the init&#39;d BaseApi object. This is how a `xmodel.base.model.BaseModel`
        instance get&#39;s it&#39;s own associated `BaseApi` object
        (that&#39;s a different instance vs the one set on BaseModel class when the BaseModel class
        was originally constructed).

        All params are optional.

        Args:
            api: The &#34;parent&#34; BaseApi obj to copy the basic structure from as a starting point,
                etc.
                The superclasses BaseApi class is passed via this arg.
                This is only used when allocating a new `BaseApi` object for a new
                `xmodel.base.model.BaseModel` class (not an instance, a model class/type).
                This BaseApi object is used for the class-level BaseModel api object;
                ie: via &#34;ModelClass.api&#34;

                See above &#34;BaseModel Class Construction&#34; for more details.

            model:  BaseModel to associate new BaseApi obj with.
                This is only used to create a new BaseApi object for a
                `xmodel.base.model.BaseModel`
                instance for an already-existing type. ie: for BaseModel object instances.

                See above &#34;BaseModel Instance Creation&#34; for more details.
        &#34;&#34;&#34;
        if api and model:
            raise XModelError(
                f&#34;You can&#39;t pass in an BaseApi {api} and BaseModel {model} simultaneously.&#34;
            )

        if model:
            api = type(model).api

        if not api:
            assert not model, &#34;You can&#39;t pass in a model without an associated api/model obj.&#34;

        if model:
            # If we have a model, the structure should be exactly the same as it&#39;s BaseModel type.
            self._structure = api.structure
            self._api_state = PrivateApiState(model=model)
            return

        # If We don&#39;t have a BaseModel, then we need to copy the structure, it could change
        # because we are being allocated for a new BaseModel type at the class/type level;
        # this means we are not associated with a specific BaseModel instance, only a BaseModel
        # type.

        # We lookup the structure type that our associated model-type/class wants to use.
        structure_type = get_type_hints(type(self)).get(
            &#39;structure&#39;,
            BaseStructure[Field]
        )

        args = typing_inspect.get_args(structure_type)
        field_type = args[0] if args else Field

        # We have a root BaseModel with the abstract BaseModel as its super class,
        # in this case we need to allocate a blank structure object.
        # todo: allocate structure with new args
        existing_struct = api.structure if api else None
        self._structure = structure_type(
            parent=existing_struct,
            field_type=field_type
        )

        # default_converters is a mapping of type to convert too, and a converter callable.
        #
        # We want to inherit from the parent and converters they already have defined.
        #
        # Take any parent converters as they currently exist, and use them as a basis for our
        # converters. Then take any converters directly assigned to self and override the any
        # parent converters, when they both have a converter for the same key/type.
        self.default_converters = {
            **DEFAULT_CONVERTERS,
            **(api.default_converters or {} if api else {}),
            **(type(self).default_converters or {}),
        }

    # ----------------------------------------------------
    # --------- Things REQUIRING an Associated BaseModel -----

    @property
    def model(self) -&gt; BaseModel[M]:
        &#34;&#34;&#34; REQUIRES associated model object [see doc text below].

        Gives you back the model associated with this api. If this BaseApi obj is associated
        directly with the BaseModel class type and so there is no associated model, I will
        raise an exception.

        Some BaseApi methods are dependant on having an associated model, and when they ask for it
        and there is None, this will raise an exception for them. The first line of the doc
        comment tells you if it needs one.  Normally, it&#39;s pretty obvious if the method
        will need the model, due to what it will return to you (ie: if it would need model attrs).

        The methods that are dependant on a model are ones, like &#39;json&#39;, where it returns the
        JSON for a model.  It needs a model to get this data.

        If you access an object api via a BaseModel object, that will be the associated model.
        If you access it via a BaseModel type/class, it will be directly associated with the model
        class.

        Examples:
        &gt;&gt;&gt; # Grab Account model from some_lib (as an example).
        &gt;&gt;&gt; from some_lib.account import Account
        &gt;&gt;&gt;
        &gt;&gt;&gt; # api object is associated with MyModelClass class, not model obj.
        &gt;&gt;&gt; Account.api
        &gt;&gt;&gt;
        &gt;&gt;&gt; account_obj = Account.api.get_via_id(3)
        &gt;&gt;&gt; # api is associated with the account_obj model object.
        &gt;&gt;&gt; account_obj.api
        &gt;&gt;&gt;
        &gt;&gt;&gt; # This sends object attributes to API, so it needs an associated
        &gt;&gt;&gt; # BaseModel object, so this works:
        &gt;&gt;&gt; account_obj.api.send()
        &gt;&gt;&gt;
        &gt;&gt;&gt; # This would produce an exception, since it would try to get BaseModel
        &gt;&gt;&gt; # attributes to send. But there is no associated model.
        &gt;&gt;&gt; Account.api.send()

        &#34;&#34;&#34;
        api_state = self._api_state
        assert api_state, &#34;BaseApi needs an attached model obj and there is no associated &#34; \
                          &#34;model api state.&#34;
        model = api_state.model
        assert model, &#34;BaseApi needs an attached model obj and there is none.&#34;
        return model

    def get_child_without_lazy_lookup(
            self,
            child_field_name,
            *,
            false_if_not_set=False,
    ) -&gt; Union[BaseModel[M], None, bool, NullType]:
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        If the child is current set to Null, or an object, returns that value.
        Will NOT lazily lookup child, even if its possible to do so.

        :param child_field_name: The field name of the child object.
        :param false_if_not_set:
            Possible Values [Default: False]:
                * False: Return None if nothing is currently set.
                * True:  Return False if nothing is currently set. This lets you distinguish
                  between having a None value set on field vs nothing set at all.
                  Normally this distinction is only useful internally in this class,
                  external users probably don&#39;t need this option.
        &#34;&#34;&#34;

        model = self.model

        if not self.structure.is_field_a_child(child_field_name):
            raise XModelError(
                f&#34;Called get_child_without_lazy_lookup(&#39;{child_field_name}&#39;) but &#34;
                f&#34;field ({child_field_name}) is NOT a child field on model ({model}).&#34;)

        if child_field_name in model.__dict__:
            return getattr(model, child_field_name)

        if false_if_not_set:
            return False

        return None

    @property
    def have_changes(self) -&gt; bool:
        &#34;&#34;&#34; Is True if `self.json(only_include_changes=True)` is not None;
            see json() method for more details.
        &#34;&#34;&#34;
        log.debug(f&#34;Checking Obj {self.model} to see if I have any changes [have_changes]&#34;)
        return self.json(only_include_changes=True) is not None

    def json(
        self, only_include_changes: bool = False, log_output: bool = False
    ) -&gt; Optional[JsonDict]:
        &#34;&#34;&#34; REQUIRES associated model object (see `BaseApi.model` for details on this).

        Return associated model object as a JsonDict (str keys, any value), ready to be encoded
        via JSON encoder and sent to the API.

        Args:
            only_include_changes: If True, will only include what changed in the JsonDict result.
                Defaults to False.
                This is normally set to True if system is sending this object via PATCH, which is
                the  normal way the system sends objects to API.

                If only_include_changes is False (default), we always include everything that
                is not &#39;None&#39;.
                When a `xmodel.base.client.BaseClient` subclass
                (such as `xmodel.rest.RestClient`)
                calls this method, it will pass in a value based on it&#39;s own
                `xmodel.rest.RestClient.enable_send_changes_only` is set to
                (defaults to False there too).
                You can override the RestClient.enable_send_changes_only at the BaseModel class
                level by making a RestClient subclass and setting `enable_send_changes_only` to
                default to `True`.

                There is a situations where we have to include all attributes, regardless:
                    1. If the &#39;id&#39; field is set to a &#39;None&#39; value. This indicates we need to create
                       a new object, and we are not partially updating an existing one, even if we
                       got updated via json at some point in the past.

                As always, properties set to None will *NOT* be included in returned JsonDict,
                regardless of what options have been set.

            log_output (bool): If False (default): won&#39;t log anything.
                If True: Logs what method returns at debug level.


        Returns:
            JsonDict: Will the needed attributes that should be sent to API.
                If returned value is None, that means only_include_changes is True
                and there were no changes.

                The returned dict is a copy and so can be mutated be the caller.
        &#34;&#34;&#34;

        # todo: Refactor _get_fields() to return getter/setter closures for each field, and we
        #       can make this whole method more generic that way. We also can &#39;cache&#39; the logic
        #       needed that way instead of having to figure it out each time, every time.

        structure = self.structure
        model = self.model
        api_state = self._api_state

        json: JsonDict = {}

        field_objs = structure.fields

        # Negate only_include_changes if we don&#39;t have any original update json to compare against.
        if only_include_changes and api_state.last_original_update_json is None:
            only_include_changes = False

        # noinspection PyDefaultArgument
        def set_value_into_json_dict(value, field_name, *, json=json):
            # Sets field value directly on json dict or passed in dict...
            if value is not None:
                # Convert Null into None (that&#39;s how JSON converter represents a Null).
                json[field_name] = value if value is not Null else None

        for field_obj in field_objs:
            # If we are read-only, no need to do anything more.
            if field_obj.read_only:
                continue

            # We deal with non-related types later.
            related_type = field_obj.related_type
            if not related_type:
                continue

            f = field_obj.name
            if field_obj.read_only:
                continue

            # todo: For now, the &#39;api-field-path&#39; option can&#39;t be used at the same time as obj-r.
            if field_obj.json_path != field_obj.name:
                # I&#39;ve put in some initial support for this below, but it&#39;s has not been tested
                # for now, keep raising an exception for this like we have been.
                # There is a work-around, see bottom part of the message in the below error:
                raise NotImplementedError(
                    f&#34;Can&#39;t have xmodel.Field on BaseModel with related-type and a json_path &#34;
                    f&#34;that differ at the moment, for field ({field_obj}). &#34;
                    f&#34;It is something I want to support someday; the support is mostly in place &#34;
                    f&#34;already, but it needs some more careful thought, attention and testing &#34;
                    f&#34;before we should allow it. &#34;
                    &#34;Workaround:  Make an `{field.name}_id` field next to related field on the &#34;
                    &#34;model. Then, set `json_path` for that `{field.name}_id` field, set it to &#34;
                    &#34;what you want it to be. Finally, set the `{related_field.name}` to &#34;
                    &#34;read_only=True. This allows you to rename the `_id` field used to/from api &#34;
                    &#34;in the JSON input/output, but the Model can have an alternate name for the &#34;
                    &#34;related field. You can see a real-example of this at &#34;
                    &#34;`bigcommerce.api.orders._BcCommonOrderMetafield.order&#34;
                )

            obj_type_structure = related_type.api.structure
            obj_type_has_id = obj_type_structure.has_id_field()

            if obj_type_has_id:
                # If the obj uses an &#39;id&#39;, then we have a {field_name}_id we want to
                # send instead of the full object as a json dict.
                #
                # This will grab the id from child obj if it exists, or from a defined field
                # of f&#34;{f}_id&#34; or finally from related id storage.

                # todo: If there is an object with no &#39;id&#39; value, do we ignore it?
                #   or should we embed full object anyway?

                child_obj_id = api_state.get_related_field_id(f)

                # Method below should deal with None vs Null.
                set_value_into_json_dict(child_obj_id, f&#34;{f}_id&#34;)
            else:
                obj: &#39;BaseModel[M]&#39; = getattr(model, f)

                # Related-object has no &#39;id&#39;, so get it&#39;s json dict and set that into the output.
                v = obj
                if obj is not Null and obj is not None:
                    # todo: a Field option to override this and always provide all
                    #   values (if object always needs to be fully embedded).
                    v = obj.api.json(only_include_changes=only_include_changes)

                # if it returns None (ie: no changes) and only_include_changes is enabled,
                # don&#39;t include the sub-object as a change.
                if v is not None or not only_include_changes:
                    # Method below should deal with None vs Null.
                    set_value_into_json_dict(v, f)

        for field_obj in field_objs:
            # If we are read-only, no need to do anything more.
            if field_obj.read_only:
                continue

            # We don&#39;t deal with related-types here.
            if field_obj.related_type:
                continue

            f = field_obj.name
            v = getattr(model, f)
            if v is not None and field_obj.converter:
                # Convert the value....
                v = field_obj.converter(
                    api=self,
                    direction=Converter.Direction.to_json,
                    field=field_obj,
                    value=v
                )

            path = field_obj.json_path
            if not path:
                set_value_into_json_dict(v, f)
                continue

            path_list = path.split(field_obj.json_path_separator)
            d = json
            for name in path_list[:-1]:
                d = d.setdefault(name, {})
            name = path_list[-1]

            # Sets field value into a sub-dictionary of the original `json` dict.
            set_value_into_json_dict(v, name, json=d)

        # If the `last_original_update_json` is None, then we never got update via JSON
        # so there is nothing to compare, include everything!
        if only_include_changes:
            log.debug(f&#34;Checking Obj {model} for changes to include.&#34;)
            fields_to_pop = self.fields_to_pop_for_json(json, field_objs, log_output)

            for f in fields_to_pop:
                del json[f]

            if not json:
                # If nothing in JSON, then return None.
                return None
        else:
            due_to_msg = &#34;unknown&#34;
            if not only_include_changes:
                due_to_msg = &#34;only_include_changes is False&#34;
            if api_state.last_original_update_json is None:
                due_to_msg = &#34;no original json value&#34;

            if log_output:
                log.debug(f&#34;Including everything for obj {model} due to {due_to_msg}.&#34;)

                # Log out at debug level what we are including in the JSON.
                for field, new_value in json.items():
                    log.debug(
                        f&#34;   Included field ({field}) value ({new_value})&#34;
                    )

        for k, v in json.items():
            # Must use list of JSON, convert any sets to a list.
            if type(v) is set:
                v = list(v)
                json[k] = v

        return json

    def fields_to_pop_for_json(
            self, json: dict, field_objs: List[Field], log_output: bool
    ) -&gt; Set[Any]:
        &#34;&#34;&#34;
        Goes through the list of fields (field_objs) to determine which ones have not changed in
        order to pop them out of the json representation. This method is used when we only want to
        include the changes in the json.

        :param json: dict representation of a model&#39;s fields and field values as they are currently
            set on the model.
        :param field_objs: List of fields and their values for a model
        :param log_output: boolean to determine if we should log the output or not
        :return: The field keys to remove from the json representation of the model.
        &#34;&#34;&#34;
        fields_to_pop = set()
        for field, new_value in json.items():

            # json has simple strings, numbers, lists, dict;
            # so makes general comparison simpler.
            old_value = self._get_old_json_value(field=field, as_type=type(new_value))

            if old_value is Default:
                if log_output:
                    log.debug(
                        f&#34;   Included field ({field}) with value &#34;
                        f&#34;({new_value}) because there is no original json value for it.&#34;
                    )
            elif self.should_include_field_in_json(
                    new_value=new_value,
                    old_value=old_value,
                    field=field
            ):
                if log_output:
                    log.debug(
                        f&#34;   Included field ({field}) due to new value &#34;
                        f&#34;({new_value}) != old value ({old_value}).&#34;
                    )
            else:
                # We don&#39;t want to mutate dict while traversing it, remember this for later.
                fields_to_pop.add(field)

        # Map a field-key to what other fields should be included if field-key value is used.
        # For now we are NOT supporting `Field.json_path` to keep things simpler
        # when used in conjunction with `Field.include_with_fields`.
        # `Field` will raise an exception if json_path != field name and include_with_fields
        # is used at the same time.
        # It&#39;s something I would like to support in the future, but for now it&#39;s not needed.
        # We can assume that `field_obj.name == field_obj.json_path`
        for field_obj in field_objs:
            if not field_obj.include_with_fields:
                continue
            if field_obj.name not in fields_to_pop:
                continue
            if not (field_obj.include_with_fields &lt;= fields_to_pop):
                fields_to_pop.remove(field_obj.name)

        return fields_to_pop

    def should_include_field_in_json(self, new_value: Any, old_value: Any, field: str) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the the value for field should be included in the JSON.
        This only gets called if only_include_changes is True when passed to self.json::

            # Passed in like so:
            self.json(only_include_changes=True)

        This method is an easy way to change the comparison logic.

        :param new_value: New value that will be put into JSON.
        :param old_value:
            Old value originals in original JSON [normalized if possible to the same type as
            new_value.
        :param field: Field name.
        :return:
            If True: Will include the fields value in an update.
            If False: Won&#39;t include the fields value in an update.
        &#34;&#34;&#34;
        # Convert old value to set if new value is set and old value is list (from original JSON).
        # If I was really cool :)... I would find out the inner type in case of int/str
        # and to a conversion to compare Apples to Apples.....
        # But trying to minimize changes so I don&#39;t conflict as much with soon to be
        # xmodel-dynamo feature.
        if type(new_value) is set and type(old_value) is list:
            old_value = set(old_value)

        return new_value != old_value

    def _get_old_json_value(self, *, field: str, as_type: Type = None) -&gt; Optional[Any]:
        &#34;&#34;&#34; Returns the old field-values; Will return `Default` if there is no original value.  &#34;&#34;&#34;
        original_json = self._api_state.last_original_update_json
        if original_json is None:
            # todo: Is there another value we could return here to indicate that we
            #       never got an original value in the first place?
            #
            # todo: Also, think about how we could do above todo ^ per-field
            #       [ie: if field was requested in the first place].
            return Default

        old_value = original_json.get(field, Default)
        if old_value is Default:
            # None is a valid value in JSON,
            # this indicates to do the Default thing/value with this field since we don&#39;t have any
            # original value for it.
            return Default

        # json has simple strings, numbers, lists, dict;
        # so makes general comparison simpler.
        old_type = type(old_value)
        if as_type != old_type:
            str_compatible_types = {str, int, float}
            if as_type in str_compatible_types and old_type in str_compatible_types:
                try:
                    # The &#39;id&#39; field is a string and not an int [for example], so in
                    # general, we want to try and convert the old value into the new
                    # values type before comparison, if possible, for the basic types
                    # of str, int, float.
                    old_value = as_type(old_value)
                except ValueError:
                    # Just be sure it&#39;s the same value/type, should be but just in case.
                    old_value = original_json.get(field, None)
                    pass
        return old_value

    def copy_from_model(self, model: BaseModel):
        their_fields = model.api.structure.field_map
        my_fields = self.structure.field_map
        keys = [k for k in their_fields if k in my_fields]

        # Assume we have a model, and are not the class-based `MyModel.api....` version.
        # todo: have `self.model` raise an exception if called on the class api version
        #   (which does not have a related model, just knows about model-type.).
        my_model = self.model
        for k in keys:
            their_value = getattr(model, k)
            if their_value is not None:
                setattr(my_model, k, their_value)

    def update_from_json(self, json: Union[JsonDict, Mapping]):
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        todo: Needs more documentation

        We update the dict per-key, with what we got passed in [via &#39;json&#39; parameter]
        overriding anything we got previously. This also makes a copy of the dict, which is
        want we want [no change to modify the incoming dict parameter].
        &#34;&#34;&#34;

        structure = self.structure
        model = self.model
        api_state = self._api_state

        if not isinstance(json, Mapping):
            raise XModelError(
                f&#34;update_from_json(...) was given a non-mapping parameter ({json}).&#34;
            )

        # Merge the old values with the new values.
        api_state.last_original_update_json = {
            **(api_state.last_original_update_json or {}),
            **json
        }

        fields = structure.fields

        values = {}
        for field_obj in fields:
            path_list = field_obj.json_path.split(field_obj.json_path_separator)
            v = json
            got_value = True
            for name in path_list:
                if name not in v:
                    # We don&#39;t even have a &#39;None&#39; value so we assume we just did not get the value
                    # from the api, and therefore we just skip doing anything with it.
                    got_value = False
                    break

                v = v.get(name)
                if v is None:
                    break

            # We map the value we got from JSON into a flat-dict with the BaseModel name as the
            # key...
            if got_value:
                values[field_obj.name] = v if v is not None else Null

        def set_attr_on_model(field, value, model=model):
            &#34;&#34;&#34; Closure to set attr on self unless value is None.
            &#34;&#34;&#34;
            if value is None:
                return
            setattr(model, field, value)

        # Merge in the outer json, keeping the values we mapped [via Field.json_path] for conflicts
        values = {**json, **values}

        # todo: If the json does not have a value [not even a &#39;None&#39; value], don&#39;t update?
        #       We may have gotten a partial update?  For now, always update [even to None]
        #       all defined fields regardless if they are inside the json or not.

        for field_obj in fields:
            # We deal with related types later....
            if field_obj.related_type:
                continue

            f = field_obj.name
            v = values.get(f, Default)

            # A None from JSON means a Null for us.
            # If JSON does not include anything, that&#39;s a None for us.
            if v is None:
                v = Null
            elif v is Default:
                v = None

            # Run the converter if needed.
            # If we have a None value, we don&#39;t need to convert that, there was no value to
            # convert.
            if field_obj.converter and v is not None:
                v = field_obj.converter(
                    self,
                    Converter.Direction.from_json,
                    field_obj,
                    v
                )

            set_attr_on_model(f, v)

        for field_obj in fields:
            # Ok, now we deal with related types...
            related_type = field_obj.related_type
            if not related_type:
                continue

            f = field_obj.name

            # todo: at some point, allow customization of this via Field class
            #   Also, s tore the id
            f_id_name = f&#34;{f}_id&#34;
            if typing_inspect.get_origin(field_obj.type_hint) is list:
                # todo: This code is not complete [Kaden never finished it up]
                #   for now, just comment out.

                raise NotImplementedError(
                    &#34;Type-hints for xmodel models in this format: `attr: List[SomeType]` &#34;
                    &#34;are not currently supported. We want to support it someday. For now you &#34;
                    &#34;must use lower-cased non-generic `list`. At some point the idea is to &#34;
                    &#34;allow one to do `List[ChildModel]` and then we know it&#39;s a list of &#34;
                    &#34;other BaseModel objects and automatically handle that in some way.&#34;
                )

                # child_type: &#39;Type[BaseModel[M]]&#39;
                # child_type = typing_inspect.get_args(obj_type)
                # # __args__ returns a tuple of all arguments passed into List[] so we need to
                # # pull the class out of the tuple
                # if child_type:
                #     child_type = child_type[0]
                #
                # child_api: BaseApi
                # child_api = child_type.api
                # if not child_api and child_api.structure.has_id_field:
                #     # TODO: add a non generic Exception for this
                #     raise XModelError(
                #         f&#34;{model} has an attribute with name ({f}) with type-hint List that &#34;
                #         f&#34;doesn&#39;t contain an API BaseModel Type as the only argument&#34;
                #     )
                # parent_name = model.__class__.__name__.lower()
                # state.set_related_field_id(f, parent_name)
                # continue

            v = None
            if f in values:
                v = values.get(f, Null)
                if v is not Null:
                    v = related_type(v)

            # Check to see if we have an api/json field for object relation name with &#34;_id&#34; on
            # end.
            if v is None and related_type.api.structure.has_id_field():
                # If we don&#39;t have a defined field for this value, check JSON for it and store it.
                #
                # If we have a defined None value for the id field, meaning the field exists
                # in the json, and is set directly to None, then we have a Null relationship.
                # We set that as the value, since there is no need to &#39;lookup&#39; a null value.
                f_id_value = json.get(f_id_name)
                id_field = structure.get_field(f_id_name)

                if not id_field:
                    id_field = field_obj.related_type.api.structure.get_field(&#39;id&#39;)

                # Run the converter if needed.
                # If we have a None value, we don&#39;t need to convert that, there was no value to
                # convert.
                if id_field and id_field.converter and f_id_value is not None:
                    f_id_value = id_field.converter(
                        self,
                        Converter.Direction.from_json,
                        id_field,
                        f_id_value
                    )

                if f_id_value is None and f_id_name in json:
                    # We have a Null situation.
                    f_id_value = Null

                if f_id_value is not None:
                    # We have an id!
                    # Set the value to support automatic lookup of value, lazily.
                    # This method also takes care to set child object to Null or delete it
                    # as needed depending on the f_id_value and what the child&#39;s id field value is.
                    api_state.set_related_field_id(f, f_id_value)
            else:
                # &#39;v&#39; is either going to be None, Null or an BaseModel object.
                set_attr_on_model(f, v)

    def list_of_attrs_to_repr(self) -&gt; List[str]:
        &#34;&#34;&#34;&#34; REQUIRES associated model object [see self.model].

        A list of attribute names to put into the __repr__/string representation
        of the associated model object. This is consulted when the BaseModel has __repr__
        called on it.
        &#34;&#34;&#34;
        names = set()
        model = self.model

        # todo: Move this into pres-club override of list_of_attrs_to_repr in an BaseApi subclass.
        if hasattr(model, &#39;account_id&#39;):
            names.add(&#39;account_id&#39;)

        # todo: Consider adding others here, perhaps all defined fields on model that have
        # todo: a non-None value?

        for f in self.structure.fields:
            if f.include_in_repr:
                names.add(f.name)
        return list(names)

    def forget_original_json_state(self):
        &#34;&#34;&#34; If called, we forget/reset the orginal json state, which is a combination
            of all the json that this object has been updated with over it&#39;s lifetime.

            The json state is what allows the object to decide what has changed,
            when it&#39;s requested to only include changes via the `BaseApi.json` method.

            If forgotten, it&#39;s as-if we never got the json in the first place to compare against.
            Therefore, all attributes that have values will be returned for this object
            when it&#39;s only requested to include changes
            (the RestClient in xmodel-rest can request it to do this, as an example).

            Resetting the state here only effects this object, not any child objects.
            You&#39;ll have to ask child objects directly to forget t heir original json, if desired.
        &#34;&#34;&#34;
        self._api_state.last_original_update_json = None

    # ----------------------------
    # --------- Private ----------
    #
    # I want to make the state and structure private for now, because it might change a bit later.
    # Want to give this some opportunity to be used for a while to see where the areas for
    # improvement are before potentially opening it up publicly to things outside of the sdk.

    _api_state: PrivateApiState[M] = None
    &#34;&#34;&#34; This object will vary from BaseModel class instance-to-instance, and is the area we keep
        api state that is Private for the BaseModel instance.

        Will be None if we are directly associated with BaseModel class, otherwise this will be the
        BaseModel&#39;s instance state, methods in this object need the BaseModel instance.
    &#34;&#34;&#34;

    @property
    def context(self) -&gt; XContext:
        &#34;&#34;&#34; BaseApi context to use when asking this object to send/delete/etc its self to/from
            service.

            This is an old hold-over from when we used to keep a XContext reference.
            This is the same as calling `xinject.context.XContext.current`.
        &#34;&#34;&#34;
        return XContext.grab()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.remote.api.RemoteApi" href="remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.BaseApi.default_converters"><code class="name">var <span class="ident">default_converters</span> :Â Dict[Type[Any],Â <a title="xmodel.base.fields.Converter" href="base/fields.html#xmodel.base.fields.Converter">Converter</a>]</code></dt>
<dd>
<div class="desc"><p>For an overview of type-converts, see
<a href="./#type-converters">Type Converters Overview</a>.</p>
<p>The class attribute defaults to <code>None</code>, but an instance/object will always have
some sort of dict in place (happens during init call).</p>
<p>Notice the <code>todo</code> note in the <a href="./#type-converters">overview</a>. I want it to work that way in the
future (so via <code>BaseApi.set_default_converter</code> and <code>BaseApi.get_default_converter</code>).
It's something coming in the future. For now you'll need to override
<code>default_converters</code> and/or change it directly.</p>
<p>You can provide your own values for this directly in a sub-class,
when an BaseApi or subclass is created, we will merge converters in this order,
with things later in the order taking precedence and override it:</p>
<ol>
<li><code>xmodel.converters.DEFAULT_CONVERTERS</code></li>
<li><code><a title="xmodel.BaseApi.default_converters" href="#xmodel.BaseApi.default_converters">BaseApi.default_converters</a></code> from <code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> from parent model.
The parent model is the one the model is directly inheriting from.</li>
<li>Finally, <code><a title="xmodel.BaseApi.default_converters" href="#xmodel.BaseApi.default_converters">BaseApi.default_converters</a></code> from the BaseApi subclass's class attribute
(only looks on type/class directly for <code>default_converters</code>).</li>
</ol>
<p>It takes this final mapping and sets it on <code>self.default_converters</code>,
and will be inherited as explained on on line number <code>2</code> above in the future.</p>
<p>Default converters we have defined at the moment:</p>
<ul>
<li><code><a title="xmodel.converters.convert_json_date" href="converters.html#xmodel.converters.convert_json_date">convert_json_date()</a></code></li>
<li><code><a title="xmodel.converters.convert_json_datetime" href="converters.html#xmodel.converters.convert_json_datetime">convert_json_datetime()</a></code></li>
<li>And a set of basic converters via <code><a title="xmodel.converters.ConvertBasicType" href="converters.html#xmodel.converters.ConvertBasicType">ConvertBasicType</a></code>, supports:<ul>
<li>float</li>
<li>bool</li>
<li>str</li>
<li>int</li>
</ul>
</li>
</ul>
<p>See <code>xmodel.converters.DEFAULT_CONVERTERS</code> to see the default converters map/dict.</p>
<p>Maps type-hint to a default converter.
This converter will be used for <code>TypeValue.convert</code>
when the model BaseStructure is create if none is provided for it at field definition time
for a particular type-hint. If a type-hint is not in this converter, no convert is
called for it.</p>
<p>You don't need to provide one of these for a <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> type-hint,
as the system knows to call json/update_from_json on those types of objects.</p>
<p>The default value provides a way to convert to/from a dt.date/dt.datetime and a string.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.BaseApi.context"><code class="name">var <span class="ident">context</span> :Â <a title="xinject.context.XContext" href="../xinject/context.html#xinject.context.XContext">XContext</a></code></dt>
<dd>
<div class="desc"><p>BaseApi context to use when asking this object to send/delete/etc its self to/from
service.</p>
<p>This is an old hold-over from when we used to keep a XContext reference.
This is the same as calling <code><a title="xinject.context.XContext.current" href="../xinject/context.html#xinject.context.XContext.current">XContext.current()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; XContext:
    &#34;&#34;&#34; BaseApi context to use when asking this object to send/delete/etc its self to/from
        service.

        This is an old hold-over from when we used to keep a XContext reference.
        This is the same as calling `xinject.context.XContext.current`.
    &#34;&#34;&#34;
    return XContext.grab()</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.have_changes"><code class="name">var <span class="ident">have_changes</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Is True if <code>self.json(only_include_changes=True)</code> is not None;
see json() method for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def have_changes(self) -&gt; bool:
    &#34;&#34;&#34; Is True if `self.json(only_include_changes=True)` is not None;
        see json() method for more details.
    &#34;&#34;&#34;
    log.debug(f&#34;Checking Obj {self.model} to see if I have any changes [have_changes]&#34;)
    return self.json(only_include_changes=True) is not None</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.model"><code class="name">var <span class="ident">model</span> :Â <a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M]</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see doc text below].</p>
<p>Gives you back the model associated with this api. If this BaseApi obj is associated
directly with the BaseModel class type and so there is no associated model, I will
raise an exception.</p>
<p>Some BaseApi methods are dependant on having an associated model, and when they ask for it
and there is None, this will raise an exception for them. The first line of the doc
comment tells you if it needs one.
Normally, it's pretty obvious if the method
will need the model, due to what it will return to you (ie: if it would need model attrs).</p>
<p>The methods that are dependant on a model are ones, like 'json', where it returns the
JSON for a model.
It needs a model to get this data.</p>
<p>If you access an object api via a BaseModel object, that will be the associated model.
If you access it via a BaseModel type/class, it will be directly associated with the model
class.</p>
<p>Examples:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Grab Account model from some_lib (as an example).
&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt;
&gt;&gt;&gt; # api object is associated with MyModelClass class, not model obj.
&gt;&gt;&gt; Account.api
&gt;&gt;&gt;
&gt;&gt;&gt; account_obj = Account.api.get_via_id(3)
&gt;&gt;&gt; # api is associated with the account_obj model object.
&gt;&gt;&gt; account_obj.api
&gt;&gt;&gt;
&gt;&gt;&gt; # This sends object attributes to API, so it needs an associated
&gt;&gt;&gt; # BaseModel object, so this works:
&gt;&gt;&gt; account_obj.api.send()
&gt;&gt;&gt;
&gt;&gt;&gt; # This would produce an exception, since it would try to get BaseModel
&gt;&gt;&gt; # attributes to send. But there is no associated model.
&gt;&gt;&gt; Account.api.send()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; BaseModel[M]:
    &#34;&#34;&#34; REQUIRES associated model object [see doc text below].

    Gives you back the model associated with this api. If this BaseApi obj is associated
    directly with the BaseModel class type and so there is no associated model, I will
    raise an exception.

    Some BaseApi methods are dependant on having an associated model, and when they ask for it
    and there is None, this will raise an exception for them. The first line of the doc
    comment tells you if it needs one.  Normally, it&#39;s pretty obvious if the method
    will need the model, due to what it will return to you (ie: if it would need model attrs).

    The methods that are dependant on a model are ones, like &#39;json&#39;, where it returns the
    JSON for a model.  It needs a model to get this data.

    If you access an object api via a BaseModel object, that will be the associated model.
    If you access it via a BaseModel type/class, it will be directly associated with the model
    class.

    Examples:
    &gt;&gt;&gt; # Grab Account model from some_lib (as an example).
    &gt;&gt;&gt; from some_lib.account import Account
    &gt;&gt;&gt;
    &gt;&gt;&gt; # api object is associated with MyModelClass class, not model obj.
    &gt;&gt;&gt; Account.api
    &gt;&gt;&gt;
    &gt;&gt;&gt; account_obj = Account.api.get_via_id(3)
    &gt;&gt;&gt; # api is associated with the account_obj model object.
    &gt;&gt;&gt; account_obj.api
    &gt;&gt;&gt;
    &gt;&gt;&gt; # This sends object attributes to API, so it needs an associated
    &gt;&gt;&gt; # BaseModel object, so this works:
    &gt;&gt;&gt; account_obj.api.send()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # This would produce an exception, since it would try to get BaseModel
    &gt;&gt;&gt; # attributes to send. But there is no associated model.
    &gt;&gt;&gt; Account.api.send()

    &#34;&#34;&#34;
    api_state = self._api_state
    assert api_state, &#34;BaseApi needs an attached model obj and there is no associated &#34; \
                      &#34;model api state.&#34;
    model = api_state.model
    assert model, &#34;BaseApi needs an attached model obj and there is none.&#34;
    return model</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.model_type"><code class="name">var <span class="ident">model_type</span> :Â Type[~M]</code></dt>
<dd>
<div class="desc"><p>The same BaseApi class is meant to be re-used for any number of Models,
and so a BaseModel specifies it's BaseApi type as generic <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a>[M]</code>. In this case
is the BaseModel it's self.
That way we can have the type-system aware that different
instances of the same BaseApi class can specify different associated BaseModel classes.</p>
<p>This property will return the BaseModel type/class associated with this BaseApi
instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model_type(self) -&gt; Type[M]:
    &#34;&#34;&#34; The same BaseApi class is meant to be re-used for any number of Models,
        and so a BaseModel specifies it&#39;s BaseApi type as generic `BaseApi[M]`. In this case
        is the BaseModel it&#39;s self.  That way we can have the type-system aware that different
        instances of the same BaseApi class can specify different associated BaseModel classes.

        This property will return the BaseModel type/class associated with this BaseApi
        instance.
    &#34;&#34;&#34;
    # noinspection PyTypeChecker
    return self.structure.model_cls</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.structure"><code class="name">var <span class="ident">structure</span> :Â <a title="xmodel.base.structure.BaseStructure" href="base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a>[<a title="xmodel.base.fields.Field" href="base/fields.html#xmodel.base.fields.Field">Field</a>]</code></dt>
<dd>
<div class="desc"><p>Contain things that don't vary among the model instances;
ie: This is the same object and applies to all instances of a particular BaseModel class.</p>
<p>This object has a list of <code>xmodel.fields.Field</code> that apply to the
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> you can get via
<code>xmodel.base.structure.Structure.fields</code>; for example.</p>
<p>This is currently created in <code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code>.</p>
<p>BaseApi instance for a BaseModel is only created when first asked for via
<code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="xmodel.BaseStructure" href="#xmodel.BaseStructure">BaseStructure</a></code></dt>
<dd>Structure with correct field and model type in it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _structure(self):
    &#34;&#34;&#34;
    Contain things that don&#39;t vary among the model instances;
    ie: This is the same object and applies to all instances of a particular BaseModel class.

    This object has a list of `xmodel.fields.Field` that apply to the
    `xmodel.base.model.BaseModel` you can get via
    `xmodel.base.structure.Structure.fields`; for example.

    This is currently created in `BaseApi.__init__`.

    BaseApi instance for a BaseModel is only created when first asked for via
    `xmodel.base.model.BaseModel.api`.

    Returns:
        BaseStructure: Structure with correct field and model type in it.
    &#34;&#34;&#34;
    return self._structure</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.BaseApi.copy_from_model"><code class="name flex">
<span>def <span class="ident">copy_from_model</span></span>(<span>self, model:Â <a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_from_model(self, model: BaseModel):
    their_fields = model.api.structure.field_map
    my_fields = self.structure.field_map
    keys = [k for k in their_fields if k in my_fields]

    # Assume we have a model, and are not the class-based `MyModel.api....` version.
    # todo: have `self.model` raise an exception if called on the class api version
    #   (which does not have a related model, just knows about model-type.).
    my_model = self.model
    for k in keys:
        their_value = getattr(model, k)
        if their_value is not None:
            setattr(my_model, k, their_value)</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.fields_to_pop_for_json"><code class="name flex">
<span>def <span class="ident">fields_to_pop_for_json</span></span>(<span>self, json:Â dict, field_objs:Â List[<a title="xmodel.base.fields.Field" href="base/fields.html#xmodel.base.fields.Field">Field</a>], log_output:Â bool) â€‘>Â Set[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Goes through the list of fields (field_objs) to determine which ones have not changed in
order to pop them out of the json representation. This method is used when we only want to
include the changes in the json.</p>
<p>:param json: dict representation of a model's fields and field values as they are currently
set on the model.
:param field_objs: List of fields and their values for a model
:param log_output: boolean to determine if we should log the output or not
:return: The field keys to remove from the json representation of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fields_to_pop_for_json(
        self, json: dict, field_objs: List[Field], log_output: bool
) -&gt; Set[Any]:
    &#34;&#34;&#34;
    Goes through the list of fields (field_objs) to determine which ones have not changed in
    order to pop them out of the json representation. This method is used when we only want to
    include the changes in the json.

    :param json: dict representation of a model&#39;s fields and field values as they are currently
        set on the model.
    :param field_objs: List of fields and their values for a model
    :param log_output: boolean to determine if we should log the output or not
    :return: The field keys to remove from the json representation of the model.
    &#34;&#34;&#34;
    fields_to_pop = set()
    for field, new_value in json.items():

        # json has simple strings, numbers, lists, dict;
        # so makes general comparison simpler.
        old_value = self._get_old_json_value(field=field, as_type=type(new_value))

        if old_value is Default:
            if log_output:
                log.debug(
                    f&#34;   Included field ({field}) with value &#34;
                    f&#34;({new_value}) because there is no original json value for it.&#34;
                )
        elif self.should_include_field_in_json(
                new_value=new_value,
                old_value=old_value,
                field=field
        ):
            if log_output:
                log.debug(
                    f&#34;   Included field ({field}) due to new value &#34;
                    f&#34;({new_value}) != old value ({old_value}).&#34;
                )
        else:
            # We don&#39;t want to mutate dict while traversing it, remember this for later.
            fields_to_pop.add(field)

    # Map a field-key to what other fields should be included if field-key value is used.
    # For now we are NOT supporting `Field.json_path` to keep things simpler
    # when used in conjunction with `Field.include_with_fields`.
    # `Field` will raise an exception if json_path != field name and include_with_fields
    # is used at the same time.
    # It&#39;s something I would like to support in the future, but for now it&#39;s not needed.
    # We can assume that `field_obj.name == field_obj.json_path`
    for field_obj in field_objs:
        if not field_obj.include_with_fields:
            continue
        if field_obj.name not in fields_to_pop:
            continue
        if not (field_obj.include_with_fields &lt;= fields_to_pop):
            fields_to_pop.remove(field_obj.name)

    return fields_to_pop</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.forget_original_json_state"><code class="name flex">
<span>def <span class="ident">forget_original_json_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If called, we forget/reset the orginal json state, which is a combination
of all the json that this object has been updated with over it's lifetime.</p>
<p>The json state is what allows the object to decide what has changed,
when it's requested to only include changes via the <code><a title="xmodel.BaseApi.json" href="#xmodel.BaseApi.json">BaseApi.json()</a></code> method.</p>
<p>If forgotten, it's as-if we never got the json in the first place to compare against.
Therefore, all attributes that have values will be returned for this object
when it's only requested to include changes
(the RestClient in xmodel-rest can request it to do this, as an example).</p>
<p>Resetting the state here only effects this object, not any child objects.
You'll have to ask child objects directly to forget t heir original json, if desired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forget_original_json_state(self):
    &#34;&#34;&#34; If called, we forget/reset the orginal json state, which is a combination
        of all the json that this object has been updated with over it&#39;s lifetime.

        The json state is what allows the object to decide what has changed,
        when it&#39;s requested to only include changes via the `BaseApi.json` method.

        If forgotten, it&#39;s as-if we never got the json in the first place to compare against.
        Therefore, all attributes that have values will be returned for this object
        when it&#39;s only requested to include changes
        (the RestClient in xmodel-rest can request it to do this, as an example).

        Resetting the state here only effects this object, not any child objects.
        You&#39;ll have to ask child objects directly to forget t heir original json, if desired.
    &#34;&#34;&#34;
    self._api_state.last_original_update_json = None</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.get_child_without_lazy_lookup"><code class="name flex">
<span>def <span class="ident">get_child_without_lazy_lookup</span></span>(<span>self, child_field_name, *, false_if_not_set=False) â€‘>Â Union[<a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M],Â None,Â bool,Â <a title="xsentinels.null.NullType" href="../xsentinels/null.html#xsentinels.null.NullType">NullType</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see self.model].</p>
<p>If the child is current set to Null, or an object, returns that value.
Will NOT lazily lookup child, even if its possible to do so.</p>
<p>:param child_field_name: The field name of the child object.
:param false_if_not_set:
Possible Values [Default: False]:
* False: Return None if nothing is currently set.
* True:
Return False if nothing is currently set. This lets you distinguish
between having a None value set on field vs nothing set at all.
Normally this distinction is only useful internally in this class,
external users probably don't need this option.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_child_without_lazy_lookup(
        self,
        child_field_name,
        *,
        false_if_not_set=False,
) -&gt; Union[BaseModel[M], None, bool, NullType]:
    &#34;&#34;&#34; REQUIRES associated model object [see self.model].

    If the child is current set to Null, or an object, returns that value.
    Will NOT lazily lookup child, even if its possible to do so.

    :param child_field_name: The field name of the child object.
    :param false_if_not_set:
        Possible Values [Default: False]:
            * False: Return None if nothing is currently set.
            * True:  Return False if nothing is currently set. This lets you distinguish
              between having a None value set on field vs nothing set at all.
              Normally this distinction is only useful internally in this class,
              external users probably don&#39;t need this option.
    &#34;&#34;&#34;

    model = self.model

    if not self.structure.is_field_a_child(child_field_name):
        raise XModelError(
            f&#34;Called get_child_without_lazy_lookup(&#39;{child_field_name}&#39;) but &#34;
            f&#34;field ({child_field_name}) is NOT a child field on model ({model}).&#34;)

    if child_field_name in model.__dict__:
        return getattr(model, child_field_name)

    if false_if_not_set:
        return False

    return None</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, only_include_changes:Â boolÂ =Â False, log_output:Â boolÂ =Â False) â€‘>Â Optional[Dict[str,Â Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object (see <code><a title="xmodel.BaseApi.model" href="#xmodel.BaseApi.model">BaseApi.model</a></code> for details on this).</p>
<p>Return associated model object as a JsonDict (str keys, any value), ready to be encoded
via JSON encoder and sent to the API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>only_include_changes</code></strong></dt>
<dd>
<p>If True, will only include what changed in the JsonDict result.
Defaults to False.
This is normally set to True if system is sending this object via PATCH, which is
the
normal way the system sends objects to API.</p>
<p>If only_include_changes is False (default), we always include everything that
is not 'None'.
When a <code>xmodel.base.client.BaseClient</code> subclass
(such as <code>xmodel.rest.RestClient</code>)
calls this method, it will pass in a value based on it's own
<code>xmodel.rest.RestClient.enable_send_changes_only</code> is set to
(defaults to False there too).
You can override the RestClient.enable_send_changes_only at the BaseModel class
level by making a RestClient subclass and setting <code>enable_send_changes_only</code> to
default to <code>True</code>.</p>
<p>There is a situations where we have to include all attributes, regardless:
1. If the 'id' field is set to a 'None' value. This indicates we need to create
a new object, and we are not partially updating an existing one, even if we
got updated via json at some point in the past.</p>
<p>As always, properties set to None will <em>NOT</em> be included in returned JsonDict,
regardless of what options have been set.</p>
</dd>
<dt><strong><code>log_output</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False (default): won't log anything.
If True: Logs what method returns at debug level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JsonDict</code></dt>
<dd>
<p>Will the needed attributes that should be sent to API.
If returned value is None, that means only_include_changes is True
and there were no changes.</p>
<p>The returned dict is a copy and so can be mutated be the caller.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(
    self, only_include_changes: bool = False, log_output: bool = False
) -&gt; Optional[JsonDict]:
    &#34;&#34;&#34; REQUIRES associated model object (see `BaseApi.model` for details on this).

    Return associated model object as a JsonDict (str keys, any value), ready to be encoded
    via JSON encoder and sent to the API.

    Args:
        only_include_changes: If True, will only include what changed in the JsonDict result.
            Defaults to False.
            This is normally set to True if system is sending this object via PATCH, which is
            the  normal way the system sends objects to API.

            If only_include_changes is False (default), we always include everything that
            is not &#39;None&#39;.
            When a `xmodel.base.client.BaseClient` subclass
            (such as `xmodel.rest.RestClient`)
            calls this method, it will pass in a value based on it&#39;s own
            `xmodel.rest.RestClient.enable_send_changes_only` is set to
            (defaults to False there too).
            You can override the RestClient.enable_send_changes_only at the BaseModel class
            level by making a RestClient subclass and setting `enable_send_changes_only` to
            default to `True`.

            There is a situations where we have to include all attributes, regardless:
                1. If the &#39;id&#39; field is set to a &#39;None&#39; value. This indicates we need to create
                   a new object, and we are not partially updating an existing one, even if we
                   got updated via json at some point in the past.

            As always, properties set to None will *NOT* be included in returned JsonDict,
            regardless of what options have been set.

        log_output (bool): If False (default): won&#39;t log anything.
            If True: Logs what method returns at debug level.


    Returns:
        JsonDict: Will the needed attributes that should be sent to API.
            If returned value is None, that means only_include_changes is True
            and there were no changes.

            The returned dict is a copy and so can be mutated be the caller.
    &#34;&#34;&#34;

    # todo: Refactor _get_fields() to return getter/setter closures for each field, and we
    #       can make this whole method more generic that way. We also can &#39;cache&#39; the logic
    #       needed that way instead of having to figure it out each time, every time.

    structure = self.structure
    model = self.model
    api_state = self._api_state

    json: JsonDict = {}

    field_objs = structure.fields

    # Negate only_include_changes if we don&#39;t have any original update json to compare against.
    if only_include_changes and api_state.last_original_update_json is None:
        only_include_changes = False

    # noinspection PyDefaultArgument
    def set_value_into_json_dict(value, field_name, *, json=json):
        # Sets field value directly on json dict or passed in dict...
        if value is not None:
            # Convert Null into None (that&#39;s how JSON converter represents a Null).
            json[field_name] = value if value is not Null else None

    for field_obj in field_objs:
        # If we are read-only, no need to do anything more.
        if field_obj.read_only:
            continue

        # We deal with non-related types later.
        related_type = field_obj.related_type
        if not related_type:
            continue

        f = field_obj.name
        if field_obj.read_only:
            continue

        # todo: For now, the &#39;api-field-path&#39; option can&#39;t be used at the same time as obj-r.
        if field_obj.json_path != field_obj.name:
            # I&#39;ve put in some initial support for this below, but it&#39;s has not been tested
            # for now, keep raising an exception for this like we have been.
            # There is a work-around, see bottom part of the message in the below error:
            raise NotImplementedError(
                f&#34;Can&#39;t have xmodel.Field on BaseModel with related-type and a json_path &#34;
                f&#34;that differ at the moment, for field ({field_obj}). &#34;
                f&#34;It is something I want to support someday; the support is mostly in place &#34;
                f&#34;already, but it needs some more careful thought, attention and testing &#34;
                f&#34;before we should allow it. &#34;
                &#34;Workaround:  Make an `{field.name}_id` field next to related field on the &#34;
                &#34;model. Then, set `json_path` for that `{field.name}_id` field, set it to &#34;
                &#34;what you want it to be. Finally, set the `{related_field.name}` to &#34;
                &#34;read_only=True. This allows you to rename the `_id` field used to/from api &#34;
                &#34;in the JSON input/output, but the Model can have an alternate name for the &#34;
                &#34;related field. You can see a real-example of this at &#34;
                &#34;`bigcommerce.api.orders._BcCommonOrderMetafield.order&#34;
            )

        obj_type_structure = related_type.api.structure
        obj_type_has_id = obj_type_structure.has_id_field()

        if obj_type_has_id:
            # If the obj uses an &#39;id&#39;, then we have a {field_name}_id we want to
            # send instead of the full object as a json dict.
            #
            # This will grab the id from child obj if it exists, or from a defined field
            # of f&#34;{f}_id&#34; or finally from related id storage.

            # todo: If there is an object with no &#39;id&#39; value, do we ignore it?
            #   or should we embed full object anyway?

            child_obj_id = api_state.get_related_field_id(f)

            # Method below should deal with None vs Null.
            set_value_into_json_dict(child_obj_id, f&#34;{f}_id&#34;)
        else:
            obj: &#39;BaseModel[M]&#39; = getattr(model, f)

            # Related-object has no &#39;id&#39;, so get it&#39;s json dict and set that into the output.
            v = obj
            if obj is not Null and obj is not None:
                # todo: a Field option to override this and always provide all
                #   values (if object always needs to be fully embedded).
                v = obj.api.json(only_include_changes=only_include_changes)

            # if it returns None (ie: no changes) and only_include_changes is enabled,
            # don&#39;t include the sub-object as a change.
            if v is not None or not only_include_changes:
                # Method below should deal with None vs Null.
                set_value_into_json_dict(v, f)

    for field_obj in field_objs:
        # If we are read-only, no need to do anything more.
        if field_obj.read_only:
            continue

        # We don&#39;t deal with related-types here.
        if field_obj.related_type:
            continue

        f = field_obj.name
        v = getattr(model, f)
        if v is not None and field_obj.converter:
            # Convert the value....
            v = field_obj.converter(
                api=self,
                direction=Converter.Direction.to_json,
                field=field_obj,
                value=v
            )

        path = field_obj.json_path
        if not path:
            set_value_into_json_dict(v, f)
            continue

        path_list = path.split(field_obj.json_path_separator)
        d = json
        for name in path_list[:-1]:
            d = d.setdefault(name, {})
        name = path_list[-1]

        # Sets field value into a sub-dictionary of the original `json` dict.
        set_value_into_json_dict(v, name, json=d)

    # If the `last_original_update_json` is None, then we never got update via JSON
    # so there is nothing to compare, include everything!
    if only_include_changes:
        log.debug(f&#34;Checking Obj {model} for changes to include.&#34;)
        fields_to_pop = self.fields_to_pop_for_json(json, field_objs, log_output)

        for f in fields_to_pop:
            del json[f]

        if not json:
            # If nothing in JSON, then return None.
            return None
    else:
        due_to_msg = &#34;unknown&#34;
        if not only_include_changes:
            due_to_msg = &#34;only_include_changes is False&#34;
        if api_state.last_original_update_json is None:
            due_to_msg = &#34;no original json value&#34;

        if log_output:
            log.debug(f&#34;Including everything for obj {model} due to {due_to_msg}.&#34;)

            # Log out at debug level what we are including in the JSON.
            for field, new_value in json.items():
                log.debug(
                    f&#34;   Included field ({field}) value ({new_value})&#34;
                )

    for k, v in json.items():
        # Must use list of JSON, convert any sets to a list.
        if type(v) is set:
            v = list(v)
            json[k] = v

    return json</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.list_of_attrs_to_repr"><code class="name flex">
<span>def <span class="ident">list_of_attrs_to_repr</span></span>(<span>self) â€‘>Â List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>" REQUIRES associated model object [see self.model].</p>
<p>A list of attribute names to put into the <strong>repr</strong>/string representation
of the associated model object. This is consulted when the BaseModel has <strong>repr</strong>
called on it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_of_attrs_to_repr(self) -&gt; List[str]:
    &#34;&#34;&#34;&#34; REQUIRES associated model object [see self.model].

    A list of attribute names to put into the __repr__/string representation
    of the associated model object. This is consulted when the BaseModel has __repr__
    called on it.
    &#34;&#34;&#34;
    names = set()
    model = self.model

    # todo: Move this into pres-club override of list_of_attrs_to_repr in an BaseApi subclass.
    if hasattr(model, &#39;account_id&#39;):
        names.add(&#39;account_id&#39;)

    # todo: Consider adding others here, perhaps all defined fields on model that have
    # todo: a non-None value?

    for f in self.structure.fields:
        if f.include_in_repr:
            names.add(f.name)
    return list(names)</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.should_include_field_in_json"><code class="name flex">
<span>def <span class="ident">should_include_field_in_json</span></span>(<span>self, new_value:Â Any, old_value:Â Any, field:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the the value for field should be included in the JSON.
This only gets called if only_include_changes is True when passed to self.json::</p>
<pre><code># Passed in like so:
self.json(only_include_changes=True)
</code></pre>
<p>This method is an easy way to change the comparison logic.</p>
<p>:param new_value: New value that will be put into JSON.
:param old_value:
Old value originals in original JSON [normalized if possible to the same type as
new_value.
:param field: Field name.
:return:
If True: Will include the fields value in an update.
If False: Won't include the fields value in an update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_include_field_in_json(self, new_value: Any, old_value: Any, field: str) -&gt; bool:
    &#34;&#34;&#34;
    Returns True if the the value for field should be included in the JSON.
    This only gets called if only_include_changes is True when passed to self.json::

        # Passed in like so:
        self.json(only_include_changes=True)

    This method is an easy way to change the comparison logic.

    :param new_value: New value that will be put into JSON.
    :param old_value:
        Old value originals in original JSON [normalized if possible to the same type as
        new_value.
    :param field: Field name.
    :return:
        If True: Will include the fields value in an update.
        If False: Won&#39;t include the fields value in an update.
    &#34;&#34;&#34;
    # Convert old value to set if new value is set and old value is list (from original JSON).
    # If I was really cool :)... I would find out the inner type in case of int/str
    # and to a conversion to compare Apples to Apples.....
    # But trying to minimize changes so I don&#39;t conflict as much with soon to be
    # xmodel-dynamo feature.
    if type(new_value) is set and type(old_value) is list:
        old_value = set(old_value)

    return new_value != old_value</code></pre>
</details>
</dd>
<dt id="xmodel.BaseApi.update_from_json"><code class="name flex">
<span>def <span class="ident">update_from_json</span></span>(<span>self, json:Â Union[Dict[str,Â Any],Â collections.abc.Mapping])</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see self.model].</p>
<p>todo: Needs more documentation</p>
<p>We update the dict per-key, with what we got passed in [via 'json' parameter]
overriding anything we got previously. This also makes a copy of the dict, which is
want we want [no change to modify the incoming dict parameter].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_from_json(self, json: Union[JsonDict, Mapping]):
    &#34;&#34;&#34; REQUIRES associated model object [see self.model].

    todo: Needs more documentation

    We update the dict per-key, with what we got passed in [via &#39;json&#39; parameter]
    overriding anything we got previously. This also makes a copy of the dict, which is
    want we want [no change to modify the incoming dict parameter].
    &#34;&#34;&#34;

    structure = self.structure
    model = self.model
    api_state = self._api_state

    if not isinstance(json, Mapping):
        raise XModelError(
            f&#34;update_from_json(...) was given a non-mapping parameter ({json}).&#34;
        )

    # Merge the old values with the new values.
    api_state.last_original_update_json = {
        **(api_state.last_original_update_json or {}),
        **json
    }

    fields = structure.fields

    values = {}
    for field_obj in fields:
        path_list = field_obj.json_path.split(field_obj.json_path_separator)
        v = json
        got_value = True
        for name in path_list:
            if name not in v:
                # We don&#39;t even have a &#39;None&#39; value so we assume we just did not get the value
                # from the api, and therefore we just skip doing anything with it.
                got_value = False
                break

            v = v.get(name)
            if v is None:
                break

        # We map the value we got from JSON into a flat-dict with the BaseModel name as the
        # key...
        if got_value:
            values[field_obj.name] = v if v is not None else Null

    def set_attr_on_model(field, value, model=model):
        &#34;&#34;&#34; Closure to set attr on self unless value is None.
        &#34;&#34;&#34;
        if value is None:
            return
        setattr(model, field, value)

    # Merge in the outer json, keeping the values we mapped [via Field.json_path] for conflicts
    values = {**json, **values}

    # todo: If the json does not have a value [not even a &#39;None&#39; value], don&#39;t update?
    #       We may have gotten a partial update?  For now, always update [even to None]
    #       all defined fields regardless if they are inside the json or not.

    for field_obj in fields:
        # We deal with related types later....
        if field_obj.related_type:
            continue

        f = field_obj.name
        v = values.get(f, Default)

        # A None from JSON means a Null for us.
        # If JSON does not include anything, that&#39;s a None for us.
        if v is None:
            v = Null
        elif v is Default:
            v = None

        # Run the converter if needed.
        # If we have a None value, we don&#39;t need to convert that, there was no value to
        # convert.
        if field_obj.converter and v is not None:
            v = field_obj.converter(
                self,
                Converter.Direction.from_json,
                field_obj,
                v
            )

        set_attr_on_model(f, v)

    for field_obj in fields:
        # Ok, now we deal with related types...
        related_type = field_obj.related_type
        if not related_type:
            continue

        f = field_obj.name

        # todo: at some point, allow customization of this via Field class
        #   Also, s tore the id
        f_id_name = f&#34;{f}_id&#34;
        if typing_inspect.get_origin(field_obj.type_hint) is list:
            # todo: This code is not complete [Kaden never finished it up]
            #   for now, just comment out.

            raise NotImplementedError(
                &#34;Type-hints for xmodel models in this format: `attr: List[SomeType]` &#34;
                &#34;are not currently supported. We want to support it someday. For now you &#34;
                &#34;must use lower-cased non-generic `list`. At some point the idea is to &#34;
                &#34;allow one to do `List[ChildModel]` and then we know it&#39;s a list of &#34;
                &#34;other BaseModel objects and automatically handle that in some way.&#34;
            )

            # child_type: &#39;Type[BaseModel[M]]&#39;
            # child_type = typing_inspect.get_args(obj_type)
            # # __args__ returns a tuple of all arguments passed into List[] so we need to
            # # pull the class out of the tuple
            # if child_type:
            #     child_type = child_type[0]
            #
            # child_api: BaseApi
            # child_api = child_type.api
            # if not child_api and child_api.structure.has_id_field:
            #     # TODO: add a non generic Exception for this
            #     raise XModelError(
            #         f&#34;{model} has an attribute with name ({f}) with type-hint List that &#34;
            #         f&#34;doesn&#39;t contain an API BaseModel Type as the only argument&#34;
            #     )
            # parent_name = model.__class__.__name__.lower()
            # state.set_related_field_id(f, parent_name)
            # continue

        v = None
        if f in values:
            v = values.get(f, Null)
            if v is not Null:
                v = related_type(v)

        # Check to see if we have an api/json field for object relation name with &#34;_id&#34; on
        # end.
        if v is None and related_type.api.structure.has_id_field():
            # If we don&#39;t have a defined field for this value, check JSON for it and store it.
            #
            # If we have a defined None value for the id field, meaning the field exists
            # in the json, and is set directly to None, then we have a Null relationship.
            # We set that as the value, since there is no need to &#39;lookup&#39; a null value.
            f_id_value = json.get(f_id_name)
            id_field = structure.get_field(f_id_name)

            if not id_field:
                id_field = field_obj.related_type.api.structure.get_field(&#39;id&#39;)

            # Run the converter if needed.
            # If we have a None value, we don&#39;t need to convert that, there was no value to
            # convert.
            if id_field and id_field.converter and f_id_value is not None:
                f_id_value = id_field.converter(
                    self,
                    Converter.Direction.from_json,
                    id_field,
                    f_id_value
                )

            if f_id_value is None and f_id_name in json:
                # We have a Null situation.
                f_id_value = Null

            if f_id_value is not None:
                # We have an id!
                # Set the value to support automatic lookup of value, lazily.
                # This method also takes care to set child object to Null or delete it
                # as needed depending on the f_id_value and what the child&#39;s id field value is.
                api_state.set_related_field_id(f, f_id_value)
        else:
            # &#39;v&#39; is either going to be None, Null or an BaseModel object.
            set_attr_on_model(f, v)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel.BaseModel"><code class="flex name class">
<span>class <span class="ident">BaseModel</span></span>
<span>(</span><span>*args, **initial_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Used as the abstract base-class for classes/object that communicate with our REST API.</p>
<p>This is one of the main classes, and it's highly recommend you read the
<a href="./#orm-library-overview">SDK Library Overview</a> first, if you have not already.
That document has many basic examples of using this class along with other related classes.</p>
<p>Attributes that start with <code>_</code> or don't have a type-hint are not considered fields
on the object that automatically get mapped to/from the JSON that is passed in.
For more details see <a href="./#type-hints">Type Hints</a>.</p>
<p>When you sub-class <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code>, you can create your own Model class, with your own
fields/attrs.
You can pass class arguments/paramters in when you declare your sub-class.
The Model-subclass can provide parameters to the super class during class construction.</p>
<p>In the example below, notice the <code>base_url</code> part. That's a class argument, that is used by the
super-class during the construction of the sub-class (before any instances are created).
In this case it takes this and stores it on
<code>xmodel.rest.RestStructure.base_model_url</code>
as part of the structure information for the <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code> subclass.</p>
<p>See <a href="./#basic-model-example">Basic Model Example</a> for an example of what class arguments
are or look at this example below using a RestModel:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 'base_url' part is a class argument:
&gt;&gt;&gt; from xmodel.rest import RestModel
&gt;&gt;&gt; class Account(RestModel[&quot;Account&quot;], base_url='/account'):
&gt;&gt;&gt;    id: str
&gt;&gt;&gt;    name: str
</code></pre>
<p>These class arguments are sent to a special method
<code><a title="xmodel.base.structure.BaseStructure.configure_for_model_type" href="base/structure.html#xmodel.base.structure.BaseStructure.configure_for_model_type">BaseStructure.configure_for_model_type()</a></code>. See that methods docs for
a list of avaliable class-arguments.</p>
<p>See <code>BaseModel.__init_subclass__</code> for more on the internal details of how this works exactly.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;In the case of <code>base_url</code> example above, it's the base-url-endpoint for the model.</p>
<p>If you want to know more about that see <code>xmodel.rest.RestClient.url_for_endpoint</code>.
It has details on how the final request <code><a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a></code> is constructed.</p>
</div>
<p>This class also allows you to more easily with with JSON data via:</p>
<ul>
<li><code><a title="xmodel.base.api.BaseApi.json" href="base/api.html#xmodel.base.api.BaseApi.json">BaseApi.json()</a></code></li>
<li><code><a title="xmodel.base.api.BaseApi.update_from_json" href="base/api.html#xmodel.base.api.BaseApi.update_from_json">BaseApi.update_from_json()</a></code></li>
<li>Or passing a JSON dict as the first arrument to <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code>.</li>
</ul>
<p>Other important related classes are listed below.</p>
<ul>
<li><code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> Accessable via <code><a title="xmodel.BaseModel.api" href="#xmodel.BaseModel.api">BaseModel.api</a></code>.</li>
<li><code>xmodel.rest.RestClient</code>: Accessable via <code>xmodel.base.api.BaseApi.client</code>.</li>
<li><code>xmodel.rest.settings.RestSettings</code>: Accessable via
<code>xmodel.base.api.BaseApi.settings</code>.</li>
<li><code><a title="xmodel.base.structure.BaseStructure" href="base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>: Accessable via
<code><a title="xmodel.base.api.BaseApi.structure" href="base/api.html#xmodel.base.api.BaseApi.structure">BaseApi.structure</a></code></li>
<li><code>xmodel.base.auth.BaseAuth</code>: Accessable via <code>xmodel.base.api.BaseApi.auth</code></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Tip:&ensp;For all of the above, you can change what class is allocated for each one</p>
<p>by changing the type-hint on a subclass.</p>
</div>
<p>Creates a new model object. The first/second params need to be passed as positional
arguments. The rest must be sent as key-word arguments. Everything is optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Specify the <code>BaseModel.id</code> attribute, if you know it. If left as Default, nothing
will be set on it. It could be set to something via args[0] (ie: a JSON dict).
If you do provide a value, it be set last after everything else has been set.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>
<p>I don't want to take names from what you could put into 'initial_values',
so I keep it as position-only *args. Once Python 3.8 comes out, we can use a
new feature where you can specify some arguments as positional-only and not
keyword-able.</p>
<h2 id="firstarg-if-dict">FirstArg - If Dict:</h2>
<p>If raw dictionary parsed from JSON string. It just calls
<code>self.api.update_from_json(args[0])</code> for you.</p>
<h2 id="firstart-if-basemodel">FirstArt - If BaseModel:</h2>
<p>If a <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code>, will copy fields over that have the same name.
You can use this to duplicate a Model object, if you want to copy it.
Or can be used to copy fields from one model type into another,
on fields that are the same name.</p>
<p>Will ignore fields that are present on one but not the other.
Only copy fields that are on both models types.</p>
</dd>
<dt><strong><code>**initial_values</code></strong></dt>
<dd>Let's you specify other attribute values for convenience.
They will be set into the object the same way you would normally doing it:
ie: <code>model_obj.some_attr = v</code> is the same as <code>ModelClass(some_attr=v)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseModel(Generic[M], ABC):
    &#34;&#34;&#34;
    Used as the abstract base-class for classes/object that communicate with our REST API.

    This is one of the main classes, and it&#39;s highly recommend you read the
    [SDK Library Overview](./#orm-library-overview) first, if you have not already.
    That document has many basic examples of using this class along with other related classes.

    Attributes that start with `_` or don&#39;t have a type-hint are not considered fields
    on the object that automatically get mapped to/from the JSON that is passed in.
    For more details see [Type Hints](./#type-hints).

    When you sub-class `BaseModel`, you can create your own Model class, with your own
    fields/attrs.
    You can pass class arguments/paramters in when you declare your sub-class.
    The Model-subclass can provide parameters to the super class during class construction.

    In the example below, notice the `base_url` part. That&#39;s a class argument, that is used by the
    super-class during the construction of the sub-class (before any instances are created).
    In this case it takes this and stores it on
    `xmodel.rest.RestStructure.base_model_url`
    as part of the structure information for the `BaseModel` subclass.

    See [Basic Model Example](./#basic-model-example) for an example of what class arguments
    are or look at this example below using a RestModel:

    &gt;&gt;&gt; # &#39;base_url&#39; part is a class argument:
    &gt;&gt;&gt; from xmodel.rest import RestModel
    &gt;&gt;&gt; class Account(RestModel[&#34;Account&#34;], base_url=&#39;/account&#39;):
    &gt;&gt;&gt;    id: str
    &gt;&gt;&gt;    name: str

    These class arguments are sent to a special method
    `xmodel.base.structure.BaseStructure.configure_for_model_type`. See that methods docs for
    a list of avaliable class-arguments.

    See `BaseModel.__init_subclass__` for more on the internal details of how this works exactly.

    .. note:: In the case of `base_url` example above, it&#39;s the base-url-endpoint for the model.
        If you want to know more about that see `xmodel.rest.RestClient.url_for_endpoint`.
        It has details on how the final request `xurls.url.URL` is constructed.

    This class also allows you to more easily with with JSON data via:

    - `xmodel.base.api.BaseApi.json`
    - `xmodel.base.api.BaseApi.update_from_json`
    - Or passing a JSON dict as the first arrument to `BaseModel.__init__`.

    Other important related classes are listed below.

    - `xmodel.base.api.BaseApi` Accessable via `BaseModel.api`.
    - `xmodel.rest.RestClient`: Accessable via `xmodel.base.api.BaseApi.client`.
    - `xmodel.rest.settings.RestSettings`: Accessable via
        `xmodel.base.api.BaseApi.settings`.
    - `xmodel.base.structure.BaseStructure`: Accessable via
        `xmodel.base.api.BaseApi.structure`
    - `xmodel.base.auth.BaseAuth`: Accessable via `xmodel.base.api.BaseApi.auth`

    .. tip:: For all of the above, you can change what class is allocated for each one
        by changing the type-hint on a subclass.

    &#34;&#34;&#34;

    # -------------------------------------
    # --------- Public Properties ---------

    api: &#34;BaseApi[M]&#34; = None
    &#34;&#34;&#34; Used to access the api class, which is used to retrieve/send objects to/from api.

        You can specify this as a type-hint in subclasses to change the class we use for this
        automatically, like so::
            from xmodel import BaseModel, BaseApi
            from typing import TypeVar

            M = TypeVar(&#34;M&#34;)

            class MyCoolApi(BaseApi[M]):
                pass

            class MyCoolModel(BaseModel[&#34;MyCoolModel&#34;]):
                api: MyCoolApi[M]  # If this model will have subclasses, you want to use a type-var

        The generic ``T`` type-var in this case refers to whatever model class that your using.
        In the example just above, ``T`` would be referring to ``MyCoolModel`` if you did this
        somewhere to get the BaseModel&#39;s api: ``MyCoolModel.api``.
    &#34;&#34;&#34;

    # --------------------------------------------
    # --------- Config/Option Properties ---------

    def __init_subclass__(
        cls: Type[M],
        *,
        lazy_loader: Callable[[Type[M]], None] = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        We take all arguments (except `lazy_loader`) passed into here and send them to the method
        on our structure:
        `xmodel.base.structure.BaseStructure.configure_for_model_type`.
        This allows you to easily configure the BaseStructure via class arguments.

        For a list of class-arguments, see method parameters for
        `xmodel.base.structure.BaseStructure.configure_for_model_type`.

        See [Basic BaseModel Example](./#basic-model-example) for an example of what class
        arguments are for `BaseModel` classes and how to use them.

        We lazily configure BaseModel sub-classes. They are configured the first time that
        `BaseModel.api` is accessed under that subclass. At that point all parent + that specific
        subclass are configured and an `xmodel.base.api.BaseApi` object is created and set
        on the `BaseModel.api` attribute. From that point forward, that object is what is used.
        This only happens the first time that `BaseModel.api` is accessed.

        If you want to add support for additional BaseModel class arguments,
        you can do it by modifying the base-implementation
        `xmodel.base.structure.BaseStructure`.
        Or if you want it only for a specific sub-set of Models, you can make a custom
        `xmodel.base.structure.BaseStructure` subclass. You can configure your BaseModel to use
        this BaseStructure subclass via a type-hint on `xmodel.base.api.BaseApi.structure`.

        See `xmodel_dynamo.dynamo.DynStructure.configure_for_model_type` for a complete example of a
        custom BaseStructure subclass that adds extra class arguments that are specific to Dynamo.

        Args:
            lazy_loader: This is a callable where the first argument is `cls/self`.
                This is an optional param. If provided, we will call when we need to lazy-load
                but before we do our normal lazy-loading ourselves here.

                Most of the time, you&#39;ll want to import into the global/module space of where
                your class lives any imports you need to do lazily, such as circular imports.

                Right after we call your lazy_loader callable, we will be ourselves calling
                the method `get_type_hints` to get all of our type-hints.
                You&#39;ll want to be sure all of your forward-referenced type-hints on your
                model sub-class are resolvable.

                Forward-ref type hints are the ones that are string based type-hints,
                they get resolved lazily after your lazy_loader (if provided) is called.

                You can see in the code in our method below, look at the check for:

                &gt;&gt;&gt; if &#34;BaseApi&#34; not in globals():

                Look at that for a real-world example of what I am talking about.
                This little piece of code lazily resolves the `BaseApi` type.
        &#34;&#34;&#34;

        # We are taking all args and sending them to a xmodel.base.structure.BaseStructure
        # class object.
        super().__init_subclass__()

        def lazy_setup_api(cls_or_self):
            # If requested, before we do our own lazy-loading below, call passed in lazy-loader.
            if lazy_loader:
                lazy_loader(cls)

            for parent in cls.mro():
                if parent is not cls and issubclass(parent, BaseModel):
                    # Ensure that parent-class has a chance to lazy-load it&#39;s self
                    # before we try to examine our type-hints.
                    getattr(parent, &#39;api&#39;)

            # We potentially get called a lot (for every sub-class)
            # so check to see if we already loaded BaseApi type or not.
            if &#39;BaseApi&#39; not in globals():
                # Lazy import BaseApi into module, helps resolve BaseApi forward-refs;
                # ie: `api: &#34;BaseApi[T]&#34;`
                # We need to resolve these due to use of `get_type_hints()` below.
                #
                # Sets it in such a way so IDE&#39;s such as pycharm don&#39;t get confused + pydoc3
                # can still find it and use the type forward-reference.
                #
                # todo: figure out why dynamic model attribute getter is having an issue with this.
                #   (see that near start of this file at top ^^^)
                from xmodel import BaseApi
                globals()[&#39;BaseApi&#39;] = BaseApi
            try:
                all_type_hints = get_type_hints(cls)
            except (NameError, AttributeError) as e:
                from xmodel import XModelError
                raise XModelError(
                    f&#34;Unable to construct model subclass ({cls}) due to error resolving &#34;
                    f&#34;type-hints on model class. They must be visible at the module-level that &#34;
                    f&#34;the class is defined in. Original error: ({e}).&#34;
                ) from None

            api_cls: Type[&#34;BaseApi&#34;] = all_type_hints[&#39;api&#39;]

            base_cls = None
            for b in cls.__bases__:
                if b is BaseModel:
                    break
                if issubclass(b, BaseModel):
                    base_cls = b
                    break

            base_api = None
            if base_cls:
                base_api = base_cls.api

            api = api_cls(api=base_api)
            cls.api = api

            # Configure structure for our model type with the user supplied options + type-hints.
            structure = api.structure
            try:
                structure.configure_for_model_type(
                    model_type=cls,
                    type_hints=all_type_hints,
                    **kwargs
                )
            except TypeError as e:
                from xmodel import XModelError
                # Adding some more information to the exception.
                raise XModelError(
                    f&#34;Unable to configure model structure for ({cls}) due to error ({e}) &#34;
                    f&#34;while calling ({structure}.configure_for_model_type).&#34;
                )
            return api

        # The LazyClassAttr will turn into the proper type automatically when it&#39;s first accessed.
        lazy_api = LazyClassAttr(lazy_setup_api, name=&#34;api&#34;)

        # Avoids IDE from using this as type-hint for `self.api`, we want it to use the type-hint
        # defined on attribute.
        # Otherwise it will try to be too cleaver by trying to use the type in `lazy_api` instead.
        # The object in `lazy_api` will transform into what has been type-hinted
        # when it&#39;s first accessed by something.
        setattr(cls, &#34;api&#34;, lazy_api)

    # -------------------------------
    # --------- Init Method ---------

    # todo: Python 3.8 has support for positional-arguments only, do that when we start using it.
    # See Doc-Comment for what *args is.
    def __init__(self, *args, **initial_values):
        &#34;&#34;&#34;
        Creates a new model object. The first/second params need to be passed as positional
        arguments. The rest must be sent as key-word arguments. Everything is optional.

        Args:
            id: Specify the `BaseModel.id` attribute, if you know it. If left as Default, nothing
                will be set on it. It could be set to something via args[0] (ie: a JSON dict).
                If you do provide a value, it be set last after everything else has been set.

            *args: I don&#39;t want to take names from what you could put into &#39;initial_values&#39;,
                so I keep it as position-only *args. Once Python 3.8 comes out, we can use a
                new feature where you can specify some arguments as positional-only and not
                keyword-able.

                ## FirstArg - If Dict:
                If raw dictionary parsed from JSON string. It just calls
                `self.api.update_from_json(args[0])` for you.

                ## FirstArt - If BaseModel:
                If a `BaseModel`, will copy fields over that have the same name.
                You can use this to duplicate a Model object, if you want to copy it.
                Or can be used to copy fields from one model type into another,
                on fields that are the same name.

                Will ignore fields that are present on one but not the other.
                Only copy fields that are on both models types.

            **initial_values: Let&#39;s you specify other attribute values for convenience.
                They will be set into the object the same way you would normally doing it:
                ie: `model_obj.some_attr = v` is the same as `ModelClass(some_attr=v)`.
        &#34;&#34;&#34;
        args_len = len(args)
        if args_len &gt; 1:
            raise NotImplementedError(
                &#34;Passing XContext via second positional argument is no longer supported.&#34;
            )

        cls_api_type = type(type(self).api)
        api = cls_api_type(model=self)
        setattr(self, &#34;api&#34;, api)  # Avoids IDE from using this as type-hint for `self.api`.

        first_arg = args[0] if args_len &gt; 0 else None

        if isinstance(first_arg, BaseModel):
            api.copy_from_model(first_arg)
        elif isinstance(first_arg, Mapping):
            api.update_from_json(first_arg)
        elif first_arg is not None:
            raise XModelError(
                f&#34;When a first argument to BaseModel.__init__ is provided, it needs to be a &#34;
                f&#34;mapping/dict with the json values in it OR a BaseModel instance to copy from; &#34;
                f&#34;I was given a type ({type(first_arg)}) with value ({first_arg}) instead.&#34;
            )

        for k, v in initial_values.items():
            if not self.api.structure.get_field(k):
                raise XModelError(
                    f&#34;While constructing {self}, init method got a value for an &#34;
                    f&#34;unknown field ({k}).&#34;
                )

            setattr(self, k, v)

    def __repr__(self):
        msgs = []
        for attr in self.api.list_of_attrs_to_repr():
            msgs.append(f&#39;{attr}={getattr(self, attr, None)}&#39;)

        full_message = &#34;, &#34;.join(msgs)
        return f&#34;{self.__class__.__name__}({full_message})&#34;

    def __setattr__(self, name, value):
        # This gets called for every attribute set.

        # DO NOT use hasattr() in here, because you could make every lazily loaded object load up
        # [ie: an API request to grab lazily loaded object properties] when the lazy object is set.

        api = self.api
        structure = api.structure
        field = structure.get_field(name)
        type_hint = None

        if inspect.isclass(self):
            # If we are a class, just pass it along
            pass
        elif name == &#34;api&#34;:
            # Don&#39;t do anything special with the &#39;api&#39; var.
            pass
        elif name.startswith(&#34;_&#34;):
            # don&#39;t do anything with private vars
            pass
        elif name.endswith(&#34;_id&#34;) and structure.is_field_a_child(name[:-3], and_has_id=True):
            # We have a virtual field for a related field id, redirect to special setter.
            state = _private.api.get_api_state(api)
            state.set_related_field_id(name[:-3], value)
            return

        if not field:
            # We don&#39;t do anything more without a field object
            # (ie: just a normal python attribute of some sort, not tied with API).
            super().__setattr__(name, value)
            return

        try:
            # We have a value going to an attributed that has a type-hint, checking the type...
            # We will also support auto-converting to correct type if needed and possible,
            # otherwise an error will be thrown if we can&#39;t verify type or auto-convert it.
            type_hint = field.type_hint
            value_type = type(value)
            field_obj: Field = structure.get_field(name)

            # todo: idea: We could cache some of these details [perhaps even using closures]
            #       or use dict/set&#39;s someday for a speed improvement, if we ever need to.

            hint_union_sub_types = ()
            if typing_inspect.is_union_type(type_hint):
                # Gets all args in a union type, to see if one of them will match type_hint.
                hint_union_sub_types = typing_inspect.get_args(type_hint)
                # Get first type hint in untion, Field object (where we just got type-hint)
                # already unwraps the type hint, removing any Null/None types. It&#39;s a Union
                # only if there are other non-Null/None types in a union. For right now
                # lets only worry about the first one.
                type_hint = hint_union_sub_types[0]

            state = _private.api.get_api_state(api)
            if (
                # Check for nullability first, as an optimization.
                field.nullable and
                type_hint not in [str, None] and
                value_type is str and
                not value
            ):
                value = Null
            elif value is None:
                # By default, this is None [unless user specified something].
                value = _get_default_value_from_field(self, field)
            elif (
                value_type is type_hint
                or value_type in hint_union_sub_types
                or Optional[value_type] is type_hint
                or type_hint is NullType and field.nullable
            ):
                # Type is the same as type hint, no need to do anything else.
                # We check to reset any related field id info, just in case it exists,
                # since this field is either being set to Null or an actual object.
                state.reset_related_field_id_if_exists(name)
                pass
            elif value is Null:
                # If type_hint supported the Null type, then it would have been dealt with in
                # the previous if statement.
                XModelError(
                    f&#34;Setting a Null value for field ({name}) when typehint ({type_hint}) &#34;
                    f&#34;does not support NullType, for object ({self}).&#34;
                )
            elif field_obj.converter:
                # todo: Someday map str/int/bool (basic conversions) to standard converter methods;
                #   kind of like I we do it for date/time... have some default converter methods.
                #
                # This handles datetime, date, etc...
                value = field_obj.converter(api, Converter.Direction.to_model, field_obj, value)
            elif type_hint in (dict, JsonDict) and value_type in (dict, JsonDict):
                # this is fine for now, keep it as-is!
                #
                # For now, we just assume things in the dict are ok.
                # in the future, we will support `Dict[str, int]` or some such and we will
                # check/convert/ensure the types as needed.
                pass
            elif type_hint in (dict, JsonDict) and value_type in (int, bool, str):
                # just passively convert bool/int/str into empty dict if type-hint is a dict.
                log.warning(
                    f&#34;Converted a int/bool/str into an empty dict. Attr name ({name}),&#34;
                    f&#34;value ({value}) type-hint ({type_hint}) object ({self}). If you don&#39;t want&#34;
                    f&#34;to do this, then don&#39;t put a type-hint on the attribute.&#34;
                )
                value = {}
            elif typing_inspect.get_origin(type_hint) in (list, set):
                # See if we have a converter for this type in our default-converters....
                inside_type_hint = typing_inspect.get_args(type_hint)[0]
                basic_type_converter = self.api.default_converters.get(inside_type_hint)
                if basic_type_converter:
                    converted_values = [
                        basic_type_converter(
                            api,
                            Converter.Direction.to_model,
                            field_obj,
                            x
                        ) for x in loop(value)
                    ]

                    container_type = typing_inspect.get_origin(type_hint)
                    value = container_type(converted_values)
                # Else/Otherwise we just leave things as-is for now, no error and no conversion
                pass
            # Python 3.7 does not have GenericMeta anymore, not sure if we need it, we just need
            # to try using this for a bit and see what happens.
            #
            # If needed in Python 3.7, we can see if we can remove this loop-hole with the new
            # typing_inspect.* methods.
            #
            # elif type(type_hint) is GenericMeta:
            #     # This is a complex type (probably a Parameterized generic), not going to try and
            #     # check it out, don&#39;t want to throw and error as well, just pass it though.
            #     #
            #
            #     pass

            else:
                raise AttributeError(
                    f&#34;Setting name ({name}) with value ({value}) with type ({value_type}) on &#34;
                    f&#34;API object ({self}) but type-hint is ({type_hint}), and I don&#39;t know how&#34;
                    f&#34; to auto-convert type ({value_type}) into ({type_hint}).&#34;
                )
        except ValueError:
            # We want to raise a more informative error than the base ValueError when there
            # is a problem parsing a value
            raise AttributeError(
                f&#34;Parsing value ({value}) with type-hint ({type_hint}) resulted in an error &#34;
                f&#34;for attribute ({name}) on object ({self})&#34;
            )

        if isinstance(value, str):
            # This value has caused me a lot of problems, it&#39;s time to ALWAYS treat them
            # as blank strings, exactly what they should have been set to in the first place.
            if value.startswith(&#39;#########&#39;):
                value = &#39;&#39;

        if field_obj.post_filter:
            value = field_obj.post_filter(api=api, name=name, value=value)

        if field.fset:
            field.fset(self, value)
        elif field.fget:
            raise XModelError(
                f&#34;We have a field ({field}) that does not have a Field.fset (setter function),&#34;
                f&#34;but has a Field.fget ({field.fget}) and someone is attempting to set a &#34;
                f&#34;value on the Model object ({self})... this is unsupported. &#34;
                f&#34;If you want to allow setting the value, you must provider a setter when a &#34;
                f&#34;getter is present/provided.&#34;
            )
        else:
            super().__setattr__(name, value)

    def __getattr__(self, name: str):
        # Reminder: This method only gets called if attribute is not currently defined in self.
        structure = self.api.structure
        state = _private.api.get_api_state(self.api)

        field = structure.get_field(name)

        if name.startswith(&#34;_&#34;):
            return object.__getattribute__(self, name)

        if field and field.fget:
            # Use getter to get value, if we get a non-None value return it.
            # If we get a None back, then do the default thing we normally do
            # (ie: look for default value, related object, etc).
            value = field.fget(self)
            if value is not None:
                return value

        if name.endswith(&#34;_id&#34;) and structure.is_field_a_child(name[:-3], and_has_id=True):
            # We have a field that ends with _id, that when taken off is a child field that
            # uses and id. This means we should treat this field as virtually related field id.
            value = state.get_related_field_id(name[:-3])
            if value is not None:
                if field and field.fset:
                    field.fset(self, value)
                return value

        if not field:
            raise AttributeError(
                f&#34;Getting ({name}) on ({self.__class__.__name__}), which does not exist on object &#34;
                f&#34;or in API. For API objects, you need to use already defined fields/attributes.&#34;
            )

        if (
            field.related_type is not None and
            field.related_type.api.structure.has_id_field()
        ):
            name_id_value = state.get_related_field_id(name)

            # RemoteModel is an abstract interface,
            # Let&#39;s us know how to lazily lookup remote objects by their id value.
            name_type: &#34;RemoteModel&#34; = field.related_type
            obj = None

            if name_id_value is Null:
                # Don&#39;t attempt to lookup object, we have it&#39;s primary id:
                obj = Null
            elif name_id_value is not None:
                # Attempt to lookup remote object, we have it&#39;s primary id:
                obj = name_type.api.get_via_id(name_id_value)
                # todo: consider raising an exception if we have an `id` but no related object?
                #   I&#39;ll think about it.

                # if we have an object, set it and return it
                if obj is not None:
                    if field.fset:
                        field.fset(self, obj)
                    else:
                        super().__setattr__(name, obj)
                    return obj
                # Otherwise, we continue, next thing to do is look for any default value.

        # We next look for a default value, if any set/return that.
        default = _get_default_value_from_field(self, field)

        # We set to default value and return it if we have a non-None value.
        if default is not None:
            # We have a value of some sort, call setter:
            if field.fset:
                field.fset(self, default)
            else:
                super().__setattr__(name, default)
            return default

        # We found no default value, return None.
        return None

    def __eq__(self, other):
        &#34;&#34;&#34; For BaseModel, by default our identity is based on object instance ID, not any values
            in our attributes.  Makes things simpler when trying to find object/self in a Set;
            which is useful when traversing relationships.
        &#34;&#34;&#34;
        return self is other

    def __hash__(self):
        &#34;&#34;&#34; For BaseModel, by default our identity is based on object instance ID, not any values
            in our attributes.  Makes things simpler when trying to find object/self in a Set;
            which is useful when traversing relationships.
        &#34;&#34;&#34;
        return id(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.json.JsonModel" href="json.html#xmodel.json.JsonModel">JsonModel</a></li>
<li><a title="xmodel.remote.model.RemoteModel" href="remote/model.html#xmodel.remote.model.RemoteModel">RemoteModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.BaseModel.api"><code class="name">var <span class="ident">api</span> :Â <a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a>[~M]</code></dt>
<dd>
<div class="desc"><p>Used to access the api class, which is used to retrieve/send objects to/from api.</p>
<p>You can specify this as a type-hint in subclasses to change the class we use for this
automatically, like so::
from xmodel import BaseModel, BaseApi
from typing import TypeVar</p>
<pre><code>M = TypeVar("M")

class MyCoolApi(BaseApi[M]):
    pass

class MyCoolModel(BaseModel["MyCoolModel"]):
    api: MyCoolApi[M]  # If this model will have subclasses, you want to use a type-var
</code></pre>
<p>The generic <code>T</code> type-var in this case refers to whatever model class that your using.
In the example just above, <code>T</code> would be referring to <code>MyCoolModel</code> if you did this
somewhere to get the BaseModel's api: <code>MyCoolModel.api</code>.</p></div>
</dd>
</dl>
</dd>
<dt id="xmodel.BaseStructure"><code class="flex name class">
<span>class <span class="ident">BaseStructure</span></span>
<span>(</span><span>*, parent:Â Optional[ForwardRef('<a title="xmodel.BaseStructure" href="#xmodel.BaseStructure">BaseStructure</a>')], field_type:Â Type[~F])</span>
</code></dt>
<dd>
<div class="desc"><p>BaseStructure class is meant to keep track of things that apply for all
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s at the class-level.</p>
<p>You can use <code><a title="xmodel.BaseStructure.fields" href="#xmodel.BaseStructure.fields">BaseStructure.fields</a></code> to get all fields for a particular
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
as an example of the sort of information on the <code><a title="xmodel.BaseStructure" href="#xmodel.BaseStructure">BaseStructure</a></code> object.</p>
<p>BaseStructure is lazily configured for a particular BaseModel the first time something
attempts to get <code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> off the particular BaseModel subclass.</p>
<p>You can get it via first getting api attribute for BaseModel via
<code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> and then getting the structure attribute on that via
<code><a title="xmodel.base.api.BaseApi.structure" href="base/api.html#xmodel.base.api.BaseApi.structure">BaseApi.structure</a></code>.</p>
<p>Example getting the structure object for the Account model/api:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt; structure = Account.api.structure
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseStructure(Generic[F]):

    &#34;&#34;&#34;
    BaseStructure class is meant to keep track of things that apply for all
    `xmodel.base.model.BaseModel`&#39;s at the class-level.

    You can use `BaseStructure.fields` to get all fields for a particular
    `xmodel.base.model.BaseModel`
    as an example of the sort of information on the `BaseStructure` object.

    BaseStructure is lazily configured for a particular BaseModel the first time something
    attempts to get `xmodel.base.model.BaseModel.api` off the particular BaseModel subclass.

    You can get it via first getting api attribute for BaseModel via
    `xmodel.base.model.BaseModel.api` and then getting the structure attribute on that via
    `xmodel.base.api.BaseApi.structure`.

    Example getting the structure object for the Account model/api:

    &gt;&gt;&gt; from some_lib.account import Account
    &gt;&gt;&gt; structure = Account.api.structure
    &#34;&#34;&#34;

    def __init__(
            self,
            *,
            parent: Optional[&#39;BaseStructure&#39;],
            field_type: Type[F]
    ):
        super().__init__()

        # Set specific ones so I have my own &#39;instance&#39; of them.
        self._name_to_type_hint_map = {}
        self._get_fields_cache = None

        # Copy all my attributes over from parent, for use as &#39;default&#39; values.
        if parent:
            self.__dict__.update(parent.__dict__)
            # noinspection PyProtectedMember
            # This parent is my own type/class, so I am fine accessing it&#39;s private member.
            self._name_to_type_hint_map = parent._name_to_type_hint_map.copy()

        self._get_fields_cache = None
        self.field_type = field_type
        self.internal_shared_api_values = {}

    def configure_for_model_type(
            self,
            *,  # &lt;-- means we don&#39;t support positional arguments
            model_type: Type[&#39;BaseModel&#39;],
            type_hints: Dict[str, Any],
    ):
        &#34;&#34;&#34;
        This EXPECTS to have passed-in the type-hints for my `BaseStructure.;
        see code inside `xmodel.base.model.BaseModel.__init_subclass__` for more details.
        There is no need to get the type-hints twice [it can be a bit expensive, trying to
        limit how may times I grab them]....

        See `xmodel.base.model.BaseModel` for more details on how Models work...
        This describes the options you
        can pass into a `xmodel.base.model.BaseModel` subclass at class-construction time.
        It allows you to customize how the Model class will work.

        This method will remember the options passed to it, but won&#39;t finish constructing the class
        until someone asks for it&#39;s `xmodel.base.model.BaseModel.api` attribute for the first
        time. This allows you
        to dynamically add more Field classes if needed. It also makes things import faster as
        we won&#39;t have to fully setup the class unless something tries to use it.

        Args:
            model_type (Type[xmodel.base.model.BaseModel]): The model we are associated with,
                this is what we are configuring ourselves against.
            type_hints (Dict[str, Any]): List of typehints via Python&#39;s `get_type_hints` method;
                Be aware that `get_type_hints` will try and resolve all type-hints, including
                ones that are forward references. Make sure these types are available at
                the module-level by the time `get_type_hints` runs.
        &#34;&#34;&#34;
        # Prep model class, remove any class Field objects...
        # These objects have been &#34;moved&#34; into me via `self.fields`.
        self._name_to_type_hint_map = type_hints
        self.model_cls = model_type
        for field_obj in self.fields:
            field_name = field_obj.name

            # The default values are inside `field_obj.default` now.
            # We delete the class-vars, so that `__getattr__` is called when someone attempts
            # to grab a value from a BaseModel for an attribute that does not directly exist
            # on the BaseModel subclass so we can do our normal field_obj.default resolution.
            # If the class keeps the value, it prevents `__getattr__` from being called for
            # attributes that don&#39;t exist directly on the model instance/object;
            # Python will instead grab and return the value set on the class for that attribute.
            #
            # todo/thoughts/brain-storm:
            #    Consider just using __getattribute__ for BaseModel instead of __getattr_...
            #    It&#39;s slightly slower but then I could have more flexablity around this...
            #    Thinking of returning the associated field-object if you do
            #    `BaseModelSubClass.some_attr_field` for various purposes....
            #    Using `__getattribute__` would allow for this....
            #    just something I have been thinking about...
            #    For example: you could use that field object as a query-key instead of a string
            #    with the field-name...
            #    might be nicer, and get auto-completion that way... not sure, thinking about it.
            #
            if field_name in self.model_cls.__dict__:
                delattr(self.model_cls, field_name)

    # --------------------------------------
    # --------- Environmental Properties ---------

    model_cls: &#34;Type[BaseModel]&#34;
    &#34;&#34;&#34;
    The model&#39;s class we are defining the structure for.
    This is typed as some sort of `xmodel.base.model.BaseModel`
    .
    This is NOT generically typed anymore, to get much better generically typed
    version you should use `xmodel.base.api.BaseApi.model_type` to get the BaseModel outside
    of the `xmodel.structure` module.
    Using that will give the IDE the correctly typed BaseModel class!
     &#34;&#34;&#34;

    # --------------------------------------
    # --------- General Properties ---------
    #
    # Most of these will be set inside __init_subclass__() via associated BaseModel Class.

    field_type: Type[F]
    &#34;&#34;&#34;
    Field type that this structure will use when auto-generating `xmodel.fields.Field`&#39;s.
    User defined Fields on a model-class will keep whatever type the user used.
    When `xmodel.base.model.BaseModel` class is constructed, and the `BaseStructure` is
    created, we will check to ensure all user-defined fields inherit from this field_type.

    That way you can assume any fields you get off this structure object inherit from
    field_type.
    &#34;&#34;&#34;

    internal_shared_api_values: Dict[Any, Any] = None
    &#34;&#34;&#34;
    A place an `xmodel.base.api.BaseApi` object can use to share values BaseModel-class wide
    (ie: for all BaseModel&#39;s of a specific type).

    This should NOT be used outside of the BaseApi class.
    For example, ``xmodel.base.api.BaseApi.client` stores it&#39;s object lazily here.
    Users outside of BaseApi class should simply ask it for the client and not try
    to go behind it&#39;s back and get it here.

    Code/Users outside of `xmodel.base.api.BaseApi` and it&#39;s subclasses can&#39;t assume
    anything about what&#39;s in this dictionary.  This exists for pure-convenience of the
    `xmodel.base.api.BaseApi` class.
    &#34;&#34;&#34;

    _name_to_type_hint_map: Dict[str, Any]
    &#34;&#34;&#34;
        .. deprecated:: v0.2.33 Use `BaseStructure.fields` instead to get a list of
            the real fields to use. And `xmodel.fields.Field.type_hint` to get the type-hint
            [don&#39;t get it here, keeping this temporary for backwards compatibility].

        A map of  attribute-name to type-hint type.

        .. important:: This WILL NOT take into account field-names where the `Field.name` is
            different then the name of the field on BaseModel the type-hint was assigned to.
    &#34;&#34;&#34;

    _get_fields_cache: Dict[str, F] = None

    @property
    def have_api_endpoint(self) -&gt; bool:
        &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
            That&#39;s determined right now via seeing if `BaseStructure.has_id_field_set()` is True.
        &#34;&#34;&#34;
        if not self.has_id_field():
            return False
        else:
            return True

    def __copy__(self):
        obj = type(self)(parent=self, field_type=self.field_type)
        obj.__dict__.update(self.__dict__)
        obj._name_to_type_hint_map = self._name_to_type_hint_map.copy()
        obj._get_fields_cache = None
        return obj

    def field_exists(self, name: str) -&gt; bool:
        &#34;&#34;&#34; Return `True` if the field with `name` exists on the model, otherwise `False`. &#34;&#34;&#34;
        return name in self.field_map

    def has_id_field(self):
        &#34;&#34;&#34; Defaults to False, returns True for RemoteStructure,
            What this property is really saying is if you can do a foreign-key to the related
            object/model.

            It may be better at some point in the long-run to rename this field to more indicate
            that; perhaps the next time we have a breaking-change we need to do for xmodel.

            For now, we are leaving the name along and hard-coding this to
            return False in BaseStructure, and to return True in RemoteStructure.
        &#34;&#34;&#34;
        return False

    def get_field(self, name: str) -&gt; Optional[F]:
        &#34;&#34;&#34;
        Args:
            name (str): Field name to query on.
        Returns:
            xmodel.fields.Field: If field object exists with `name`.

            None: If not field with `name` exists
        &#34;&#34;&#34;
        if name is None:
            return None
        return self.field_map.get(name)

    @property
    def fields(self) -&gt; List[F]:
        &#34;&#34;&#34; Returns:
                List[xmodel.fields.Field]: list of field objects.
        &#34;&#34;&#34;
        return list(self.field_map.values())

    @property
    def field_map(self) -&gt; Mapping[str, F]:
        &#34;&#34;&#34;

        Returns:
           Dict[str, xmodel.fields.Field]: Map of `xmodel.fields.Field.name` to
                `xmodel.fields.Field` objects.
        &#34;&#34;&#34;
        cached_content = self._get_fields_cache
        if cached_content is not None:
            # Mapping proxy is a read-only view of the passed in dict.
            # This will LIVE update the mapping if underlying dict changed.
            return MappingProxyType(cached_content)

        generated_fields = self._generate_fields()
        self._get_fields_cache = generated_fields
        return MappingProxyType(generated_fields)

    def excluded_field_map(self) -&gt; Dict[str, F]:
        &#34;&#34;&#34;
        Returns:
            Dict[str, xmodel.fields.Field]: Mapping of `xmodel.fields.Field.name` to
                field objects that are excluded (`xmodel.fields.Field.exclude` == `True`).
        &#34;&#34;&#34;
        return {f.name: f for f in self.fields if f.exclude}

    def _generate_fields(self) -&gt; Dict[str, F]:
        &#34;&#34;&#34; Goes though object and grabs/generated Field objects and caches them in self.
            Gives back the definitive list of Field objects.

            For now keeping this private, but may open it up in the future if sub-classes
            need to customize how fields are generated.
        &#34;&#34;&#34;
        full_field_map = {}

        default_field_type: Type[Field] = self.field_type
        type_hint_map = self._name_to_type_hint_map
        model_cls = self.model_cls

        # todo: Figure out how to put this into/consolidate into
        #  `xmodel.base.api.BaseApi`; and simplify stuff!!!
        default_converters = getattr(self.model_cls.api, &#39;default_converters&#39;)

        # todo:  default_con ^^^^ make sure we are using it!!!!

        # Lazy-import BaseModel, we need to check to see if we have a sub-class or not...
        from xmodel import BaseModel

        # This will be a collection of any Fields that exist on the parent(s), merged together...
        base_fields: Dict[str, Field] = {}

        # go though parent and find any Field objects, grab latest version
        # which is the one closest to child on a per-field basis...
        # we exclude it&#39;s self [the model we are currently working with].
        for base in reversed(model_cls.__mro__[1:]):
            base: Type[BaseModel]
            if not inspect.isclass(base):
                continue
            if not issubclass(base, BaseModel):
                continue
            if not base.api:
                # `base` is likely xmodel.base.model.BaseModel; and that has no API allocated
                # to it
                # at the moment [mostly because the __init_subclasses is only executed on sub&#39;s].
                # todo: BaseModel is an abstract class... do we really need structure/fields on it?
                continue
            # todo:  ensure we later on use these and make a new field if needed...
            base_fields.update(base.api.structure.field_map)

        for name, type_hint in type_hint_map.items():
            # Ignore the &#39;api&#39; attribute, it&#39;s special.
            if name == &#39;api&#39;:
                continue

            # Ignore anything the starts with &#39;_&#39;.
            if name.startswith(&#34;_&#34;):
                continue

            # todo:
            #   1. Get Parent Field&#39;s, merge values.
            #   2. Map all type&#39;s and if not map then raise error.

            # noinspection PyArgumentList
            field_obj: Field
            field_value: Field = getattr(model_cls, name, Default)
            if isinstance(field_value, Field):
                field_obj = field_value
                field_value = Default
            elif field_value is not Default:
                if not inspect.isclass(field_value) and isinstance(field_value, property):
                    field_obj = default_field_type(fget=field_value.fget, fset=field_value.fset)
                else:
                    # noinspection PyArgumentList
                    field_obj = default_field_type(default=field_value)
            else:
                # noinspection PyArgumentList
                field_obj = default_field_type()

            # Name can be overridden, we want to use it to lookup parent field name....
            if field_obj.name:
                name = field_obj.name

            field_obj.resolve_defaults(
                name=name,
                type_hint=type_hint_map.get(name, None),
                default_converter_map=default_converters,
                parent_field=base_fields.get(name)
            )

            # Ensure all fields that still have `Default` as their value are resolved to None.
            field_obj.resolve_remaining_defaults_to_none()

            # field-object will unwrap the type-hint for us.
            type_hint = field_obj.type_hint

            # Name can be overridden, we want to use whatever it says we should be using.
            name = field_obj.name
            full_field_map[field_obj.name] = field_obj

            # If we have a converter, we can assume that will take care of things correctly
            # for whatever type we have.  If we don&#39;t have a converter, we only support specific
            # types; We check here for type-compatibility.
            from xmodel import BaseModel
            if (
                not field_obj.converter and
                type_hint not in supported_basic_types and
                (not inspect.isclass(type_hint) or not issubclass(type_hint, BaseModel)) and
                typing_inspect.get_origin(type_hint) not in (list, set)
            ):
                raise XModelError(
                    f&#34;Unsupported type ({type_hint}) with field-name ({name}) &#34;
                    f&#34;for model-class ({model_cls}) in field-obj ({field_obj}).&#34;
                )

            if (
                field_obj.json_path and
                field_obj.json_path != field_obj.name and
                field_obj.related_type
            ):
                XModelError(
                    &#34;Right now obj-relationships can&#39;t use the &#39;json_path&#39; option &#34;
                    &#34;while at the same time being obj-relationships. Must use basic field &#34;
                    &#34;with api_path. &#34;

                    # Copy/Paste from `BaseApi.json`:
                    f&#34;Can&#39;t have xmodel.Field on BaseModel with related-type and a json_path &#34;
                    f&#34;that differ at the moment, for field ({field_obj}). &#34;
                    f&#34;It is something I want to support someday; the support is mostly in place &#34;
                    f&#34;already, but it needs some more careful thought, attention and testing &#34;
                    f&#34;before we should allow it. &#34;
                    &#34;Workaround:  Make an `{field.name}_id` field next to related field on the &#34;
                    &#34;model. Then, set `json_path` for that `{field.name}_id` field, set it to &#34;
                    &#34;what you want it to be. Finally, set the `{related_field.name}` to &#34;
                    &#34;read_only=True. This allows you to rename the `_id` field used to/from api &#34;
                    &#34;in the JSON input/output, but the Model can have an alternate name for the &#34;
                    &#34;related field. You can see a real-example of this at &#34;
                    &#34;`bigcommerce.api.orders._BcCommonOrderMetafield.order&#34;
                )

        # todo: Provide a &#39;remove&#39; option in the Field config class.
        if &#39;id&#39; not in full_field_map:

            # Go though and populate the `Field.field_for_foreign_key_related_field` as needed...
            for k, f in full_field_map.items():
                # If there is a relate field name, and we have a field defined for it...
                # Set it&#39;s field_for_foreign_key_related_field so the correct field...
                # Otherwise generate a field object for this key-field.
                #
                # FYI: The `resolve_defaults` call above will always set
                #      field_for_foreign_key_related_field to None.
                #      We then set it to something here if needed.
                if f.related_field_name_for_id:
                    related_field = full_field_map.get(f.related_field_name_for_id)
                    if related_field:
                        related_field.field_for_foreign_key_related_field = f

        return full_field_map

    def id_cache_key(self, _id):
        &#34;&#34;&#34; Returns a proper key to use for `xmodel.base.client.BaseClient.cache_get`
            and other caching methods for id-based lookup of an object.
        &#34;&#34;&#34;
        if type(_id) is dict:
            # todo: Put module name in this key.
            key = f&#34;{self.model_cls.__name__}&#34;
            try:
                sorted_keys = sorted(_id.keys())
            except TypeError:
                sorted_keys = _id.keys()
            for key_name in sorted_keys:
                key += f&#34;-{key_name}-{_id[key_name]}&#34;
            return key
        else:
            return f&#34;{self.model_cls.__name__}-id-{_id}&#34;

    # todo: Get rid of this [only used by Dynamo right now]. Need to use Field instead...
    def get_unwraped_typehint(self, field_name: str):
        &#34;&#34;&#34;
        This is now done for you on `xmodel.fields.Field.type_hint`, so you can just grab it
        directly your self now.

        Gets typehint for field_name and calls `xmodel.types.unwrap_optional_type`
        on it to try and get the plain type-hint as best as we can.
        &#34;&#34;&#34;
        field = self.get_field(field_name)
        if field is None:
            return None

        return field.type_hint

    def is_field_a_child(self, child_field_name, *, and_has_id=False):
        &#34;&#34;&#34;
        True if the field is a child, otherwise False.  Will still return `False` if
        `and_has_id` argument is `True` and the related type is configured to not use id via class
        argument `has_id_field=False` (see `BaseStructure.configure_for_model_type` for more
        details on class arguments).

        Won&#39;t raise an exception if field does not exist.

        Args:
            child_field_name (str): Name of field to check.
            and_has_id (bool): If True, then return False if related type is not configured to
                use id.
        Returns:
            bool: `True` if this field is a child field, otherwise `False`.
        &#34;&#34;&#34;
        field = self.get_field(child_field_name)
        if not field:
            return False

        related_type = field.related_type
        if not related_type:
            return False

        related_structure = related_type.api.structure
        if and_has_id and not related_structure.has_id_field():
            return False

        return True

    @property
    def endpoint_description(self):
        &#34;&#34;&#34; Gives some sort of basic descriptive string that contains the path/table-name/etc
            that basically indicates the api endpoint being used.

            This is meant for logging and other human readability/debugging purposes.
            Feel free to change the string to whatever is most useful to know.

            I expect this to be overridden by the concrete implementation, see examples here:

            - `xmodel.rest.RestStructure.endpoint_description`
            - `xmodel.dynamo.DynStructure.endpoint_description`
        &#34;&#34;&#34;
        return &#34;?&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.remote.structure.RemoteStructure" href="remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.BaseStructure.field_type"><code class="name">var <span class="ident">field_type</span> :Â Type[~F]</code></dt>
<dd>
<div class="desc"><p>Field type that this structure will use when auto-generating <code>xmodel.fields.Field</code>'s.
User defined Fields on a model-class will keep whatever type the user used.
When <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> class is constructed, and the <code><a title="xmodel.BaseStructure" href="#xmodel.BaseStructure">BaseStructure</a></code> is
created, we will check to ensure all user-defined fields inherit from this field_type.</p>
<p>That way you can assume any fields you get off this structure object inherit from
field_type.</p></div>
</dd>
<dt id="xmodel.BaseStructure.internal_shared_api_values"><code class="name">var <span class="ident">internal_shared_api_values</span> :Â Dict[Any,Â Any]</code></dt>
<dd>
<div class="desc"><p>A place an <code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> object can use to share values BaseModel-class wide
(ie: for all BaseModel's of a specific type).</p>
<p>This should NOT be used outside of the BaseApi class.
For example, <code>`xmodel.base.api.BaseApi.client</code> stores it's object lazily here.
Users outside of BaseApi class should simply ask it for the client and not try
to go behind it's back and get it here.</p>
<p>Code/Users outside of <code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> and it's subclasses can't assume
anything about what's in this dictionary.
This exists for pure-convenience of the
<code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> class.</p></div>
</dd>
<dt id="xmodel.BaseStructure.model_cls"><code class="name">var <span class="ident">model_cls</span> :Â Type[<a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>]</code></dt>
<dd>
<div class="desc"><p>The model's class we are defining the structure for.
This is typed as some sort of <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
.
This is NOT generically typed anymore, to get much better generically typed
version you should use <code><a title="xmodel.base.api.BaseApi.model_type" href="base/api.html#xmodel.base.api.BaseApi.model_type">BaseApi.model_type</a></code> to get the BaseModel outside
of the <code>xmodel.structure</code> module.
Using that will give the IDE the correctly typed BaseModel class!</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.BaseStructure.endpoint_description"><code class="name">var <span class="ident">endpoint_description</span></code></dt>
<dd>
<div class="desc"><p>Gives some sort of basic descriptive string that contains the path/table-name/etc
that basically indicates the api endpoint being used.</p>
<p>This is meant for logging and other human readability/debugging purposes.
Feel free to change the string to whatever is most useful to know.</p>
<p>I expect this to be overridden by the concrete implementation, see examples here:</p>
<ul>
<li><code>xmodel.rest.RestStructure.endpoint_description</code></li>
<li><code>xmodel.dynamo.DynStructure.endpoint_description</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endpoint_description(self):
    &#34;&#34;&#34; Gives some sort of basic descriptive string that contains the path/table-name/etc
        that basically indicates the api endpoint being used.

        This is meant for logging and other human readability/debugging purposes.
        Feel free to change the string to whatever is most useful to know.

        I expect this to be overridden by the concrete implementation, see examples here:

        - `xmodel.rest.RestStructure.endpoint_description`
        - `xmodel.dynamo.DynStructure.endpoint_description`
    &#34;&#34;&#34;
    return &#34;?&#34;</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.field_map"><code class="name">var <span class="ident">field_map</span> :Â Mapping[str,Â ~F]</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Map of <code>xmodel.fields.Field.name</code> to
<code>xmodel.fields.Field</code> objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def field_map(self) -&gt; Mapping[str, F]:
    &#34;&#34;&#34;

    Returns:
       Dict[str, xmodel.fields.Field]: Map of `xmodel.fields.Field.name` to
            `xmodel.fields.Field` objects.
    &#34;&#34;&#34;
    cached_content = self._get_fields_cache
    if cached_content is not None:
        # Mapping proxy is a read-only view of the passed in dict.
        # This will LIVE update the mapping if underlying dict changed.
        return MappingProxyType(cached_content)

    generated_fields = self._generate_fields()
    self._get_fields_cache = generated_fields
    return MappingProxyType(generated_fields)</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.fields"><code class="name">var <span class="ident">fields</span> :Â List[~F]</code></dt>
<dd>
<div class="desc"><p>Returns:
List[xmodel.fields.Field]: list of field objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fields(self) -&gt; List[F]:
    &#34;&#34;&#34; Returns:
            List[xmodel.fields.Field]: list of field objects.
    &#34;&#34;&#34;
    return list(self.field_map.values())</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.have_api_endpoint"><code class="name">var <span class="ident">have_api_endpoint</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
That's determined right now via seeing if <code>BaseStructure.has_id_field_set()</code> is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def have_api_endpoint(self) -&gt; bool:
    &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
        That&#39;s determined right now via seeing if `BaseStructure.has_id_field_set()` is True.
    &#34;&#34;&#34;
    if not self.has_id_field():
        return False
    else:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.BaseStructure.configure_for_model_type"><code class="name flex">
<span>def <span class="ident">configure_for_model_type</span></span>(<span>self, *, model_type:Â Type[ForwardRef('<a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>')], type_hints:Â Dict[str,Â Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This EXPECTS to have passed-in the type-hints for my `BaseStructure.;
see code inside <code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="base/model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code> for more details.
There is no need to get the type-hints twice [it can be a bit expensive, trying to
limit how may times I grab them]....</p>
<p>See <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> for more details on how Models work&hellip;
This describes the options you
can pass into a <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> subclass at class-construction time.
It allows you to customize how the Model class will work.</p>
<p>This method will remember the options passed to it, but won't finish constructing the class
until someone asks for it's <code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> attribute for the first
time. This allows you
to dynamically add more Field classes if needed. It also makes things import faster as
we won't have to fully setup the class unless something tries to use it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code>Type[<a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a>]</code></dt>
<dd>The model we are associated with,
this is what we are configuring ourselves against.</dd>
<dt><strong><code>type_hints</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>List of typehints via Python's <code>get_type_hints</code> method;
Be aware that <code>get_type_hints</code> will try and resolve all type-hints, including
ones that are forward references. Make sure these types are available at
the module-level by the time <code>get_type_hints</code> runs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_for_model_type(
        self,
        *,  # &lt;-- means we don&#39;t support positional arguments
        model_type: Type[&#39;BaseModel&#39;],
        type_hints: Dict[str, Any],
):
    &#34;&#34;&#34;
    This EXPECTS to have passed-in the type-hints for my `BaseStructure.;
    see code inside `xmodel.base.model.BaseModel.__init_subclass__` for more details.
    There is no need to get the type-hints twice [it can be a bit expensive, trying to
    limit how may times I grab them]....

    See `xmodel.base.model.BaseModel` for more details on how Models work...
    This describes the options you
    can pass into a `xmodel.base.model.BaseModel` subclass at class-construction time.
    It allows you to customize how the Model class will work.

    This method will remember the options passed to it, but won&#39;t finish constructing the class
    until someone asks for it&#39;s `xmodel.base.model.BaseModel.api` attribute for the first
    time. This allows you
    to dynamically add more Field classes if needed. It also makes things import faster as
    we won&#39;t have to fully setup the class unless something tries to use it.

    Args:
        model_type (Type[xmodel.base.model.BaseModel]): The model we are associated with,
            this is what we are configuring ourselves against.
        type_hints (Dict[str, Any]): List of typehints via Python&#39;s `get_type_hints` method;
            Be aware that `get_type_hints` will try and resolve all type-hints, including
            ones that are forward references. Make sure these types are available at
            the module-level by the time `get_type_hints` runs.
    &#34;&#34;&#34;
    # Prep model class, remove any class Field objects...
    # These objects have been &#34;moved&#34; into me via `self.fields`.
    self._name_to_type_hint_map = type_hints
    self.model_cls = model_type
    for field_obj in self.fields:
        field_name = field_obj.name

        # The default values are inside `field_obj.default` now.
        # We delete the class-vars, so that `__getattr__` is called when someone attempts
        # to grab a value from a BaseModel for an attribute that does not directly exist
        # on the BaseModel subclass so we can do our normal field_obj.default resolution.
        # If the class keeps the value, it prevents `__getattr__` from being called for
        # attributes that don&#39;t exist directly on the model instance/object;
        # Python will instead grab and return the value set on the class for that attribute.
        #
        # todo/thoughts/brain-storm:
        #    Consider just using __getattribute__ for BaseModel instead of __getattr_...
        #    It&#39;s slightly slower but then I could have more flexablity around this...
        #    Thinking of returning the associated field-object if you do
        #    `BaseModelSubClass.some_attr_field` for various purposes....
        #    Using `__getattribute__` would allow for this....
        #    just something I have been thinking about...
        #    For example: you could use that field object as a query-key instead of a string
        #    with the field-name...
        #    might be nicer, and get auto-completion that way... not sure, thinking about it.
        #
        if field_name in self.model_cls.__dict__:
            delattr(self.model_cls, field_name)</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.excluded_field_map"><code class="name flex">
<span>def <span class="ident">excluded_field_map</span></span>(<span>self) â€‘>Â Dict[str,Â ~F]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Mapping of <code>xmodel.fields.Field.name</code> to
field objects that are excluded (<code>xmodel.fields.Field.exclude</code> == <code>True</code>).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def excluded_field_map(self) -&gt; Dict[str, F]:
    &#34;&#34;&#34;
    Returns:
        Dict[str, xmodel.fields.Field]: Mapping of `xmodel.fields.Field.name` to
            field objects that are excluded (`xmodel.fields.Field.exclude` == `True`).
    &#34;&#34;&#34;
    return {f.name: f for f in self.fields if f.exclude}</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.field_exists"><code class="name flex">
<span>def <span class="ident">field_exists</span></span>(<span>self, name:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if the field with <code>name</code> exists on the model, otherwise <code>False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_exists(self, name: str) -&gt; bool:
    &#34;&#34;&#34; Return `True` if the field with `name` exists on the model, otherwise `False`. &#34;&#34;&#34;
    return name in self.field_map</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, name:Â str) â€‘>Â Optional[~F]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Field name to query on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xmodel.fields.Field</code></dt>
<dd>If field object exists with <code>name</code>.</dd>
<dt><code>None</code></dt>
<dd>If not field with <code>name</code> exists</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field(self, name: str) -&gt; Optional[F]:
    &#34;&#34;&#34;
    Args:
        name (str): Field name to query on.
    Returns:
        xmodel.fields.Field: If field object exists with `name`.

        None: If not field with `name` exists
    &#34;&#34;&#34;
    if name is None:
        return None
    return self.field_map.get(name)</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.get_unwraped_typehint"><code class="name flex">
<span>def <span class="ident">get_unwraped_typehint</span></span>(<span>self, field_name:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is now done for you on <code>xmodel.fields.Field.type_hint</code>, so you can just grab it
directly your self now.</p>
<p>Gets typehint for field_name and calls <code>xmodel.types.unwrap_optional_type</code>
on it to try and get the plain type-hint as best as we can.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unwraped_typehint(self, field_name: str):
    &#34;&#34;&#34;
    This is now done for you on `xmodel.fields.Field.type_hint`, so you can just grab it
    directly your self now.

    Gets typehint for field_name and calls `xmodel.types.unwrap_optional_type`
    on it to try and get the plain type-hint as best as we can.
    &#34;&#34;&#34;
    field = self.get_field(field_name)
    if field is None:
        return None

    return field.type_hint</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.has_id_field"><code class="name flex">
<span>def <span class="ident">has_id_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defaults to False, returns True for RemoteStructure,
What this property is really saying is if you can do a foreign-key to the related
object/model.</p>
<p>It may be better at some point in the long-run to rename this field to more indicate
that; perhaps the next time we have a breaking-change we need to do for xmodel.</p>
<p>For now, we are leaving the name along and hard-coding this to
return False in BaseStructure, and to return True in RemoteStructure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_id_field(self):
    &#34;&#34;&#34; Defaults to False, returns True for RemoteStructure,
        What this property is really saying is if you can do a foreign-key to the related
        object/model.

        It may be better at some point in the long-run to rename this field to more indicate
        that; perhaps the next time we have a breaking-change we need to do for xmodel.

        For now, we are leaving the name along and hard-coding this to
        return False in BaseStructure, and to return True in RemoteStructure.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.id_cache_key"><code class="name flex">
<span>def <span class="ident">id_cache_key</span></span>(<span>self, _id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a proper key to use for <code>xmodel.base.client.BaseClient.cache_get</code>
and other caching methods for id-based lookup of an object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_cache_key(self, _id):
    &#34;&#34;&#34; Returns a proper key to use for `xmodel.base.client.BaseClient.cache_get`
        and other caching methods for id-based lookup of an object.
    &#34;&#34;&#34;
    if type(_id) is dict:
        # todo: Put module name in this key.
        key = f&#34;{self.model_cls.__name__}&#34;
        try:
            sorted_keys = sorted(_id.keys())
        except TypeError:
            sorted_keys = _id.keys()
        for key_name in sorted_keys:
            key += f&#34;-{key_name}-{_id[key_name]}&#34;
        return key
    else:
        return f&#34;{self.model_cls.__name__}-id-{_id}&#34;</code></pre>
</details>
</dd>
<dt id="xmodel.BaseStructure.is_field_a_child"><code class="name flex">
<span>def <span class="ident">is_field_a_child</span></span>(<span>self, child_field_name, *, and_has_id=False)</span>
</code></dt>
<dd>
<div class="desc"><p>True if the field is a child, otherwise False.
Will still return <code>False</code> if
<code>and_has_id</code> argument is <code>True</code> and the related type is configured to not use id via class
argument <code>has_id_field=False</code> (see <code><a title="xmodel.BaseStructure.configure_for_model_type" href="#xmodel.BaseStructure.configure_for_model_type">BaseStructure.configure_for_model_type()</a></code> for more
details on class arguments).</p>
<p>Won't raise an exception if field does not exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>child_field_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of field to check.</dd>
<dt><strong><code>and_has_id</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, then return False if related type is not configured to
use id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if this field is a child field, otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_field_a_child(self, child_field_name, *, and_has_id=False):
    &#34;&#34;&#34;
    True if the field is a child, otherwise False.  Will still return `False` if
    `and_has_id` argument is `True` and the related type is configured to not use id via class
    argument `has_id_field=False` (see `BaseStructure.configure_for_model_type` for more
    details on class arguments).

    Won&#39;t raise an exception if field does not exist.

    Args:
        child_field_name (str): Name of field to check.
        and_has_id (bool): If True, then return False if related type is not configured to
            use id.
    Returns:
        bool: `True` if this field is a child field, otherwise `False`.
    &#34;&#34;&#34;
    field = self.get_field(child_field_name)
    if not field:
        return False

    related_type = field.related_type
    if not related_type:
        return False

    related_structure = related_type.api.structure
    if and_has_id and not related_structure.has_id_field():
        return False

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel.Converter"><code class="flex name class">
<span>class <span class="ident">Converter</span></span>
</code></dt>
<dd>
<div class="desc"><p>This is meant to be a Callable that converts to/from a type when a value is assigned
to a <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.</p>
<p>See <code>Converter.__call__</code> for the calling interface.</p>
<p>You can set these on <code><a title="xmodel.Field.converter" href="#xmodel.Field.converter">Field.converter</a></code> or <code><a title="xmodel.base.api.BaseApi.default_converters" href="base/api.html#xmodel.base.api.BaseApi.default_converters">BaseApi.default_converters</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Converter:
    &#34;&#34;&#34; This is meant to be a Callable that converts to/from a type when a value is assigned
        to a `xmodel.base.model.BaseModel`.

        See `Converter.__call__` for the calling interface.

        You can set these on `Field.converter` or `xmodel.base.api.BaseApi.default_converters`.
    &#34;&#34;&#34;
    class Direction(Enum):
        &#34;&#34;&#34; Possible values for field option keys. &#34;&#34;&#34;
        to_json = EnumAuto()
        &#34;&#34;&#34; We are converting from BaseModel into JSON. &#34;&#34;&#34;
        from_json = EnumAuto()
        &#34;&#34;&#34; We are converting from JSON and need value to set on BaseModel. &#34;&#34;&#34;
        to_model = EnumAuto()
        &#34;&#34;&#34; We are setting a value on the BaseModel [could be coming from anywhere]. &#34;&#34;&#34;

    def __call__(
            self,
            api: &#34;BaseApi&#34;,
            direction: Direction,  # todo: Used to be &#39;to_json&#39;, need to fix it everywhere...
            field: &#34;Field&#34;,  # todo: this is a new param, use to be &#39;field_name&#39;...
            value: Any,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Gets called when something needs to be converted.

        By default, this will call one of these depending on the direction:

        - `Converter.to_json`
        - `Converter.from_json`
        - `Converter.to_model`

        Args:
            api (xmodel.base.api.BaseApi): This has the associated
                `xmodel.base.model.BaseModel.api` object, from which we need a value converted.
            direction (Converter.Direction): Look at `Converter.Direction` for details.
            field (str): Field information, this contains the name, types, etc...
            value (Any): The value that needs to be converted.
        &#34;&#34;&#34;
        Direction = Converter.Direction  # noqa
        if direction == Direction.to_json:
            return self.to_json(api, field, value)

        if direction == Direction.from_json:
            return self.from_json(api, field, value)

        if direction == Direction.to_model:
            return self.to_model(api, field, value)

    # Instead of implementing `__call__`, you can implement of these instead if that&#39;s easier.
    def to_json(self, api: &#39;BaseApi&#39;, field: &#39;Field&#39;, value: Any):
        &#34;&#34;&#34; todo &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Converter ({self}) has no __call__ or to_json method which does the conversion.&#34;
        )

    def from_json(self, api: &#39;BaseApi&#39;, field: &#39;Field&#39;, value: Any):
        &#34;&#34;&#34; todo &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Converter ({self}) has no __call__ or from_json method which does the conversion.&#34;
        )

    def to_model(self, api: &#39;BaseApi&#39;, field: &#39;Field&#39;, value: Any):
        &#34;&#34;&#34; todo &#34;&#34;&#34;
        raise NotImplementedError(
            f&#34;Converter ({self}) has no __call__ or to_model method which does the conversion.&#34;
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.converters.ConvertBasicType" href="converters.html#xmodel.converters.ConvertBasicType">ConvertBasicType</a></li>
<li><a title="xmodel.converters.EnumConverter" href="converters.html#xmodel.converters.EnumConverter">EnumConverter</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.Converter.Direction"><code class="name">var <span class="ident">Direction</span></code></dt>
<dd>
<div class="desc"><p>Possible values for field option keys.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.Converter.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, api:Â <a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a>, field:Â <a title="xmodel.Field" href="#xmodel.Field">Field</a>, value:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>todo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, api: &#39;BaseApi&#39;, field: &#39;Field&#39;, value: Any):
    &#34;&#34;&#34; todo &#34;&#34;&#34;
    raise NotImplementedError(
        f&#34;Converter ({self}) has no __call__ or from_json method which does the conversion.&#34;
    )</code></pre>
</details>
</dd>
<dt id="xmodel.Converter.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, api:Â <a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a>, field:Â <a title="xmodel.Field" href="#xmodel.Field">Field</a>, value:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>todo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, api: &#39;BaseApi&#39;, field: &#39;Field&#39;, value: Any):
    &#34;&#34;&#34; todo &#34;&#34;&#34;
    raise NotImplementedError(
        f&#34;Converter ({self}) has no __call__ or to_json method which does the conversion.&#34;
    )</code></pre>
</details>
</dd>
<dt id="xmodel.Converter.to_model"><code class="name flex">
<span>def <span class="ident">to_model</span></span>(<span>self, api:Â <a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a>, field:Â <a title="xmodel.Field" href="#xmodel.Field">Field</a>, value:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>todo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_model(self, api: &#39;BaseApi&#39;, field: &#39;Field&#39;, value: Any):
    &#34;&#34;&#34; todo &#34;&#34;&#34;
    raise NotImplementedError(
        f&#34;Converter ({self}) has no __call__ or to_model method which does the conversion.&#34;
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>name:Â strÂ =Â Default, type_hint:Â Type[+CT_co]Â =Â &lt;property object&gt;, nullable:Â boolÂ =Â Default, read_only:Â boolÂ =Â Default, exclude:Â boolÂ =Â Default, default:Â AnyÂ =Â Default, post_filter:Â Optional[<a title="xmodel.base.fields.Filter" href="base/fields.html#xmodel.base.fields.Filter">Filter</a>]Â =Â Default, converter:Â Optional[<a title="xmodel.base.fields.Converter" href="base/fields.html#xmodel.base.fields.Converter">Converter</a>]Â =Â Default, fget:Â Optional[Callable[[M],Â Any]]Â =Â Default, fset:Â Optional[Callable[[<a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>,Â Any],Â None]]Â =Â Default, include_with_fields:Â Set[str]Â =Â Default, json_path:Â strÂ =Â Default, json_path_separator:Â strÂ =Â Default, include_in_repr:Â boolÂ =Â Default, related_type:Â Optional[Type[<a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>]]Â =Â Default, related_field_name_for_id:Â Optional[str]Â =Â Default, related_to_many:Â boolÂ =Â Default, model:Â <a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>Â =Â Default)</span>
</code></dt>
<dd>
<div class="desc"><p>If this is not used on a model field/attribute, the field will get the default set of
options automatically if the field has a type-hint; see topic
<a href="./#model-fields">BaseModel Fields</a>.</p>
<p>Preferred way going forward to provide additional options/configuration to BaseModel fields.</p>
<p>If you don't specify a value for a particular attribute, it will have the
<code><a title="xsentinels.default.Default" href="../xsentinels/default.html#xsentinels.default.Default">Default</a></code> value. When a Default value is encountered while constructing a
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>, it will resolve these Default values and assign the final
value for the field.</p>
<p>To resolve these Defaults, it will look at field on the parent BaseModel class.
If a non-Default value is defined there, it will use that for the child.
If not, then it looks at the next parent. If no non-Default value is found we then use
a value that makes sense. You can see what this is in the first line of each doc-comment.
In the future, when we start using Python 3.9 we can use type annotations (typing.Annotated)
to annotate a specific value to the Default type generically. For now it's hard-coded.</p>
<h2 id="side-notes">Side Notes</h2>
<p>Keep in mind that after the <code>.api</code> is accessed for the first time on a particular model
class, the sdk will construct the rest of the class (lazily)&hellip;
it will read and then remove/delete from the BaseModel class any type-hinted json fields
with a Field object assigned to the class. It moves these Field objects into a special
internal structure.
The class gets <code>None</code> values set on all fields after this is done.</p>
<h2 id="details-on-why-we-remove-them">Details on why we remove them:</h2>
<p>Doing this helps with <strong>getattr</strong>, as it will still be executed for fields without a value
when we create an object instance. <strong>getattr</strong> is used to support lazy lookups [via API] of
related objects. Using <strong>getattr</strong> is much faster than using the <strong>getattribute</strong> version.
So I want to keep using the <strong>getattr</strong> version if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field:
    &#34;&#34;&#34;
    If this is not used on a model field/attribute, the field will get the default set of
    options automatically if the field has a type-hint; see topic
    [BaseModel Fields](./#model-fields).

    Preferred way going forward to provide additional options/configuration to BaseModel fields.

    If you don&#39;t specify a value for a particular attribute, it will have the
    `xsentinels.default.Default` value. When a Default value is encountered while constructing a
    `xmodel.base.model.BaseModel`, it will resolve these Default values and assign the final
    value for the field.

    To resolve these Defaults, it will look at field on the parent BaseModel class.
    If a non-Default value is defined there, it will use that for the child.
    If not, then it looks at the next parent. If no non-Default value is found we then use
    a value that makes sense. You can see what this is in the first line of each doc-comment.
    In the future, when we start using Python 3.9 we can use type annotations (typing.Annotated)
    to annotate a specific value to the Default type generically. For now it&#39;s hard-coded.

    ## Side Notes

    Keep in mind that after the `.api` is accessed for the first time on a particular model
    class, the sdk will construct the rest of the class (lazily)...
    it will read and then remove/delete from the BaseModel class any type-hinted json fields
    with a Field object assigned to the class. It moves these Field objects into a special
    internal structure.  The class gets `None` values set on all fields after this is done.

    ## Details on why we remove them:

    Doing this helps with __getattr__, as it will still be executed for fields without a value
    when we create an object instance. __getattr__ is used to support lazy lookups [via API] of
    related objects. Using __getattr__ is much faster than using the __getattribute__ version.
    So I want to keep using the __getattr__ version if possible.
    &#34;&#34;&#34;

    _options_explicitly_set_by_user: Set[str] = dataclasses.field(default=None, repr=False)

    def was_option_explicitly_set_by_user(self, option_name: str) -&gt; bool:
        &#34;&#34;&#34; Given an option / field-attribute name, if the option was explicitly set by
            the user then we return True.

            If not we return False.

            We determine this while `Field.resolve_defaults` is called, it checks to see
            what is still set to `Default`.

            If an option is not `Default` anymore when `resolve_defaults` is first called, we
            consider it set by the user.

            This is important, as it informs subclasses of BaseModel if their parent model&#39;s
            field&#39;s value was resolved automatically or if it was set by user.

            Generally, if it was resolved automatically, we continue to resolve it automatically.

            If it was set by the user we tend to use what the user set it to and not resolve
            it automatically.
        &#34;&#34;&#34;
        return option_name in self._options_explicitly_set_by_user

    def resolve_defaults(
            self,
            *,  # Keyword args only after this point
            name,
            type_hint: Type,
            default_converter_map: Optional[Dict[Type, Converter]] = None,
            parent_field: &#34;Field&#34; = None
    ):
        &#34;&#34;&#34;
        Resolves all dataclass attributes/fields on self that are still set to `Default`.
        The only exception is `type_hint`. We will always use what is passed in, regardless
        of if there is a parent-field with one set. This allows one on a BaseModel to easily
        override the type-hint without having to create a field with an explicitly set
        type_hint set on it (ie: let normal python annotated type-hint override any parent type).

        This includes ones on subclasses [dataclass will generically tell us about all of them].
        System calls this when a BaseModel class is being lazily constructed
        [ie: when gets the `xmodel.base.model.BaseModel.api` attribute for the first time or
        attempts to create an instance of the BaseModel for the fist time].

        When the BaseModel class is being constructed, this method is called to resolve all
        the Default values still on the instance. We do this by:

        1. We first look at parent_field object if one has been given.
            - If ask that parent field which options where explicitly set by user and which
                ones were set by resolving a `xsentinels.default.Default`. Field objects have an
                internal/private var that keeps track of this.
        2. Next, figure out standard default value for option if option&#39;s current value is
            current at `xsentinels.default.Default` (a default sentential value, used to detect
            which values were left unset by user).


        ## More Details

        I have Field objects keep track of which fields were not at
        Default when they are resolved. This allows child Field objects
        to know which values to copy into themselves and which ones
        should be resolved normally via Default.

        The goal here is to avoid copying value from Parent that
        were originally resolved via Default mechanism
        (and were not set explicitly by user).

        An example of why this is handy:

        If we have a parent model with a field of a different type vs the one on the child.
        Unless the converter was explicitly set by the user we want to just use the default
        converter for the different type on the child (and not use the wrong converter by default).
        &#34;&#34;&#34;

        # Get pycharm to go to class-level var/typehint with the attribute docs we have written
        # instead of going into this method where it gets assigned.
        # Using different var-name for self seems to be able to do that.
        _self = self

        if parent_field:
            options_explicitly_set_by_user = parent_field._options_explicitly_set_by_user
        else:
            options_explicitly_set_by_user = set()

        # Keep track of what was Default before resolving with parent
        # [ie: was not explicitly set by user].
        was_default_before_parent = set()

        for data_field in dataclasses.fields(self):
            data_field_name = data_field.name
            child_value = getattr(self, data_field_name)
            if child_value is Default:
                was_default_before_parent.add(data_field_name)
            else:
                options_explicitly_set_by_user.add(data_field_name)

        # Store for future child-fields.
        self._options_explicitly_set_by_user = options_explicitly_set_by_user

        if parent_field:
            if not isinstance(self, type(parent_field)):
                raise XModelError(
                    f&#34;Child field {self} must be same or subclass of parent ({parent_field}).&#34;
                )

            # Go though each dataclass Field in parent, take it&#39;s value and copy it to child if:
            #   1. The child still has it set to `Default`.
            #   2. The parent&#39;s value is not `Default`.
            #   3. The parent&#39;s value was set by the user (options_explicitly_set_by_user).
            #       - If the value was not set by user, we just leave us at `Default` and resolve
            #           them normally.
            for parent_data_field in dataclasses.fields(parent_field):
                p_attr_field: dataclasses.Field
                data_field_name = parent_data_field.name
                parent_value = getattr(parent_field, data_field_name)
                child_value = getattr(self, data_field_name)

                if parent_value is Default:
                    continue

                if data_field_name not in options_explicitly_set_by_user:
                    continue

                if child_value is Default:
                    # Child has Default and parent is not-Default, copy value onto child
                    setattr(self, data_field_name, copy(parent_value))

        # We always set the type-hint, Python will automatically surface the most recent
        # type-hint for us. We want to have it easily overridable without having to use a
        # Field class explicitly.
        _self.type_hint = type_hint

        # Resolve the special-case non-None Default&#39;s...
        if self.name is Default:
            # todo: figure out if we should always set name...
            #   ...i&#39;m inclined to not do that.
            _self.name = name

        if self.json_path is Default:
            _self.json_path = self.name

        if self.include_with_fields is Default:
            _self.include_with_fields = set()
        else:
            # Ensure it&#39;s a set, not a list or some other thing the user provided.
            _self.include_with_fields = set(loop(self.include_with_fields))

        if self.include_with_fields and self.name != self.json_path:
            raise XModelError(
                f&#34;Can&#39;t have a Field with `name != json_path` &#34;
                f&#34;(&#39;{self.name}&#39; != &#39;{self.json_path}&#39;)&#34;
                f&#34;and that also uses include_with_fields &#34;
                f&#34;({self.include_with_fields})&#34;
            )

        if self.json_path_separator is Default:
            _self.json_path_separator = &#39;.&#39;

        if self.include_in_repr is Default:
            _self.include_in_repr = False

        if self.exclude is Default:
            _self.exclude = False

        if self.read_only is Default:
            _self.read_only = False

        # If converter is None, but we do have a default one, use it...
        if (
            default_converter_map and
            self.type_hint in default_converter_map and
            &#39;converter&#39; in was_default_before_parent and
            self.converter in (None, Default)
        ):
            _self.converter = default_converter_map.get(self.type_hint)

        if (
            self.converter is Default and
            inspect.isclass(self.type_hint) and
            issubclass(self.type_hint, Enum)
        ):
            from xmodel.converters import EnumConverter
            _self.converter = EnumConverter()

        if self.related_type is Default:
            # By Default, we look at type-hint to see if it had a related-type or not...
            type_hint = self.type_hint
            related_type = type_hint
            if typing_inspect.get_origin(type_hint) is list:
                # Check to see if related_type is from typing
                # list and pull out first argument for List[]...
                related_type = typing_inspect.get_args(type_hint)[0]

            # Check if related type is a BaseModel or some other thing....
            from xmodel import BaseModel
            if inspect.isclass(related_type) and issubclass(related_type, BaseModel):
                _self.related_type = related_type

        # If we have a related type, and that related type has a usable id then we generate
        # a default related_field_name_for_id value if needed.
        if (
            self.related_field_name_for_id is Default
            and self.related_type
            and self.related_type.api.structure.has_id_field()
        ):
            _self.related_field_name_for_id = f&#39;{self.name}_id&#39;

        # Always base-line this field to None, we set a value for this if needed
        # in `xmodel.base.structure.BaseStructure._generate_fields`.
        # Because we need to cross-examine fields to set this correctly...
        # This field should never be set manually, it&#39;s always set automatically
        # as part of the BaseModel class setup process.
        # See `field_for_foreign_key_related_field` doc-comment for more details.
        _self.field_for_foreign_key_related_field = None

    def resolve_remaining_defaults_to_none(self):
        &#34;&#34;&#34; Called by `xmodel.base.structure.BaseStructure` after it calls
            `Field.resolve_defaults`.

            It used to be part of `Field.resolve_defaults`, but it was nicer to seperate
            it so that `Field` subclasses could call `super().resolve_defaults()` and
            still see what fields have defaults needing to be resolved, in case they wanted
            to do some special logic after the super/base classes default&#39;s were resolve but
            before they get set to None by Default.
        &#34;&#34;&#34;
        # Resolve all other fields still at Default to None
        for attr_field in dataclasses.fields(self):
            name = attr_field.name
            child_value = getattr(self, name)
            if child_value is Default:
                setattr(self, name, None)

    def __post_init__(self):
        # Ensure we unwrap the type-hint from any optional.
        type = self.type_hint
        if type is Default:
            return
        unwraped = unwrap_optional_type(type)
        object.__setattr__(self, &#39;type_hint&#39;, unwraped)

    name: str = Default
    &#34;&#34;&#34; (Default: Parent, Name of field on BaseModel)

        This is set automatically after the BaseModel class associated with Field is constructed.
        This construction is lazy and happens the first time the
        `xmodel.base.model.BaseModel.api` property is accessed by something.
    &#34;&#34;&#34;

    # See documentation under type_hint setter, this is only here to give type-hint to dataclass.
    # We have value set on it so IDE knows it&#39;s not required in __init__ and won&#39;t give warning.
    type_hint: Type = Default

    original_type_hint: Type = dataclasses.field(init=False, default=None, repr=False)
    &#34;&#34;&#34; This is set to whatever type_hint was originally set with, un-modified.
        `Field.type_hint` modifies what it&#39;s set with by filtering out None/Null types
        so the type is simpler.  It then sets `Field.nullable` to True/False if it&#39;s value is
        currently still at `xsentinels.default.Default` based on if NullType was seen or not as one
        of the types.

        In case something wants access to the original unmodified type, it&#39;s stored here.
    &#34;&#34;&#34;

    _type_hint = Default  # No type-hint means data-class ignores it.

    # noinspection PyRedeclaration
    @property
    def type_hint(self) -&gt; Type:
        &#34;&#34;&#34; (Default: Parent, The type-hint of the field)

            This is set automatically after the BaseModel class associated with Field is
            constructed. This construction is lazy and happens the first time the
            `xmodel.base.model.BaseModel.api` property is accessed by something.
        &#34;&#34;&#34;
        return self._type_hint

    @type_hint.setter
    def type_hint(self, value: Type):
        if value is Field.type_hint:
            # This means we were not initialized with a value, so just continue to use Default.
            # When data-class is not given an attr-value in __init__, it does a GET on the class
            # and passes that to us here, so we just ignore it since it&#39;s the property setter it&#39;s
            # self.
            return
        self.original_type_hint = value
        result = unwrap_optional_type(value, return_saw_null=True)
        self._type_hint = result[0]
        if self.nullable is Default:
            self.nullable = bool(result[1])

    nullable: bool = Default
    &#34;&#34;&#34; (Default: Nullable in type-hint, ie: `some_var: Union[int, NullType]`; `False`)

        If `True`, we are a nullable field and can have `xmodel.null.Null` set on us.

        When left as Default, when the type-hint is set on us we will examine to see if it
        is a Union type with NullType in it.  If it does have that, this will be set to True
        otherwise to False.
    &#34;&#34;&#34;

    read_only: bool = Default
    &#34;&#34;&#34; (Default: Parent, False)

        If `True`, we will NEVER send any values for this field to API.
    &#34;&#34;&#34;

    exclude: bool = Default
    &#34;&#34;&#34; (Default: `Parent`, `False`)

        If `True`, by default will will try and exclude this field if the api supports doing this.
        This means that we will request API not send it to us by default.

        This could make the API return results in a more efficient manner if it does not have
        to output fields when most of the time we don&#39;t care about it&#39;s value.
    &#34;&#34;&#34;

    default: Any = Default
    &#34;&#34;&#34; (Default: `Parent`, `None`)

        Default value for a field that we don&#39;t currently or did not previously retrieve a value
        for.

        If this default value is callable, like a function, type or an object that has a
        `__call__()` function defined on it; the system will call it without arguments to get
        a value back for the default value whenever a default value is needed for the model field.

        If you set a Non-Field value on a `xmodel.base.model.BaseModel`, it will be used as the
        value for this the `Field` object is created automatically (ie: if you don&#39;t set a
        `Field` object the the BaseModel class attribute/field, but something else, then it gets
        set here for you automatically).
    &#34;&#34;&#34;

    post_filter: Optional[Filter] = Default
    &#34;&#34;&#34; (Default: `Parent`, `None`)

        Called when something set the field after it&#39;s been type verified and changed if needed.
        You can use this to alter the value if needed.

        An example would be lower-casing all strings set on property.

        You can also return None to indicate the value is unset, or Null to indicate null value.
        Be sure to only do this with fields that expect a Null value, since whatever the
        post_filter returns is used without verifying it&#39;s type against what the field expects.
    &#34;&#34;&#34;

    converter: Optional[Converter] = Default
    &#34;&#34;&#34; (Default: `Parent` if set explicit by user;
        otherwise default converter for `Field.type_hint`)

        .. todo:: Implement this in BaseStructure/BaseApi.

        If set, this is used to convert value to/from api/json.
        You can see a real example of a converter at
        `xmodel.base.api.BaseApi.default_converters`.
    &#34;&#34;&#34;

    # def __call__(self, fget_func: Callable[[], T]) -&gt; T:
    #     if callable(fget_func):
    #         self.fget = fget_func
    #         return self
    #
    #     raise XModelError(
    #         f&#34;Attempt to calling a Field ({self}) as a callable function without &#34;
    #         f&#34;providing a function as the first parameter, &#34;
    #         f&#34;I got this parameter instead: ({func})... &#34;
    #         f&#34;When a Field is used as a decorator (ie: `@Field()`), it needs to be &#34;
    #         f&#34;places right before a function. This function will be used as the fields &#34;
    #         f&#34;property getter function. &#34;
    #     )

    @property
    def getter(self):
        &#34;&#34;&#34;
        Like the built-in `@property` of python, except you can also place a Field and set
        any field-options you like, so it lets you make a field that will read/write to JSON
        out of a propety function.

        Basically, used to easily set a `fget` (getter) function on self via the standard
        property decorator syntax.

        See `Field.fget` for more details. But in summary, it works like normal python properties
        except that when a value is set on you, `BaseModel` will first convert it if needed
        before invoking your property setter (if you provide a property setter).

        If you don&#39;t provide a property setter, then you can only grab values from the property
        and it will be an error to attempt to set a value on one.

        &gt;&gt;&gt; class MyModel(BaseModel):
        ...
        ...    # You can easily setup a field like normal, and then use getter/setter to setup
        ...    # the getter/setter for the field. Note: You MUST allocate a Field object of some
        ...    # sort your-self, otherwise there would be no object (yet) to use for the decorator.
        ...
        ...    my_field: str = Field()
        ...
        ...    @my_field.getter
        ...    def my_field(self):
        ...         return self._my_field_backing_store
        ...
        ...    # In either case, you can do the setter just like how normal properties work:
        ...    @my_field.setter
        ...    def my_field(self, value):
        ...        self._my_field_backing_store = value
        ...
        ...    _my_field_backing_store = None
        &#34;&#34;&#34;

        def set_setter_on_field_with(func):
            self.fget = func
            return self

        return set_setter_on_field_with

    @property
    def setter(self):
        &#34;&#34;&#34;
        Used to easily set a `set_func` setter function on self via the standard
        property decorator syntax, ie:

        &gt;&gt;&gt; class MyModel(BaseModel):
        ...    _my_field_backing_store = None
        ...    my_field: str = Field()
        ...    def my_field(self):
        ...         return self._my_field_backing_store
        ...    @my_field.setter
        ...    def my_field(self, value):
        ...        self._my_field_backing_store = value

        &#34;&#34;&#34;

        def set_setter_on_field_with(func):
            self.fset = func
            return self

        return set_setter_on_field_with

    fget: &#39;Optional[Callable[[M], Any]]&#39; = Default
    &#34;&#34;&#34; (Default: `Parent`; otherwise `None`)

        Function to use to get the value of a property, instead of getting it directly from object,
        BaseModel will use this.

        Callable Args:

        1. The model (ie: `self`)
        2. Is associated Field object
    &#34;&#34;&#34;

    fset: &#39;Optional[Callable[[BaseModel, Any], None]]&#39; = Default
    &#34;&#34;&#34; (Default: `Parent`; otherwise `None`)

        Function to use to set the value of a property, instead of setting it directly on object,
        BaseModel will use this.

        Callable Args:

        1. The model (ie: `self`)
        2. Is associated Field object
        3. Finally, the value to set.

        The value will be passed into function AFTER it&#39;s been verified, and converted if needed.
        If you need to adjust how the converter aspect works, look at `Field.converter`.

        Also, if someone attempts get the value, and the value is None...
        And if there is a `Field.default` set, the BaseModel needs to create a default value
        and return it.

        The created value will be set onto object before the getter returns.
        because no value is there... then it will be created and this function will be called.
    &#34;&#34;&#34;

    include_with_fields: Set[str] = Default
    &#34;&#34;&#34;
    (Default: `Parent`, `[]`)

    List of field names that, if they are included in the JSON, this one should too;
    even if our value has not changed.

    Defaults to blank set (ie: nothing).

    .. important:: Can use `include_with_fields` only when `Field.name` and `Field.json_path`
        are the same value (ie: have not customized `field.json_path` to be different.
        It&#39;s something that we have chosen not  to support to keep the implementation of this
        simpler. It&#39;s something that could be support in the future if the need ever arises.

    .. todo:: in the future, consider also allowing to pass in field-object,
        (which we would convert to the fields name, for the user as a convenience).
    &#34;&#34;&#34;

    json_path: str = Default
    &#34;&#34;&#34;
    (Default: `Field.name` at time of BaseModel-class construction [when defaults are resolved])

    Key/name used when mapping field to/from json/api request.

    If you include a `.`, it will go one level deeper in the JSON. That way you can
    map from/to a sub-property....

    Defaults to the Field.name.
    &#34;&#34;&#34;

    json_path_separator: str = Default
    &#34;&#34;&#34; (Default: `Parent`, &#34;.&#34;)

        Path separator to use in json_path.  Defaults to a period (&#34;.&#34;).
    &#34;&#34;&#34;

    # todo: Would like to rename this to just `repr`, just like in dataclasses.
    include_in_repr: bool = Default
    &#34;&#34;&#34; (Default: `Parent`, `False`)

        .. todo:: Would like to rename this to just `repr`, just like in dataclasses.

        Used in `xmodel.base.api.BaseApi.list_of_attrs_to_repr` to return a list of field-names
        that `xmodel.base.model.BaseModel.__repr__` uses to determine if the field should be
        included in the string it returns.

        This string is what get&#39;s used when the `xmodel.base.model.BaseModel` gets converted to
        a string, such as when logging the object out or printing it via the debugger.
    &#34;&#34;&#34;

    related_type: &#39;Optional[Type[BaseModel]]&#39; = Default
    &#34;&#34;&#34;
    (Default: `Parent`, `Field.type_hint` if subclass of `xmodel.base.model.BaseModel`, None)

    If not None, this is a type that is as subclass of `xmodel.base.model.BaseModel`.

    If `xsentinels.default.Default`, and we have not Parent field,
    we grab this from type-hints, examples:

    &gt;&gt;&gt; from xmodel.base.model. import BaseModel
    &gt;&gt;&gt; class MyModel(BaseModel):
    ...     # Needs &#39;my_attr_id&#39; via JSON, will do lazy lookup:
    ...     my_attr: SomeOtherModel
    ...
    ...     # &#39;List&#39; Not fully supported yet:
    ...     my_attr_list: List[SomeOtherModel]
    ...
    ...     # This works (for basic types, inside list/set)
    ...     # BaseModel-types inside list will come in future.
    ...     my_attr_list: Set[int]

    .. todo:: Right now we only support a one-to-one. In the future, we will support
        one-to-many via the generic `List[SomeModel]` type-hint syntax.

    Generally, when you ask for the value of a field with this set you get back an Instance
    of the type set into this field (as a value in this field).

    By convention, the primary-key value for this is the field name from the api when a
    &#34;_id&#34; appended to the end of the name; ie: &#34;`Field.json_key`_id&#34;

    .. todo:: At some point, I would like to make the `_id` customizable, perhaps with
        a `Field.related_type_id_key` or some such....
    &#34;&#34;&#34;

    related_field_name_for_id: Optional[str] = Default
    &#34;&#34;&#34;
    .. important:: Not currently used, will be used when one-to-many support is fully
        added. However, this should still be populated and return correct information.


    (Default: `Parent`;
              If `Field.related_type` is set to something with
              `xmodel.base.structure.BaseStructure.have_usable_id` is True,
              then `_id` is appended on end of`Field.json_path`.

              If the related_field uses no id field, then the object should be a sub-object
              and fully embedded into tje JSON instead of only embedding it&#39;s id value.
    )

    When getting Default value (if parent does not have this set) we use `self.json_path` and
    append an `_id` to the end. You can override this if you need to via the usual way:
    `Field(related_field_name_for_id=&#39;...xyz...&#39;)`.

    When resolve the Default value, we will only do so if the `Field.related_type` has it&#39;s
    `api.structure.have_usable_id` set to True (meaning that the related-type uses an `id` field).

    If a related type does not use an `id` field, by default the related type will be an
    embedded object (ie: fully embedded into the produced JSON, as needed).

    .. note:: The below statement is for when one_to_many is supported, someday...

    ~~if related_is_one_to_many is False, otherwise we find the a one-to-one link back to us
    from related_type, and use that field&#39;s `Field.json_path`.~~
    &#34;&#34;&#34;

    field_for_foreign_key_related_field: &#39;Optional[Field]&#39; = dataclasses.field(
        default=Default, init=False
    )
    &#34;&#34;&#34;
    .. important:: Not currently used, will be used when one-to-many support is fully
        added. However, this should still be populated and return correct information.


    (Default: If another field on Model has a `Field.related_field_name_for_id` that is equal
              to self.name, then we set this attribute with that other field object.

              Otherwise this is None
    )


    .. important:: this is always automatically generated, and should not be set manually.
        Keep reading for details.

    By Default, if this field represents the value of an &#39;id&#39; or key, for a one-to-one related
    foreign-key field  then this will be set to that related field.

    This is the other field on the same Model that is the related object for this key field.
    In other-words, the field this points to the field that represents the object for the value
    of this id/key field IF the related field is a one-to-one relationship.

    This can&#39;t be set via the `__init__` method for Field, it&#39;s always set when
    the `xmodel.base.structure.BaseStructure` generates fields via
    it&#39;s `_generate_fields` method.
    &#34;&#34;&#34;

    @property
    def is_foreign_key(self):
        &#34;&#34;&#34;
            .. important:: Not currently used, will be used when one-to-many support is fully
                added. However, this should still be populated and return correct information.

            If we have a `field_for_foreign_key_related_field`, then we are a foreign key field.

            This checks `Field.field_for_foreign_key_related_field` and returns True or False
            depending on if that has a field value or not.

            This property just makes it clear and documents on how one knows if we are a
            foreign key field or not.
        &#34;&#34;&#34;
        return bool(self.field_for_foreign_key_related_field)

    related_to_many: bool = Default
    &#34;&#34;&#34;
    .. important:: Not currently used, will be used when one-to-many support is fully added.
        Right now this will by Default always be `None`.

    (Default: `Parent`, If type-hint is `List[Model]` and other model has a one-to-one type-hint
    back to myself)

    If True, this field is a one-to-many relationship with another model.

    We use `Field.related_field_name_for_id` a the key for a query on the relationship via
    `BaseApi.get`. We will query `Field.related_type`&#39;s `api`, call get on it and use our model&#39;s
    `xmodel.base.model.BaseModel.id` as the query value.

    We will do our best to weak-cache the result, if weak-cache is currently enabled;
    see `xmodel.weak_cache_pool.WeakCachePool` for weak-cache details.
    &#34;&#34;&#34;

    model: &#39;BaseModel&#39; = Default

    @property
    def related_field(self) -&gt; &#39;Field&#39;:
        &#34;&#34;&#34; Set to the Field for the `Field.related_field_name_for_id`. &#34;&#34;&#34;
        api = self.related_type.api if self.related_to_many else self.model.api
        return api.structure.get_field(self.related_field_name_for_id)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.Field.converter"><code class="name">var <span class="ident">converter</span> :Â Optional[<a title="xmodel.base.fields.Converter" href="base/fields.html#xmodel.base.fields.Converter">Converter</a>]</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code> if set explicit by user;
otherwise default converter for <code><a title="xmodel.Field.type_hint" href="#xmodel.Field.type_hint">Field.type_hint</a></code>)</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Implement this in BaseStructure/BaseApi.</p>
</div>
<p>If set, this is used to convert value to/from api/json.
You can see a real example of a converter at
<code><a title="xmodel.base.api.BaseApi.default_converters" href="base/api.html#xmodel.base.api.BaseApi.default_converters">BaseApi.default_converters</a></code>.</p></div>
</dd>
<dt id="xmodel.Field.default"><code class="name">var <span class="ident">default</span> :Â Any</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, <code>None</code>)</p>
<p>Default value for a field that we don't currently or did not previously retrieve a value
for.</p>
<p>If this default value is callable, like a function, type or an object that has a
<code>__call__()</code> function defined on it; the system will call it without arguments to get
a value back for the default value whenever a default value is needed for the model field.</p>
<p>If you set a Non-Field value on a <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>, it will be used as the
value for this the <code><a title="xmodel.Field" href="#xmodel.Field">Field</a></code> object is created automatically (ie: if you don't set a
<code><a title="xmodel.Field" href="#xmodel.Field">Field</a></code> object the the BaseModel class attribute/field, but something else, then it gets
set here for you automatically).</p></div>
</dd>
<dt id="xmodel.Field.exclude"><code class="name">var <span class="ident">exclude</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, <code>False</code>)</p>
<p>If <code>True</code>, by default will will try and exclude this field if the api supports doing this.
This means that we will request API not send it to us by default.</p>
<p>This could make the API return results in a more efficient manner if it does not have
to output fields when most of the time we don't care about it's value.</p></div>
</dd>
<dt id="xmodel.Field.fget"><code class="name">var <span class="ident">fget</span> :Â Optional[Callable[[M],Â Any]]</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>; otherwise <code>None</code>)</p>
<p>Function to use to get the value of a property, instead of getting it directly from object,
BaseModel will use this.</p>
<p>Callable Args:</p>
<ol>
<li>The model (ie: <code>self</code>)</li>
<li>Is associated Field object</li>
</ol></div>
</dd>
<dt id="xmodel.Field.field_for_foreign_key_related_field"><code class="name">var <span class="ident">field_for_foreign_key_related_field</span> :Â Optional[<a title="xmodel.Field" href="#xmodel.Field">Field</a>]</code></dt>
<dd>
<div class="desc"><div class="admonition important">
<p class="admonition-title">Important:&ensp;Not currently used, will be used when one-to-many support is fully</p>
<p>added. However, this should still be populated and return correct information.</p>
</div>
<p>(Default: If another field on Model has a <code><a title="xmodel.Field.related_field_name_for_id" href="#xmodel.Field.related_field_name_for_id">Field.related_field_name_for_id</a></code> that is equal
to self.name, then we set this attribute with that other field object.</p>
<pre><code>      Otherwise this is None
</code></pre>
<p>)</p>
<div class="admonition important">
<p class="admonition-title">Important:&ensp;this is always automatically generated, and should not be set manually.</p>
<p>Keep reading for details.</p>
</div>
<p>By Default, if this field represents the value of an 'id' or key, for a one-to-one related
foreign-key field
then this will be set to that related field.</p>
<p>This is the other field on the same Model that is the related object for this key field.
In other-words, the field this points to the field that represents the object for the value
of this id/key field IF the related field is a one-to-one relationship.</p>
<p>This can't be set via the <code>__init__</code> method for Field, it's always set when
the <code><a title="xmodel.base.structure.BaseStructure" href="base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code> generates fields via
it's <code>_generate_fields</code> method.</p></div>
</dd>
<dt id="xmodel.Field.fset"><code class="name">var <span class="ident">fset</span> :Â Optional[Callable[[<a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>,Â Any],Â None]]</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>; otherwise <code>None</code>)</p>
<p>Function to use to set the value of a property, instead of setting it directly on object,
BaseModel will use this.</p>
<p>Callable Args:</p>
<ol>
<li>The model (ie: <code>self</code>)</li>
<li>Is associated Field object</li>
<li>Finally, the value to set.</li>
</ol>
<p>The value will be passed into function AFTER it's been verified, and converted if needed.
If you need to adjust how the converter aspect works, look at <code><a title="xmodel.Field.converter" href="#xmodel.Field.converter">Field.converter</a></code>.</p>
<p>Also, if someone attempts get the value, and the value is None&hellip;
And if there is a <code><a title="xmodel.Field.default" href="#xmodel.Field.default">Field.default</a></code> set, the BaseModel needs to create a default value
and return it.</p>
<p>The created value will be set onto object before the getter returns.
because no value is there&hellip; then it will be created and this function will be called.</p></div>
</dd>
<dt id="xmodel.Field.include_in_repr"><code class="name">var <span class="ident">include_in_repr</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, <code>False</code>)</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Would like to rename this to just <code>repr</code>, just like in dataclasses.</p>
</div>
<p>Used in <code><a title="xmodel.base.api.BaseApi.list_of_attrs_to_repr" href="base/api.html#xmodel.base.api.BaseApi.list_of_attrs_to_repr">BaseApi.list_of_attrs_to_repr()</a></code> to return a list of field-names
that <code>xmodel.base.model.BaseModel.__repr__</code> uses to determine if the field should be
included in the string it returns.</p>
<p>This string is what get's used when the <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code> gets converted to
a string, such as when logging the object out or printing it via the debugger.</p></div>
</dd>
<dt id="xmodel.Field.include_with_fields"><code class="name">var <span class="ident">include_with_fields</span> :Â Set[str]</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, <code>[]</code>)</p>
<p>List of field names that, if they are included in the JSON, this one should too;
even if our value has not changed.</p>
<p>Defaults to blank set (ie: nothing).</p>
<div class="admonition important">
<p class="admonition-title">Important:&ensp;Can use <code>include_with_fields</code> only when <code><a title="xmodel.Field.name" href="#xmodel.Field.name">Field.name</a></code> and <code><a title="xmodel.Field.json_path" href="#xmodel.Field.json_path">Field.json_path</a></code></p>
<p>are the same value (ie: have not customized <code>field.json_path</code> to be different.
It's something that we have chosen not
to support to keep the implementation of this
simpler. It's something that could be support in the future if the need ever arises.</p>
</div>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>in the future, consider also allowing to pass in field-object,
(which we would convert to the fields name, for the user as a convenience).</p>
</div></div>
</dd>
<dt id="xmodel.Field.json_path"><code class="name">var <span class="ident">json_path</span> :Â str</code></dt>
<dd>
<div class="desc"><p>(Default: <code><a title="xmodel.Field.name" href="#xmodel.Field.name">Field.name</a></code> at time of BaseModel-class construction [when defaults are resolved])</p>
<p>Key/name used when mapping field to/from json/api request.</p>
<p>If you include a <code>.</code>, it will go one level deeper in the JSON. That way you can
map from/to a sub-property....</p>
<p>Defaults to the Field.name.</p></div>
</dd>
<dt id="xmodel.Field.json_path_separator"><code class="name">var <span class="ident">json_path_separator</span> :Â str</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, ".")</p>
<p>Path separator to use in json_path.
Defaults to a period (".").</p></div>
</dd>
<dt id="xmodel.Field.model"><code class="name">var <span class="ident">model</span> :Â <a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xmodel.Field.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>(Default: Parent, Name of field on BaseModel)</p>
<p>This is set automatically after the BaseModel class associated with Field is constructed.
This construction is lazy and happens the first time the
<code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> property is accessed by something.</p></div>
</dd>
<dt id="xmodel.Field.nullable"><code class="name">var <span class="ident">nullable</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>(Default: Nullable in type-hint, ie: <code>some_var: Union[int, NullType]</code>; <code>False</code>)</p>
<p>If <code>True</code>, we are a nullable field and can have <code>xmodel.null.Null</code> set on us.</p>
<p>When left as Default, when the type-hint is set on us we will examine to see if it
is a Union type with NullType in it.
If it does have that, this will be set to True
otherwise to False.</p></div>
</dd>
<dt id="xmodel.Field.original_type_hint"><code class="name">var <span class="ident">original_type_hint</span> :Â Type[+CT_co]</code></dt>
<dd>
<div class="desc"><p>This is set to whatever type_hint was originally set with, un-modified.
<code><a title="xmodel.Field.type_hint" href="#xmodel.Field.type_hint">Field.type_hint</a></code> modifies what it's set with by filtering out None/Null types
so the type is simpler.
It then sets <code><a title="xmodel.Field.nullable" href="#xmodel.Field.nullable">Field.nullable</a></code> to True/False if it's value is
currently still at <code><a title="xsentinels.default.Default" href="../xsentinels/default.html#xsentinels.default.Default">Default</a></code> based on if NullType was seen or not as one
of the types.</p>
<p>In case something wants access to the original unmodified type, it's stored here.</p></div>
</dd>
<dt id="xmodel.Field.post_filter"><code class="name">var <span class="ident">post_filter</span> :Â Optional[<a title="xmodel.base.fields.Filter" href="base/fields.html#xmodel.base.fields.Filter">Filter</a>]</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, <code>None</code>)</p>
<p>Called when something set the field after it's been type verified and changed if needed.
You can use this to alter the value if needed.</p>
<p>An example would be lower-casing all strings set on property.</p>
<p>You can also return None to indicate the value is unset, or Null to indicate null value.
Be sure to only do this with fields that expect a Null value, since whatever the
post_filter returns is used without verifying it's type against what the field expects.</p></div>
</dd>
<dt id="xmodel.Field.read_only"><code class="name">var <span class="ident">read_only</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>(Default: Parent, False)</p>
<p>If <code>True</code>, we will NEVER send any values for this field to API.</p></div>
</dd>
<dt id="xmodel.Field.related_field_name_for_id"><code class="name">var <span class="ident">related_field_name_for_id</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"><div class="admonition important">
<p class="admonition-title">Important:&ensp;Not currently used, will be used when one-to-many support is fully</p>
<p>added. However, this should still be populated and return correct information.</p>
</div>
<p>(Default: <code>Parent</code>;
If <code><a title="xmodel.Field.related_type" href="#xmodel.Field.related_type">Field.related_type</a></code> is set to something with
<code>xmodel.base.structure.BaseStructure.have_usable_id</code> is True,
then <code>_id</code> is appended on end of<code><a title="xmodel.Field.json_path" href="#xmodel.Field.json_path">Field.json_path</a></code>.</p>
<pre><code>      If the related_field uses no id field, then the object should be a sub-object
      and fully embedded into tje JSON instead of only embedding it's id value.
</code></pre>
<p>)</p>
<p>When getting Default value (if parent does not have this set) we use <code>self.json_path</code> and
append an <code>_id</code> to the end. You can override this if you need to via the usual way:
<code>Field(related_field_name_for_id='...xyz...')</code>.</p>
<p>When resolve the Default value, we will only do so if the <code><a title="xmodel.Field.related_type" href="#xmodel.Field.related_type">Field.related_type</a></code> has it's
<code>api.structure.have_usable_id</code> set to True (meaning that the related-type uses an <code>id</code> field).</p>
<p>If a related type does not use an <code>id</code> field, by default the related type will be an
embedded object (ie: fully embedded into the produced JSON, as needed).</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The below statement is for when one_to_many is supported, someday&hellip;</p>
</div>
<p>~~if related_is_one_to_many is False, otherwise we find the a one-to-one link back to us
from related_type, and use that field's <code><a title="xmodel.Field.json_path" href="#xmodel.Field.json_path">Field.json_path</a></code>.~~</p></div>
</dd>
<dt id="xmodel.Field.related_to_many"><code class="name">var <span class="ident">related_to_many</span> :Â bool</code></dt>
<dd>
<div class="desc"><div class="admonition important">
<p class="admonition-title">Important:&ensp;Not currently used, will be used when one-to-many support is fully added.</p>
<p>Right now this will by Default always be <code>None</code>.</p>
</div>
<p>(Default: <code>Parent</code>, If type-hint is <code>List[Model]</code> and other model has a one-to-one type-hint
back to myself)</p>
<p>If True, this field is a one-to-many relationship with another model.</p>
<p>We use <code><a title="xmodel.Field.related_field_name_for_id" href="#xmodel.Field.related_field_name_for_id">Field.related_field_name_for_id</a></code> a the key for a query on the relationship via
<code>BaseApi.get</code>. We will query <code><a title="xmodel.Field.related_type" href="#xmodel.Field.related_type">Field.related_type</a></code>'s <code>api</code>, call get on it and use our model's
<code>xmodel.base.model.BaseModel.id</code> as the query value.</p>
<p>We will do our best to weak-cache the result, if weak-cache is currently enabled;
see <code>xmodel.weak_cache_pool.WeakCachePool</code> for weak-cache details.</p></div>
</dd>
<dt id="xmodel.Field.related_type"><code class="name">var <span class="ident">related_type</span> :Â Optional[Type[<a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a>]]</code></dt>
<dd>
<div class="desc"><p>(Default: <code>Parent</code>, <code><a title="xmodel.Field.type_hint" href="#xmodel.Field.type_hint">Field.type_hint</a></code> if subclass of <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>, None)</p>
<p>If not None, this is a type that is as subclass of <code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.</p>
<p>If <code><a title="xsentinels.default.Default" href="../xsentinels/default.html#xsentinels.default.Default">Default</a></code>, and we have not Parent field,
we grab this from type-hints, examples:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from xmodel.base.model. import BaseModel
&gt;&gt;&gt; class MyModel(BaseModel):
...     # Needs 'my_attr_id' via JSON, will do lazy lookup:
...     my_attr: SomeOtherModel
...
...     # 'List' Not fully supported yet:
...     my_attr_list: List[SomeOtherModel]
...
...     # This works (for basic types, inside list/set)
...     # BaseModel-types inside list will come in future.
...     my_attr_list: Set[int]
</code></pre>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Right now we only support a one-to-one. In the future, we will support
one-to-many via the generic <code>List[SomeModel]</code> type-hint syntax.</p>
</div>
<p>Generally, when you ask for the value of a field with this set you get back an Instance
of the type set into this field (as a value in this field).</p>
<p>By convention, the primary-key value for this is the field name from the api when a
"_id" appended to the end of the name; ie: "<code>Field.json_key</code>_id"</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>At some point, I would like to make the <code>_id</code> customizable, perhaps with
a <code>Field.related_type_id_key</code> or some such....</p>
</div></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.Field.getter"><code class="name">var <span class="ident">getter</span></code></dt>
<dd>
<div class="desc"><p>Like the built-in <code>@property</code> of python, except you can also place a Field and set
any field-options you like, so it lets you make a field that will read/write to JSON
out of a propety function.</p>
<p>Basically, used to easily set a <code>fget</code> (getter) function on self via the standard
property decorator syntax.</p>
<p>See <code><a title="xmodel.Field.fget" href="#xmodel.Field.fget">Field.fget</a></code> for more details. But in summary, it works like normal python properties
except that when a value is set on you, <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code> will first convert it if needed
before invoking your property setter (if you provide a property setter).</p>
<p>If you don't provide a property setter, then you can only grab values from the property
and it will be an error to attempt to set a value on one.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyModel(BaseModel):
...
...    # You can easily setup a field like normal, and then use getter/setter to setup
...    # the getter/setter for the field. Note: You MUST allocate a Field object of some
...    # sort your-self, otherwise there would be no object (yet) to use for the decorator.
...
...    my_field: str = Field()
...
...    @my_field.getter
...    def my_field(self):
...         return self._my_field_backing_store
...
...    # In either case, you can do the setter just like how normal properties work:
...    @my_field.setter
...    def my_field(self, value):
...        self._my_field_backing_store = value
...
...    _my_field_backing_store = None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def getter(self):
    &#34;&#34;&#34;
    Like the built-in `@property` of python, except you can also place a Field and set
    any field-options you like, so it lets you make a field that will read/write to JSON
    out of a propety function.

    Basically, used to easily set a `fget` (getter) function on self via the standard
    property decorator syntax.

    See `Field.fget` for more details. But in summary, it works like normal python properties
    except that when a value is set on you, `BaseModel` will first convert it if needed
    before invoking your property setter (if you provide a property setter).

    If you don&#39;t provide a property setter, then you can only grab values from the property
    and it will be an error to attempt to set a value on one.

    &gt;&gt;&gt; class MyModel(BaseModel):
    ...
    ...    # You can easily setup a field like normal, and then use getter/setter to setup
    ...    # the getter/setter for the field. Note: You MUST allocate a Field object of some
    ...    # sort your-self, otherwise there would be no object (yet) to use for the decorator.
    ...
    ...    my_field: str = Field()
    ...
    ...    @my_field.getter
    ...    def my_field(self):
    ...         return self._my_field_backing_store
    ...
    ...    # In either case, you can do the setter just like how normal properties work:
    ...    @my_field.setter
    ...    def my_field(self, value):
    ...        self._my_field_backing_store = value
    ...
    ...    _my_field_backing_store = None
    &#34;&#34;&#34;

    def set_setter_on_field_with(func):
        self.fget = func
        return self

    return set_setter_on_field_with</code></pre>
</details>
</dd>
<dt id="xmodel.Field.is_foreign_key"><code class="name">var <span class="ident">is_foreign_key</span></code></dt>
<dd>
<div class="desc"><div class="admonition important">
<p class="admonition-title">Important:&ensp;Not currently used, will be used when one-to-many support is fully</p>
<p>added. However, this should still be populated and return correct information.</p>
</div>
<p>If we have a <code>field_for_foreign_key_related_field</code>, then we are a foreign key field.</p>
<p>This checks <code><a title="xmodel.Field.field_for_foreign_key_related_field" href="#xmodel.Field.field_for_foreign_key_related_field">Field.field_for_foreign_key_related_field</a></code> and returns True or False
depending on if that has a field value or not.</p>
<p>This property just makes it clear and documents on how one knows if we are a
foreign key field or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_foreign_key(self):
    &#34;&#34;&#34;
        .. important:: Not currently used, will be used when one-to-many support is fully
            added. However, this should still be populated and return correct information.

        If we have a `field_for_foreign_key_related_field`, then we are a foreign key field.

        This checks `Field.field_for_foreign_key_related_field` and returns True or False
        depending on if that has a field value or not.

        This property just makes it clear and documents on how one knows if we are a
        foreign key field or not.
    &#34;&#34;&#34;
    return bool(self.field_for_foreign_key_related_field)</code></pre>
</details>
</dd>
<dt id="xmodel.Field.related_field"><code class="name">var <span class="ident">related_field</span> :Â <a title="xmodel.base.fields.Field" href="base/fields.html#xmodel.base.fields.Field">Field</a></code></dt>
<dd>
<div class="desc"><p>Set to the Field for the <code><a title="xmodel.Field.related_field_name_for_id" href="#xmodel.Field.related_field_name_for_id">Field.related_field_name_for_id</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def related_field(self) -&gt; &#39;Field&#39;:
    &#34;&#34;&#34; Set to the Field for the `Field.related_field_name_for_id`. &#34;&#34;&#34;
    api = self.related_type.api if self.related_to_many else self.model.api
    return api.structure.get_field(self.related_field_name_for_id)</code></pre>
</details>
</dd>
<dt id="xmodel.Field.setter"><code class="name">var <span class="ident">setter</span></code></dt>
<dd>
<div class="desc"><p>Used to easily set a <code>set_func</code> setter function on self via the standard
property decorator syntax, ie:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class MyModel(BaseModel):
...    _my_field_backing_store = None
...    my_field: str = Field()
...    def my_field(self):
...         return self._my_field_backing_store
...    @my_field.setter
...    def my_field(self, value):
...        self._my_field_backing_store = value
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def setter(self):
    &#34;&#34;&#34;
    Used to easily set a `set_func` setter function on self via the standard
    property decorator syntax, ie:

    &gt;&gt;&gt; class MyModel(BaseModel):
    ...    _my_field_backing_store = None
    ...    my_field: str = Field()
    ...    def my_field(self):
    ...         return self._my_field_backing_store
    ...    @my_field.setter
    ...    def my_field(self, value):
    ...        self._my_field_backing_store = value

    &#34;&#34;&#34;

    def set_setter_on_field_with(func):
        self.fset = func
        return self

    return set_setter_on_field_with</code></pre>
</details>
</dd>
<dt id="xmodel.Field.type_hint"><code class="name">var <span class="ident">type_hint</span> :Â Type[+CT_co]</code></dt>
<dd>
<div class="desc"><p>(Default: Parent, The type-hint of the field)</p>
<p>This is set automatically after the BaseModel class associated with Field is
constructed. This construction is lazy and happens the first time the
<code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> property is accessed by something.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type_hint(self) -&gt; Type:
    &#34;&#34;&#34; (Default: Parent, The type-hint of the field)

        This is set automatically after the BaseModel class associated with Field is
        constructed. This construction is lazy and happens the first time the
        `xmodel.base.model.BaseModel.api` property is accessed by something.
    &#34;&#34;&#34;
    return self._type_hint</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.Field.resolve_defaults"><code class="name flex">
<span>def <span class="ident">resolve_defaults</span></span>(<span>self, *, name, type_hint:Â Type[+CT_co], default_converter_map:Â Optional[Dict[Type[+CT_co],Â <a title="xmodel.base.fields.Converter" href="base/fields.html#xmodel.base.fields.Converter">Converter</a>]]Â =Â None, parent_field:Â <a title="xmodel.Field" href="#xmodel.Field">Field</a>Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves all dataclass attributes/fields on self that are still set to <code>Default</code>.
The only exception is <code>type_hint</code>. We will always use what is passed in, regardless
of if there is a parent-field with one set. This allows one on a BaseModel to easily
override the type-hint without having to create a field with an explicitly set
type_hint set on it (ie: let normal python annotated type-hint override any parent type).</p>
<p>This includes ones on subclasses [dataclass will generically tell us about all of them].
System calls this when a BaseModel class is being lazily constructed
[ie: when gets the <code>xmodel.base.model.BaseModel.api</code> attribute for the first time or
attempts to create an instance of the BaseModel for the fist time].</p>
<p>When the BaseModel class is being constructed, this method is called to resolve all
the Default values still on the instance. We do this by:</p>
<ol>
<li>We first look at parent_field object if one has been given.<ul>
<li>If ask that parent field which options where explicitly set by user and which
ones were set by resolving a <code><a title="xsentinels.default.Default" href="../xsentinels/default.html#xsentinels.default.Default">Default</a></code>. Field objects have an
internal/private var that keeps track of this.</li>
</ul>
</li>
<li>Next, figure out standard default value for option if option's current value is
current at <code><a title="xsentinels.default.Default" href="../xsentinels/default.html#xsentinels.default.Default">Default</a></code> (a default sentential value, used to detect
which values were left unset by user).</li>
</ol>
<h2 id="more-details">More Details</h2>
<p>I have Field objects keep track of which fields were not at
Default when they are resolved. This allows child Field objects
to know which values to copy into themselves and which ones
should be resolved normally via Default.</p>
<p>The goal here is to avoid copying value from Parent that
were originally resolved via Default mechanism
(and were not set explicitly by user).</p>
<p>An example of why this is handy:</p>
<p>If we have a parent model with a field of a different type vs the one on the child.
Unless the converter was explicitly set by the user we want to just use the default
converter for the different type on the child (and not use the wrong converter by default).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_defaults(
        self,
        *,  # Keyword args only after this point
        name,
        type_hint: Type,
        default_converter_map: Optional[Dict[Type, Converter]] = None,
        parent_field: &#34;Field&#34; = None
):
    &#34;&#34;&#34;
    Resolves all dataclass attributes/fields on self that are still set to `Default`.
    The only exception is `type_hint`. We will always use what is passed in, regardless
    of if there is a parent-field with one set. This allows one on a BaseModel to easily
    override the type-hint without having to create a field with an explicitly set
    type_hint set on it (ie: let normal python annotated type-hint override any parent type).

    This includes ones on subclasses [dataclass will generically tell us about all of them].
    System calls this when a BaseModel class is being lazily constructed
    [ie: when gets the `xmodel.base.model.BaseModel.api` attribute for the first time or
    attempts to create an instance of the BaseModel for the fist time].

    When the BaseModel class is being constructed, this method is called to resolve all
    the Default values still on the instance. We do this by:

    1. We first look at parent_field object if one has been given.
        - If ask that parent field which options where explicitly set by user and which
            ones were set by resolving a `xsentinels.default.Default`. Field objects have an
            internal/private var that keeps track of this.
    2. Next, figure out standard default value for option if option&#39;s current value is
        current at `xsentinels.default.Default` (a default sentential value, used to detect
        which values were left unset by user).


    ## More Details

    I have Field objects keep track of which fields were not at
    Default when they are resolved. This allows child Field objects
    to know which values to copy into themselves and which ones
    should be resolved normally via Default.

    The goal here is to avoid copying value from Parent that
    were originally resolved via Default mechanism
    (and were not set explicitly by user).

    An example of why this is handy:

    If we have a parent model with a field of a different type vs the one on the child.
    Unless the converter was explicitly set by the user we want to just use the default
    converter for the different type on the child (and not use the wrong converter by default).
    &#34;&#34;&#34;

    # Get pycharm to go to class-level var/typehint with the attribute docs we have written
    # instead of going into this method where it gets assigned.
    # Using different var-name for self seems to be able to do that.
    _self = self

    if parent_field:
        options_explicitly_set_by_user = parent_field._options_explicitly_set_by_user
    else:
        options_explicitly_set_by_user = set()

    # Keep track of what was Default before resolving with parent
    # [ie: was not explicitly set by user].
    was_default_before_parent = set()

    for data_field in dataclasses.fields(self):
        data_field_name = data_field.name
        child_value = getattr(self, data_field_name)
        if child_value is Default:
            was_default_before_parent.add(data_field_name)
        else:
            options_explicitly_set_by_user.add(data_field_name)

    # Store for future child-fields.
    self._options_explicitly_set_by_user = options_explicitly_set_by_user

    if parent_field:
        if not isinstance(self, type(parent_field)):
            raise XModelError(
                f&#34;Child field {self} must be same or subclass of parent ({parent_field}).&#34;
            )

        # Go though each dataclass Field in parent, take it&#39;s value and copy it to child if:
        #   1. The child still has it set to `Default`.
        #   2. The parent&#39;s value is not `Default`.
        #   3. The parent&#39;s value was set by the user (options_explicitly_set_by_user).
        #       - If the value was not set by user, we just leave us at `Default` and resolve
        #           them normally.
        for parent_data_field in dataclasses.fields(parent_field):
            p_attr_field: dataclasses.Field
            data_field_name = parent_data_field.name
            parent_value = getattr(parent_field, data_field_name)
            child_value = getattr(self, data_field_name)

            if parent_value is Default:
                continue

            if data_field_name not in options_explicitly_set_by_user:
                continue

            if child_value is Default:
                # Child has Default and parent is not-Default, copy value onto child
                setattr(self, data_field_name, copy(parent_value))

    # We always set the type-hint, Python will automatically surface the most recent
    # type-hint for us. We want to have it easily overridable without having to use a
    # Field class explicitly.
    _self.type_hint = type_hint

    # Resolve the special-case non-None Default&#39;s...
    if self.name is Default:
        # todo: figure out if we should always set name...
        #   ...i&#39;m inclined to not do that.
        _self.name = name

    if self.json_path is Default:
        _self.json_path = self.name

    if self.include_with_fields is Default:
        _self.include_with_fields = set()
    else:
        # Ensure it&#39;s a set, not a list or some other thing the user provided.
        _self.include_with_fields = set(loop(self.include_with_fields))

    if self.include_with_fields and self.name != self.json_path:
        raise XModelError(
            f&#34;Can&#39;t have a Field with `name != json_path` &#34;
            f&#34;(&#39;{self.name}&#39; != &#39;{self.json_path}&#39;)&#34;
            f&#34;and that also uses include_with_fields &#34;
            f&#34;({self.include_with_fields})&#34;
        )

    if self.json_path_separator is Default:
        _self.json_path_separator = &#39;.&#39;

    if self.include_in_repr is Default:
        _self.include_in_repr = False

    if self.exclude is Default:
        _self.exclude = False

    if self.read_only is Default:
        _self.read_only = False

    # If converter is None, but we do have a default one, use it...
    if (
        default_converter_map and
        self.type_hint in default_converter_map and
        &#39;converter&#39; in was_default_before_parent and
        self.converter in (None, Default)
    ):
        _self.converter = default_converter_map.get(self.type_hint)

    if (
        self.converter is Default and
        inspect.isclass(self.type_hint) and
        issubclass(self.type_hint, Enum)
    ):
        from xmodel.converters import EnumConverter
        _self.converter = EnumConverter()

    if self.related_type is Default:
        # By Default, we look at type-hint to see if it had a related-type or not...
        type_hint = self.type_hint
        related_type = type_hint
        if typing_inspect.get_origin(type_hint) is list:
            # Check to see if related_type is from typing
            # list and pull out first argument for List[]...
            related_type = typing_inspect.get_args(type_hint)[0]

        # Check if related type is a BaseModel or some other thing....
        from xmodel import BaseModel
        if inspect.isclass(related_type) and issubclass(related_type, BaseModel):
            _self.related_type = related_type

    # If we have a related type, and that related type has a usable id then we generate
    # a default related_field_name_for_id value if needed.
    if (
        self.related_field_name_for_id is Default
        and self.related_type
        and self.related_type.api.structure.has_id_field()
    ):
        _self.related_field_name_for_id = f&#39;{self.name}_id&#39;

    # Always base-line this field to None, we set a value for this if needed
    # in `xmodel.base.structure.BaseStructure._generate_fields`.
    # Because we need to cross-examine fields to set this correctly...
    # This field should never be set manually, it&#39;s always set automatically
    # as part of the BaseModel class setup process.
    # See `field_for_foreign_key_related_field` doc-comment for more details.
    _self.field_for_foreign_key_related_field = None</code></pre>
</details>
</dd>
<dt id="xmodel.Field.resolve_remaining_defaults_to_none"><code class="name flex">
<span>def <span class="ident">resolve_remaining_defaults_to_none</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called by <code><a title="xmodel.base.structure.BaseStructure" href="base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code> after it calls
<code><a title="xmodel.Field.resolve_defaults" href="#xmodel.Field.resolve_defaults">Field.resolve_defaults()</a></code>.</p>
<p>It used to be part of <code><a title="xmodel.Field.resolve_defaults" href="#xmodel.Field.resolve_defaults">Field.resolve_defaults()</a></code>, but it was nicer to seperate
it so that <code><a title="xmodel.Field" href="#xmodel.Field">Field</a></code> subclasses could call <code>super().resolve_defaults()</code> and
still see what fields have defaults needing to be resolved, in case they wanted
to do some special logic after the super/base classes default's were resolve but
before they get set to None by Default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_remaining_defaults_to_none(self):
    &#34;&#34;&#34; Called by `xmodel.base.structure.BaseStructure` after it calls
        `Field.resolve_defaults`.

        It used to be part of `Field.resolve_defaults`, but it was nicer to seperate
        it so that `Field` subclasses could call `super().resolve_defaults()` and
        still see what fields have defaults needing to be resolved, in case they wanted
        to do some special logic after the super/base classes default&#39;s were resolve but
        before they get set to None by Default.
    &#34;&#34;&#34;
    # Resolve all other fields still at Default to None
    for attr_field in dataclasses.fields(self):
        name = attr_field.name
        child_value = getattr(self, name)
        if child_value is Default:
            setattr(self, name, None)</code></pre>
</details>
</dd>
<dt id="xmodel.Field.was_option_explicitly_set_by_user"><code class="name flex">
<span>def <span class="ident">was_option_explicitly_set_by_user</span></span>(<span>self, option_name:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Given an option / field-attribute name, if the option was explicitly set by
the user then we return True.</p>
<p>If not we return False.</p>
<p>We determine this while <code><a title="xmodel.Field.resolve_defaults" href="#xmodel.Field.resolve_defaults">Field.resolve_defaults()</a></code> is called, it checks to see
what is still set to <code>Default</code>.</p>
<p>If an option is not <code>Default</code> anymore when <code>resolve_defaults</code> is first called, we
consider it set by the user.</p>
<p>This is important, as it informs subclasses of BaseModel if their parent model's
field's value was resolved automatically or if it was set by user.</p>
<p>Generally, if it was resolved automatically, we continue to resolve it automatically.</p>
<p>If it was set by the user we tend to use what the user set it to and not resolve
it automatically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def was_option_explicitly_set_by_user(self, option_name: str) -&gt; bool:
    &#34;&#34;&#34; Given an option / field-attribute name, if the option was explicitly set by
        the user then we return True.

        If not we return False.

        We determine this while `Field.resolve_defaults` is called, it checks to see
        what is still set to `Default`.

        If an option is not `Default` anymore when `resolve_defaults` is first called, we
        consider it set by the user.

        This is important, as it informs subclasses of BaseModel if their parent model&#39;s
        field&#39;s value was resolved automatically or if it was set by user.

        Generally, if it was resolved automatically, we continue to resolve it automatically.

        If it was set by the user we tend to use what the user set it to and not resolve
        it automatically.
    &#34;&#34;&#34;
    return option_name in self._options_explicitly_set_by_user</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel.JsonModel"><code class="flex name class">
<span>class <span class="ident">JsonModel</span></span>
<span>(</span><span>*args, **initial_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Used as the abstract base-class for classes/object that communicate with our REST API.</p>
<p>This is one of the main classes, and it's highly recommend you read the
<a href="./#orm-library-overview">SDK Library Overview</a> first, if you have not already.
That document has many basic examples of using this class along with other related classes.</p>
<p>Attributes that start with <code>_</code> or don't have a type-hint are not considered fields
on the object that automatically get mapped to/from the JSON that is passed in.
For more details see <a href="./#type-hints">Type Hints</a>.</p>
<p>When you sub-class <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code>, you can create your own Model class, with your own
fields/attrs.
You can pass class arguments/paramters in when you declare your sub-class.
The Model-subclass can provide parameters to the super class during class construction.</p>
<p>In the example below, notice the <code>base_url</code> part. That's a class argument, that is used by the
super-class during the construction of the sub-class (before any instances are created).
In this case it takes this and stores it on
<code>xmodel.rest.RestStructure.base_model_url</code>
as part of the structure information for the <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code> subclass.</p>
<p>See <a href="./#basic-model-example">Basic Model Example</a> for an example of what class arguments
are or look at this example below using a RestModel:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 'base_url' part is a class argument:
&gt;&gt;&gt; from xmodel.rest import RestModel
&gt;&gt;&gt; class Account(RestModel[&quot;Account&quot;], base_url='/account'):
&gt;&gt;&gt;    id: str
&gt;&gt;&gt;    name: str
</code></pre>
<p>These class arguments are sent to a special method
<code><a title="xmodel.base.structure.BaseStructure.configure_for_model_type" href="base/structure.html#xmodel.base.structure.BaseStructure.configure_for_model_type">BaseStructure.configure_for_model_type()</a></code>. See that methods docs for
a list of avaliable class-arguments.</p>
<p>See <code>BaseModel.__init_subclass__</code> for more on the internal details of how this works exactly.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;In the case of <code>base_url</code> example above, it's the base-url-endpoint for the model.</p>
<p>If you want to know more about that see <code>xmodel.rest.RestClient.url_for_endpoint</code>.
It has details on how the final request <code><a title="xurls.url.URL" href="../xurls/url.html#xurls.url.URL">URL</a></code> is constructed.</p>
</div>
<p>This class also allows you to more easily with with JSON data via:</p>
<ul>
<li><code><a title="xmodel.base.api.BaseApi.json" href="base/api.html#xmodel.base.api.BaseApi.json">BaseApi.json()</a></code></li>
<li><code><a title="xmodel.base.api.BaseApi.update_from_json" href="base/api.html#xmodel.base.api.BaseApi.update_from_json">BaseApi.update_from_json()</a></code></li>
<li>Or passing a JSON dict as the first arrument to <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code>.</li>
</ul>
<p>Other important related classes are listed below.</p>
<ul>
<li><code><a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a></code> Accessable via <code><a title="xmodel.BaseModel.api" href="#xmodel.BaseModel.api">BaseModel.api</a></code>.</li>
<li><code>xmodel.rest.RestClient</code>: Accessable via <code>xmodel.base.api.BaseApi.client</code>.</li>
<li><code>xmodel.rest.settings.RestSettings</code>: Accessable via
<code>xmodel.base.api.BaseApi.settings</code>.</li>
<li><code><a title="xmodel.base.structure.BaseStructure" href="base/structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>: Accessable via
<code><a title="xmodel.base.api.BaseApi.structure" href="base/api.html#xmodel.base.api.BaseApi.structure">BaseApi.structure</a></code></li>
<li><code>xmodel.base.auth.BaseAuth</code>: Accessable via <code>xmodel.base.api.BaseApi.auth</code></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Tip:&ensp;For all of the above, you can change what class is allocated for each one</p>
<p>by changing the type-hint on a subclass.</p>
</div>
<p>Creates a new model object. The first/second params need to be passed as positional
arguments. The rest must be sent as key-word arguments. Everything is optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Specify the <code>BaseModel.id</code> attribute, if you know it. If left as Default, nothing
will be set on it. It could be set to something via args[0] (ie: a JSON dict).
If you do provide a value, it be set last after everything else has been set.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>
<p>I don't want to take names from what you could put into 'initial_values',
so I keep it as position-only *args. Once Python 3.8 comes out, we can use a
new feature where you can specify some arguments as positional-only and not
keyword-able.</p>
<h2 id="firstarg-if-dict">FirstArg - If Dict:</h2>
<p>If raw dictionary parsed from JSON string. It just calls
<code>self.api.update_from_json(args[0])</code> for you.</p>
<h2 id="firstart-if-basemodel">FirstArt - If BaseModel:</h2>
<p>If a <code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code>, will copy fields over that have the same name.
You can use this to duplicate a Model object, if you want to copy it.
Or can be used to copy fields from one model type into another,
on fields that are the same name.</p>
<p>Will ignore fields that are present on one but not the other.
Only copy fields that are on both models types.</p>
</dd>
<dt><strong><code>**initial_values</code></strong></dt>
<dd>Let's you specify other attribute values for convenience.
They will be set into the object the same way you would normally doing it:
ie: <code>model_obj.some_attr = v</code> is the same as <code>ModelClass(some_attr=v)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonModel(BaseModel[M]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></li>
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.JsonModel.api"><code class="name">var <span class="ident">api</span> :Â <a title="xmodel.base.api.BaseApi" href="base/api.html#xmodel.base.api.BaseApi">BaseApi</a>[~M]</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.<code><a title="xmodel.base.model.BaseModel.api" href="base/model.html#xmodel.base.model.BaseModel.api">api</a></code>
</p>
<div class="desc inherited"><p>Used to access the api class, which is used to retrieve/send objects to/from api â€¦</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="xmodel.JsonModel.__init_subclass__"><code class="name flex">
<span>def <span class="ident">__init_subclass__</span></span>(<span>*, lazy_loader:Â Callable[[Type[~M]],Â None]Â =Â None, **kwargs)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="xmodel.base.model.BaseModel" href="base/model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.<code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="base/model.html#xmodel.base.model.BaseModel.__init_subclass__">__init_subclass__</a></code>
</p>
<div class="desc inherited"><p>We take all arguments (except <code>lazy_loader</code>) passed into here and send them to the method
on our structure:
â€¦</p></div>
</dd>
</dl>
</dd>
<dt id="xmodel.XModelError"><code class="flex name class">
<span>class <span class="ident">XModelError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base-class for all xmodel exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XModelError(Exception):
    &#34;&#34;&#34; Base-class for all xmodel exceptions. &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.remote.errors.XRemoteError" href="remote/errors.html#xmodel.remote.errors.XRemoteError">XRemoteError</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#old-docs-below-need-a-lot-of-updates-orm-is-old-reference">Old Docs Below - Need A Lot Of Updates (ORM is old reference)</a><ul>
<li><a href="#orm-library-overview">ORM Library Overview</a></li>
<li><a href="#model-fields">Model Fields</a><ul>
<li><a href="#basic-model-example">Basic Model Example</a></li>
<li><a href="#type-hints">Type-hints</a></li>
<li><a href="#field-objects">Field Objects</a><ul>
<li><a href="#field-subclasses">Field Subclasses</a></li>
</ul>
</li>
<li><a href="#json">JSON</a></li>
</ul>
</li>
<li><a href="#modelapi">Model.api</a></li>
<li><a href="#baseapi-class">BaseApi Class</a><ul>
<li><a href="#type-converters">Type Converters</a></li>
</ul>
</li>
<li><a href="#restclient-class">RestClient Class</a></li>
<li><a href="#related-child-models">Related Child Model's</a><ul>
<li><a href="#auto-prefetch-children">Auto Prefetch Children</a></li>
</ul>
</li>
<li><a href="#caching">Caching</a><ul>
<li><a href="#strong-ref-caching">Strong-Ref Caching</a></li>
<li><a href="#weak-ref-caching">Weak-Ref Caching</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="xmodel.base" href="base/index.html">xmodel.base</a></code></li>
<li><code><a title="xmodel.common" href="common/index.html">xmodel.common</a></code></li>
<li><code><a title="xmodel.converters" href="converters.html">xmodel.converters</a></code></li>
<li><code><a title="xmodel.errors" href="errors.html">xmodel.errors</a></code></li>
<li><code><a title="xmodel.json" href="json.html">xmodel.json</a></code></li>
<li><code><a title="xmodel.remote" href="remote/index.html">xmodel.remote</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel.BaseApi" href="#xmodel.BaseApi">BaseApi</a></code></h4>
<ul class="">
<li><code><a title="xmodel.BaseApi.context" href="#xmodel.BaseApi.context">context</a></code></li>
<li><code><a title="xmodel.BaseApi.copy_from_model" href="#xmodel.BaseApi.copy_from_model">copy_from_model</a></code></li>
<li><code><a title="xmodel.BaseApi.default_converters" href="#xmodel.BaseApi.default_converters">default_converters</a></code></li>
<li><code><a title="xmodel.BaseApi.fields_to_pop_for_json" href="#xmodel.BaseApi.fields_to_pop_for_json">fields_to_pop_for_json</a></code></li>
<li><code><a title="xmodel.BaseApi.forget_original_json_state" href="#xmodel.BaseApi.forget_original_json_state">forget_original_json_state</a></code></li>
<li><code><a title="xmodel.BaseApi.get_child_without_lazy_lookup" href="#xmodel.BaseApi.get_child_without_lazy_lookup">get_child_without_lazy_lookup</a></code></li>
<li><code><a title="xmodel.BaseApi.have_changes" href="#xmodel.BaseApi.have_changes">have_changes</a></code></li>
<li><code><a title="xmodel.BaseApi.json" href="#xmodel.BaseApi.json">json</a></code></li>
<li><code><a title="xmodel.BaseApi.list_of_attrs_to_repr" href="#xmodel.BaseApi.list_of_attrs_to_repr">list_of_attrs_to_repr</a></code></li>
<li><code><a title="xmodel.BaseApi.model" href="#xmodel.BaseApi.model">model</a></code></li>
<li><code><a title="xmodel.BaseApi.model_type" href="#xmodel.BaseApi.model_type">model_type</a></code></li>
<li><code><a title="xmodel.BaseApi.should_include_field_in_json" href="#xmodel.BaseApi.should_include_field_in_json">should_include_field_in_json</a></code></li>
<li><code><a title="xmodel.BaseApi.structure" href="#xmodel.BaseApi.structure">structure</a></code></li>
<li><code><a title="xmodel.BaseApi.update_from_json" href="#xmodel.BaseApi.update_from_json">update_from_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.BaseModel" href="#xmodel.BaseModel">BaseModel</a></code></h4>
<ul class="">
<li><code><a title="xmodel.BaseModel.api" href="#xmodel.BaseModel.api">api</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.BaseStructure" href="#xmodel.BaseStructure">BaseStructure</a></code></h4>
<ul class="">
<li><code><a title="xmodel.BaseStructure.configure_for_model_type" href="#xmodel.BaseStructure.configure_for_model_type">configure_for_model_type</a></code></li>
<li><code><a title="xmodel.BaseStructure.endpoint_description" href="#xmodel.BaseStructure.endpoint_description">endpoint_description</a></code></li>
<li><code><a title="xmodel.BaseStructure.excluded_field_map" href="#xmodel.BaseStructure.excluded_field_map">excluded_field_map</a></code></li>
<li><code><a title="xmodel.BaseStructure.field_exists" href="#xmodel.BaseStructure.field_exists">field_exists</a></code></li>
<li><code><a title="xmodel.BaseStructure.field_map" href="#xmodel.BaseStructure.field_map">field_map</a></code></li>
<li><code><a title="xmodel.BaseStructure.field_type" href="#xmodel.BaseStructure.field_type">field_type</a></code></li>
<li><code><a title="xmodel.BaseStructure.fields" href="#xmodel.BaseStructure.fields">fields</a></code></li>
<li><code><a title="xmodel.BaseStructure.get_field" href="#xmodel.BaseStructure.get_field">get_field</a></code></li>
<li><code><a title="xmodel.BaseStructure.get_unwraped_typehint" href="#xmodel.BaseStructure.get_unwraped_typehint">get_unwraped_typehint</a></code></li>
<li><code><a title="xmodel.BaseStructure.has_id_field" href="#xmodel.BaseStructure.has_id_field">has_id_field</a></code></li>
<li><code><a title="xmodel.BaseStructure.have_api_endpoint" href="#xmodel.BaseStructure.have_api_endpoint">have_api_endpoint</a></code></li>
<li><code><a title="xmodel.BaseStructure.id_cache_key" href="#xmodel.BaseStructure.id_cache_key">id_cache_key</a></code></li>
<li><code><a title="xmodel.BaseStructure.internal_shared_api_values" href="#xmodel.BaseStructure.internal_shared_api_values">internal_shared_api_values</a></code></li>
<li><code><a title="xmodel.BaseStructure.is_field_a_child" href="#xmodel.BaseStructure.is_field_a_child">is_field_a_child</a></code></li>
<li><code><a title="xmodel.BaseStructure.model_cls" href="#xmodel.BaseStructure.model_cls">model_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.Converter" href="#xmodel.Converter">Converter</a></code></h4>
<ul class="">
<li><code><a title="xmodel.Converter.Direction" href="#xmodel.Converter.Direction">Direction</a></code></li>
<li><code><a title="xmodel.Converter.from_json" href="#xmodel.Converter.from_json">from_json</a></code></li>
<li><code><a title="xmodel.Converter.to_json" href="#xmodel.Converter.to_json">to_json</a></code></li>
<li><code><a title="xmodel.Converter.to_model" href="#xmodel.Converter.to_model">to_model</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.Field" href="#xmodel.Field">Field</a></code></h4>
<ul class="">
<li><code><a title="xmodel.Field.converter" href="#xmodel.Field.converter">converter</a></code></li>
<li><code><a title="xmodel.Field.default" href="#xmodel.Field.default">default</a></code></li>
<li><code><a title="xmodel.Field.exclude" href="#xmodel.Field.exclude">exclude</a></code></li>
<li><code><a title="xmodel.Field.fget" href="#xmodel.Field.fget">fget</a></code></li>
<li><code><a title="xmodel.Field.field_for_foreign_key_related_field" href="#xmodel.Field.field_for_foreign_key_related_field">field_for_foreign_key_related_field</a></code></li>
<li><code><a title="xmodel.Field.fset" href="#xmodel.Field.fset">fset</a></code></li>
<li><code><a title="xmodel.Field.getter" href="#xmodel.Field.getter">getter</a></code></li>
<li><code><a title="xmodel.Field.include_in_repr" href="#xmodel.Field.include_in_repr">include_in_repr</a></code></li>
<li><code><a title="xmodel.Field.include_with_fields" href="#xmodel.Field.include_with_fields">include_with_fields</a></code></li>
<li><code><a title="xmodel.Field.is_foreign_key" href="#xmodel.Field.is_foreign_key">is_foreign_key</a></code></li>
<li><code><a title="xmodel.Field.json_path" href="#xmodel.Field.json_path">json_path</a></code></li>
<li><code><a title="xmodel.Field.json_path_separator" href="#xmodel.Field.json_path_separator">json_path_separator</a></code></li>
<li><code><a title="xmodel.Field.model" href="#xmodel.Field.model">model</a></code></li>
<li><code><a title="xmodel.Field.name" href="#xmodel.Field.name">name</a></code></li>
<li><code><a title="xmodel.Field.nullable" href="#xmodel.Field.nullable">nullable</a></code></li>
<li><code><a title="xmodel.Field.original_type_hint" href="#xmodel.Field.original_type_hint">original_type_hint</a></code></li>
<li><code><a title="xmodel.Field.post_filter" href="#xmodel.Field.post_filter">post_filter</a></code></li>
<li><code><a title="xmodel.Field.read_only" href="#xmodel.Field.read_only">read_only</a></code></li>
<li><code><a title="xmodel.Field.related_field" href="#xmodel.Field.related_field">related_field</a></code></li>
<li><code><a title="xmodel.Field.related_field_name_for_id" href="#xmodel.Field.related_field_name_for_id">related_field_name_for_id</a></code></li>
<li><code><a title="xmodel.Field.related_to_many" href="#xmodel.Field.related_to_many">related_to_many</a></code></li>
<li><code><a title="xmodel.Field.related_type" href="#xmodel.Field.related_type">related_type</a></code></li>
<li><code><a title="xmodel.Field.resolve_defaults" href="#xmodel.Field.resolve_defaults">resolve_defaults</a></code></li>
<li><code><a title="xmodel.Field.resolve_remaining_defaults_to_none" href="#xmodel.Field.resolve_remaining_defaults_to_none">resolve_remaining_defaults_to_none</a></code></li>
<li><code><a title="xmodel.Field.setter" href="#xmodel.Field.setter">setter</a></code></li>
<li><code><a title="xmodel.Field.type_hint" href="#xmodel.Field.type_hint">type_hint</a></code></li>
<li><code><a title="xmodel.Field.was_option_explicitly_set_by_user" href="#xmodel.Field.was_option_explicitly_set_by_user">was_option_explicitly_set_by_user</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.JsonModel" href="#xmodel.JsonModel">JsonModel</a></code></h4>
<ul class="">
<li><code><a title="xmodel.JsonModel.__init_subclass__" href="base/model.html#xmodel.JsonModel.__init_subclass__">__init_subclass__</a></code></li>
<li><code><a title="xmodel.JsonModel.api" href="#xmodel.JsonModel.api">api</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.XModelError" href="#xmodel.XModelError">XModelError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>