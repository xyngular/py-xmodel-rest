<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>xmodel.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xmodel.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from xmodel.base.model import BaseModel
from xmodel.base.api import BaseApi
from xmodel.base.structure import BaseStructure

__all__ = [
    &#34;BaseModel&#34;,
    &#34;BaseStructure&#34;,
    &#34;BaseApi&#34;
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="xmodel.base.api" href="api.html">xmodel.base.api</a></code></dt>
<dd>
<div class="desc"><p>If you don't know much about the ORM, read <a href="./#orm-library-overview">ORM Library Overview</a> first! …</p></div>
</dd>
<dt><code class="name"><a title="xmodel.base.fields" href="fields.html">xmodel.base.fields</a></code></dt>
<dd>
<div class="desc"><div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Write this module doc-comment, here is a link that might be useful;
it links back to the the overview doc for field objects at …</p>
</div></div>
</dd>
<dt><code class="name"><a title="xmodel.base.model" href="model.html">xmodel.base.model</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="xmodel.base.structure" href="structure.html">xmodel.base.structure</a></code></dt>
<dd>
<div class="desc"><p>See <code><a title="xmodel.base.BaseStructure" href="#xmodel.base.BaseStructure">BaseStructure</a></code> for more details; This lets you discover/kee-track/find structural details
of a <code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xmodel.base.BaseApi"><code class="flex name class">
<span>class <span class="ident">BaseApi</span></span>
<span>(</span><span>*, api: <a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a>[M] = None, model: <a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is a sort of "Central Hub" that ties all intrested parties together.</p>
<p>You can get the correct instance via <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>.</p>
<p>In order to reduce any name-collisions for other normal Model attributes, everything
related to the BaseApi that the <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> needs is gotten though via
this class.</p>
<p>You can get the BaseApi instance related to the model via
<code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>.</p>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; obj = BaseModel.api.get_via_id(1)
</code></pre>
<p>For more information see <a href="#api-class-overview">BaseApi Class Overview</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;You can probably skip the rest (below)</p>
<p>Most of the time you don't create <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code> objects your self, and so for most people
you can skip the following unless you want to know more about internal details.</p>
</div>
<h1 id="init-method-specifics">Init Method Specifics</h1>
<p>Normally you would not create an <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code> object directly your self.
<code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s know how to do this automatically.
It happens in <code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code>.</p>
<p>Details about how the arguments you can pass are below.</p>
<h2 id="basemodel-class-construction">BaseModel Class Construction:</h2>
<p>If you provide an <code><a title="xmodel.base.api" href="api.html">xmodel.base.api</a></code> arg without a <code><a title="xmodel.base.model" href="model.html">xmodel.base.model</a></code> arg; we will copy the <code><a title="xmodel.base.BaseApi.structure" href="#xmodel.base.BaseApi.structure">BaseApi.structure</a></code>
into new object, resetting the error status, and internal <code>BaseApi._state</code> to None.
This <code><a title="xmodel.base.api" href="api.html">xmodel.base.api</a></code> object is supposed to be the parent BaseModel's class api object.</p>
<p>If both <code><a title="xmodel.base.api" href="api.html">xmodel.base.api</a></code> arg + <code><a title="xmodel.base.model" href="model.html">xmodel.base.model</a></code> arg are <code>None</code>, the BaseModel is the root/generic BaseModel
(ie: it has no parent BaseModel).</p>
<p>This is what is done by BaseModel classes while the class is lazily loading and
creating/configuring the BaseModel class and it's associated <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code> object
(accessible via <code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>)</p>
<h2 id="basemodel-instance-creation">BaseModel Instance Creation:</h2>
<p>If you also pass in a <code><a title="xmodel.base.model" href="model.html">xmodel.base.model</a></code> arg; this get you a special copy of the api you passed in
for use just with that BaseModel instance. The model <code>BaseApi._state</code> will be allocated
internally in the init'd BaseApi object. This is how a <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance get's it's own associated <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code> object
(that's a different instance vs the one set on BaseModel class when the BaseModel class
was originally constructed).</p>
<p>All params are optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>
<p>The "parent" BaseApi obj to copy the basic structure from as a starting point,
etc.
The superclasses BaseApi class is passed via this arg.
This is only used when allocating a new <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code> object for a new
<code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> class (not an instance, a model class/type).
This BaseApi object is used for the class-level BaseModel api object;
ie: via "ModelClass.api"</p>
<p>See above "BaseModel Class Construction" for more details.</p>
</dd>
<dt><strong><code>model</code></strong></dt>
<dd>
<p>BaseModel to associate new BaseApi obj with.
This is only used to create a new BaseApi object for a
<code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
instance for an already-existing type. ie: for BaseModel object instances.</p>
<p>See above "BaseModel Instance Creation" for more details.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseApi(Generic[M]):
    &#34;&#34;&#34;
        This class is a sort of &#34;Central Hub&#34; that ties all intrested parties together.

        You can get the correct instance via `xmodel.base.model.BaseModel`.

        In order to reduce any name-collisions for other normal Model attributes, everything
        related to the BaseApi that the `xmodel.base.model.BaseModel` needs is gotten though via
        this class.

        You can get the BaseApi instance related to the model via
        `xmodel.base.model.BaseModel.api`.

        Example:

        &gt;&gt;&gt; obj = BaseModel.api.get_via_id(1)

        For more information see [BaseApi Class Overview](#api-class-overview).
    &#34;&#34;&#34;

    # Defaults Types to use. When you sub-class BaseApi, you can declare/override these type-hints
    # and specify a different type... The system will allocate and use that new type instead
    # for you automatically on any instances created of the class.
    #
    # The BaseAuth won&#39;t modify the request to add auth; so it&#39;s safe to use as the base default.
    #
    # These are implemented via `@property` methods further below, but these are the type-hints.
    #
    # The properties and the __init__ method all use these type-hints in order to use the correct
    # type for each one on-demand as needed. For details on each one, see the @property method(s).
    #
    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. I get around this bug by using a
    # different initial-name for the property by pre-pending a `_` to it,
    # and then setting it to the correct name later.
    #
    # Example: `structure = _structure` is done after `def _structure(...)` is defined.

    # See `_structure` method for docs and method that gets this value.
    structure: BaseStructure[Field]

    @property
    def _structure(self):
        &#34;&#34;&#34;
        Contain things that don&#39;t vary among the model instances;
        ie: This is the same object and applies to all instances of a particular BaseModel class.

        This object has a list of `xmodel.fields.Field` that apply to the
        `xmodel.base.model.BaseModel` you can get via
        `xmodel.base.structure.Structure.fields`; for example.

        This is currently created in `BaseApi.__init__`.

        BaseApi instance for a BaseModel is only created when first asked for via
        `xmodel.base.model.BaseModel.api`.

        Returns:
            BaseStructure: Structure with correct field and model type in it.
        &#34;&#34;&#34;
        return self._structure

    # PyCharm has some sort of issue, if I provide property type-hint and then a property function
    # that implements it. For some reason, this makes it ignore the type-hint in subclasses
    # but NOT in the current class.  It&#39;s some sort of bug. This gets around it since pycharm
    # can&#39;t figure out what&#39;s going on here.
    structure = _structure

    _structure = None
    &#34;&#34;&#34; See `BaseApi.structure`.
    &#34;&#34;&#34;

    # ------------------------------
    # --------- Properties ---------

    default_converters: Dict[Type[Any], Converter] = None
    &#34;&#34;&#34;
    For an overview of type-converts, see
    [Type Converters Overview](./#type-converters).

    The class attribute defaults to `None`, but an instance/object will always have
    some sort of dict in place (happens during init call).

    Notice the `todo` note in the [overview](./#type-converters). I want it to work that way in the
    future (so via `BaseApi.set_default_converter` and `BaseApi.get_default_converter`).
    It&#39;s something coming in the future. For now you&#39;ll need to override
    `default_converters` and/or change it directly.

    You can provide your own values for this directly in a sub-class,
    when an BaseApi or subclass is created, we will merge converters in this order,
    with things later in the order taking precedence and override it:

    1. `xmodel.converters.DEFAULT_CONVERTERS`
    2. `BaseApi.default_converters` from `xmodel.base.model.BaseModel.api` from parent model.
        The parent model is the one the model is directly inheriting from.
    3. Finally, `BaseApi.default_converters` from the BaseApi subclass&#39;s class attribute
       (only looks on type/class directly for `default_converters`).

    It takes this final mapping and sets it on `self.default_converters`,
    and will be inherited as explained on on line number `2` above in the future.

    Default converters we have defined at the moment:

    - `xmodel.converters.convert_json_date`
    - `xmodel.converters.convert_json_datetime`
    - And a set of basic converters via `xmodel.converters.ConvertBasicType`, supports:
        - float
        - bool
        - str
        - int

    See `xmodel.converters.DEFAULT_CONVERTERS` to see the default converters map/dict.

    Maps type-hint to a default converter.  This converter will be used for `TypeValue.convert`
    when the model BaseStructure is create if none is provided for it at field definition time
    for a particular type-hint. If a type-hint is not in this converter, no convert is
    called for it.

    You don&#39;t need to provide one of these for a `xmodel.base.model.BaseModel` type-hint,
    as the system knows to call json/update_from_json on those types of objects.

    The default value provides a way to convert to/from a dt.date/dt.datetime and a string.
    &#34;&#34;&#34;

    # def set_default_converter(self, type, converter):
    #     &#34;&#34;&#34; NOT IMPLEMENTED YET -
    #     .. Todo:: Josh: These were here to look up a converter from a parent if a child does not
    #         have one  I have not figured out what I want to do here quite yet...
    #
    #         See todo at [Type Converters](./#type-converters) for an explanation of what this may
    #         be in the future.
    #
    #     &#34;&#34;&#34;
    #     raise NotImplementedError()
    #
    # def get_default_converter(self, type) -&gt; Optional[Converter]:
    #     &#34;&#34;&#34; NOT IMPLEMENTED YET -
    #     .. Todo:: Josh: These were here to look up a converter from a parent if a child does not
    #         have one  I have not figured out what I want to do here quite yet...
    #
    #         See todo at [Type Converters](./#type-converters) for an explanation of what this may
    #         be in the future.
    #     &#34;&#34;&#34;
    #     raise NotImplementedError()

    # ------------------------------
    # --------- Properties ---------

    @property
    def model_type(self) -&gt; Type[M]:
        &#34;&#34;&#34; The same BaseApi class is meant to be re-used for any number of Models,
            and so a BaseModel specifies it&#39;s BaseApi type as generic `BaseApi[M]`. In this case
            is the BaseModel it&#39;s self.  That way we can have the type-system aware that different
            instances of the same BaseApi class can specify different associated BaseModel classes.

            This property will return the BaseModel type/class associated with this BaseApi
            instance.
        &#34;&#34;&#34;
        # noinspection PyTypeChecker
        return self.structure.model_cls

    # ---------------------------
    # --------- Methods ---------

    # noinspection PyMissingConstructor
    def __init__(self, *, api: &#34;BaseApi[M]&#34; = None, model: BaseModel = None):
        &#34;&#34;&#34;

        .. warning:: You can probably skip the rest (below)
            Most of the time you don&#39;t create `BaseApi` objects your self, and so for most people
            you can skip the following unless you want to know more about internal details.

        # Init Method Specifics

        Normally you would not create an `BaseApi` object directly your self.
        `xmodel.base.model.BaseModel`&#39;s know how to do this automatically.
        It happens in `xmodel.base.model.BaseModel.__init_subclass__`.

        Details about how the arguments you can pass are below.

        ## BaseModel Class Construction:

        If you provide an `api` arg without a `model` arg; we will copy the `BaseApi.structure`
        into new object, resetting the error status, and internal `BaseApi._state` to None.
        This `api` object is supposed to be the parent BaseModel&#39;s class api object.

        If both `api` arg + `model` arg are `None`, the BaseModel is the root/generic BaseModel
        (ie: it has no parent BaseModel).

        This is what is done by BaseModel classes while the class is lazily loading and
        creating/configuring the BaseModel class and it&#39;s associated `BaseApi` object
        (accessible via `xmodel.base.model.BaseModel.api`)

        ## BaseModel Instance Creation:

        If you also pass in a `model` arg; this get you a special copy of the api you passed in
        for use just with that BaseModel instance. The model `BaseApi._state` will be allocated
        internally in the init&#39;d BaseApi object. This is how a `xmodel.base.model.BaseModel`
        instance get&#39;s it&#39;s own associated `BaseApi` object
        (that&#39;s a different instance vs the one set on BaseModel class when the BaseModel class
        was originally constructed).

        All params are optional.

        Args:
            api: The &#34;parent&#34; BaseApi obj to copy the basic structure from as a starting point,
                etc.
                The superclasses BaseApi class is passed via this arg.
                This is only used when allocating a new `BaseApi` object for a new
                `xmodel.base.model.BaseModel` class (not an instance, a model class/type).
                This BaseApi object is used for the class-level BaseModel api object;
                ie: via &#34;ModelClass.api&#34;

                See above &#34;BaseModel Class Construction&#34; for more details.

            model:  BaseModel to associate new BaseApi obj with.
                This is only used to create a new BaseApi object for a
                `xmodel.base.model.BaseModel`
                instance for an already-existing type. ie: for BaseModel object instances.

                See above &#34;BaseModel Instance Creation&#34; for more details.
        &#34;&#34;&#34;
        if api and model:
            raise XModelError(
                f&#34;You can&#39;t pass in an BaseApi {api} and BaseModel {model} simultaneously.&#34;
            )

        if model:
            api = type(model).api

        if not api:
            assert not model, &#34;You can&#39;t pass in a model without an associated api/model obj.&#34;

        if model:
            # If we have a model, the structure should be exactly the same as it&#39;s BaseModel type.
            self._structure = api.structure
            self._api_state = PrivateApiState(model=model)
            return

        # If We don&#39;t have a BaseModel, then we need to copy the structure, it could change
        # because we are being allocated for a new BaseModel type at the class/type level;
        # this means we are not associated with a specific BaseModel instance, only a BaseModel
        # type.

        # We lookup the structure type that our associated model-type/class wants to use.
        structure_type = get_type_hints(type(self)).get(
            &#39;structure&#39;,
            BaseStructure[Field]
        )

        args = typing_inspect.get_args(structure_type)
        field_type = args[0] if args else Field

        # We have a root BaseModel with the abstract BaseModel as its super class,
        # in this case we need to allocate a blank structure object.
        # todo: allocate structure with new args
        existing_struct = api.structure if api else None
        self._structure = structure_type(
            parent=existing_struct,
            field_type=field_type
        )

        # default_converters is a mapping of type to convert too, and a converter callable.
        #
        # We want to inherit from the parent and converters they already have defined.
        #
        # Take any parent converters as they currently exist, and use them as a basis for our
        # converters. Then take any converters directly assigned to self and override the any
        # parent converters, when they both have a converter for the same key/type.
        self.default_converters = {
            **DEFAULT_CONVERTERS,
            **(api.default_converters or {} if api else {}),
            **(type(self).default_converters or {}),
        }

    # ----------------------------------------------------
    # --------- Things REQUIRING an Associated BaseModel -----

    @property
    def model(self) -&gt; BaseModel[M]:
        &#34;&#34;&#34; REQUIRES associated model object [see doc text below].

        Gives you back the model associated with this api. If this BaseApi obj is associated
        directly with the BaseModel class type and so there is no associated model, I will
        raise an exception.

        Some BaseApi methods are dependant on having an associated model, and when they ask for it
        and there is None, this will raise an exception for them. The first line of the doc
        comment tells you if it needs one.  Normally, it&#39;s pretty obvious if the method
        will need the model, due to what it will return to you (ie: if it would need model attrs).

        The methods that are dependant on a model are ones, like &#39;json&#39;, where it returns the
        JSON for a model.  It needs a model to get this data.

        If you access an object api via a BaseModel object, that will be the associated model.
        If you access it via a BaseModel type/class, it will be directly associated with the model
        class.

        Examples:
        &gt;&gt;&gt; # Grab Account model from some_lib (as an example).
        &gt;&gt;&gt; from some_lib.account import Account
        &gt;&gt;&gt;
        &gt;&gt;&gt; # api object is associated with MyModelClass class, not model obj.
        &gt;&gt;&gt; Account.api
        &gt;&gt;&gt;
        &gt;&gt;&gt; account_obj = Account.api.get_via_id(3)
        &gt;&gt;&gt; # api is associated with the account_obj model object.
        &gt;&gt;&gt; account_obj.api
        &gt;&gt;&gt;
        &gt;&gt;&gt; # This sends object attributes to API, so it needs an associated
        &gt;&gt;&gt; # BaseModel object, so this works:
        &gt;&gt;&gt; account_obj.api.send()
        &gt;&gt;&gt;
        &gt;&gt;&gt; # This would produce an exception, since it would try to get BaseModel
        &gt;&gt;&gt; # attributes to send. But there is no associated model.
        &gt;&gt;&gt; Account.api.send()

        &#34;&#34;&#34;
        api_state = self._api_state
        assert api_state, &#34;BaseApi needs an attached model obj and there is no associated &#34; \
                          &#34;model api state.&#34;
        model = api_state.model
        assert model, &#34;BaseApi needs an attached model obj and there is none.&#34;
        return model

    def get_child_without_lazy_lookup(
            self,
            child_field_name,
            *,
            false_if_not_set=False,
    ) -&gt; Union[BaseModel[M], None, bool, NullType]:
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        If the child is current set to Null, or an object, returns that value.
        Will NOT lazily lookup child, even if its possible to do so.

        :param child_field_name: The field name of the child object.
        :param false_if_not_set:
            Possible Values [Default: False]:
                * False: Return None if nothing is currently set.
                * True:  Return False if nothing is currently set. This lets you distinguish
                  between having a None value set on field vs nothing set at all.
                  Normally this distinction is only useful internally in this class,
                  external users probably don&#39;t need this option.
        &#34;&#34;&#34;

        model = self.model

        if not self.structure.is_field_a_child(child_field_name):
            raise XModelError(
                f&#34;Called get_child_without_lazy_lookup(&#39;{child_field_name}&#39;) but &#34;
                f&#34;field ({child_field_name}) is NOT a child field on model ({model}).&#34;)

        if child_field_name in model.__dict__:
            return getattr(model, child_field_name)

        if false_if_not_set:
            return False

        return None

    @property
    def have_changes(self) -&gt; bool:
        &#34;&#34;&#34; Is True if `self.json(only_include_changes=True)` is not None;
            see json() method for more details.
        &#34;&#34;&#34;
        log.debug(f&#34;Checking Obj {self.model} to see if I have any changes [have_changes]&#34;)
        return self.json(only_include_changes=True) is not None

    def json(
        self, only_include_changes: bool = False, log_output: bool = False
    ) -&gt; Optional[JsonDict]:
        &#34;&#34;&#34; REQUIRES associated model object (see `BaseApi.model` for details on this).

        Return associated model object as a JsonDict (str keys, any value), ready to be encoded
        via JSON encoder and sent to the API.

        Args:
            only_include_changes: If True, will only include what changed in the JsonDict result.
                Defaults to False.
                This is normally set to True if system is sending this object via PATCH, which is
                the  normal way the system sends objects to API.

                If only_include_changes is False (default), we always include everything that
                is not &#39;None&#39;.
                When a `xmodel.base.client.BaseClient` subclass
                (such as `xmodel.rest.RestClient`)
                calls this method, it will pass in a value based on it&#39;s own
                `xmodel.rest.RestClient.enable_send_changes_only` is set to
                (defaults to False there too).
                You can override the RestClient.enable_send_changes_only at the BaseModel class
                level by making a RestClient subclass and setting `enable_send_changes_only` to
                default to `True`.

                There is a situations where we have to include all attributes, regardless:
                    1. If the &#39;id&#39; field is set to a &#39;None&#39; value. This indicates we need to create
                       a new object, and we are not partially updating an existing one, even if we
                       got updated via json at some point in the past.

                As always, properties set to None will *NOT* be included in returned JsonDict,
                regardless of what options have been set.

            log_output (bool): If False (default): won&#39;t log anything.
                If True: Logs what method returns at debug level.


        Returns:
            JsonDict: Will the needed attributes that should be sent to API.
                If returned value is None, that means only_include_changes is True
                and there were no changes.

                The returned dict is a copy and so can be mutated be the caller.
        &#34;&#34;&#34;

        # todo: Refactor _get_fields() to return getter/setter closures for each field, and we
        #       can make this whole method more generic that way. We also can &#39;cache&#39; the logic
        #       needed that way instead of having to figure it out each time, every time.

        structure = self.structure
        model = self.model
        api_state = self._api_state

        json: JsonDict = {}

        field_objs = structure.fields

        # Negate only_include_changes if we don&#39;t have any original update json to compare against.
        if only_include_changes and api_state.last_original_update_json is None:
            only_include_changes = False

        # noinspection PyDefaultArgument
        def set_value_into_json_dict(value, field_name, *, json=json):
            # Sets field value directly on json dict or passed in dict...
            if value is not None:
                # Convert Null into None (that&#39;s how JSON converter represents a Null).
                json[field_name] = value if value is not Null else None

        for field_obj in field_objs:
            # If we are read-only, no need to do anything more.
            if field_obj.read_only:
                continue

            # We deal with non-related types later.
            related_type = field_obj.related_type
            if not related_type:
                continue

            f = field_obj.name
            if field_obj.read_only:
                continue

            # todo: For now, the &#39;api-field-path&#39; option can&#39;t be used at the same time as obj-r.
            if field_obj.json_path != field_obj.name:
                # I&#39;ve put in some initial support for this below, but it&#39;s has not been tested
                # for now, keep raising an exception for this like we have been.
                # There is a work-around, see bottom part of the message in the below error:
                raise NotImplementedError(
                    f&#34;Can&#39;t have xmodel.Field on BaseModel with related-type and a json_path &#34;
                    f&#34;that differ at the moment, for field ({field_obj}). &#34;
                    f&#34;It is something I want to support someday; the support is mostly in place &#34;
                    f&#34;already, but it needs some more careful thought, attention and testing &#34;
                    f&#34;before we should allow it. &#34;
                    &#34;Workaround:  Make an `{field.name}_id` field next to related field on the &#34;
                    &#34;model. Then, set `json_path` for that `{field.name}_id` field, set it to &#34;
                    &#34;what you want it to be. Finally, set the `{related_field.name}` to &#34;
                    &#34;read_only=True. This allows you to rename the `_id` field used to/from api &#34;
                    &#34;in the JSON input/output, but the Model can have an alternate name for the &#34;
                    &#34;related field. You can see a real-example of this at &#34;
                    &#34;`bigcommerce.api.orders._BcCommonOrderMetafield.order&#34;
                )

            obj_type_structure = related_type.api.structure
            obj_type_has_id = obj_type_structure.has_id_field()

            if obj_type_has_id:
                # If the obj uses an &#39;id&#39;, then we have a {field_name}_id we want to
                # send instead of the full object as a json dict.
                #
                # This will grab the id from child obj if it exists, or from a defined field
                # of f&#34;{f}_id&#34; or finally from related id storage.

                # todo: If there is an object with no &#39;id&#39; value, do we ignore it?
                #   or should we embed full object anyway?

                child_obj_id = api_state.get_related_field_id(f)

                # Method below should deal with None vs Null.
                set_value_into_json_dict(child_obj_id, f&#34;{f}_id&#34;)
            else:
                obj: &#39;BaseModel[M]&#39; = getattr(model, f)

                # Related-object has no &#39;id&#39;, so get it&#39;s json dict and set that into the output.
                v = obj
                if obj is not Null and obj is not None:
                    # todo: a Field option to override this and always provide all
                    #   values (if object always needs to be fully embedded).
                    v = obj.api.json(only_include_changes=only_include_changes)

                # if it returns None (ie: no changes) and only_include_changes is enabled,
                # don&#39;t include the sub-object as a change.
                if v is not None or not only_include_changes:
                    # Method below should deal with None vs Null.
                    set_value_into_json_dict(v, f)

        for field_obj in field_objs:
            # If we are read-only, no need to do anything more.
            if field_obj.read_only:
                continue

            # We don&#39;t deal with related-types here.
            if field_obj.related_type:
                continue

            f = field_obj.name
            v = getattr(model, f)
            if v is not None and field_obj.converter:
                # Convert the value....
                v = field_obj.converter(
                    api=self,
                    direction=Converter.Direction.to_json,
                    field=field_obj,
                    value=v
                )

            path = field_obj.json_path
            if not path:
                set_value_into_json_dict(v, f)
                continue

            path_list = path.split(field_obj.json_path_separator)
            d = json
            for name in path_list[:-1]:
                d = d.setdefault(name, {})
            name = path_list[-1]

            # Sets field value into a sub-dictionary of the original `json` dict.
            set_value_into_json_dict(v, name, json=d)

        # If the `last_original_update_json` is None, then we never got update via JSON
        # so there is nothing to compare, include everything!
        if only_include_changes:
            log.debug(f&#34;Checking Obj {model} for changes to include.&#34;)
            fields_to_pop = self.fields_to_pop_for_json(json, field_objs, log_output)

            for f in fields_to_pop:
                del json[f]

            if not json:
                # If nothing in JSON, then return None.
                return None
        else:
            due_to_msg = &#34;unknown&#34;
            if not only_include_changes:
                due_to_msg = &#34;only_include_changes is False&#34;
            if api_state.last_original_update_json is None:
                due_to_msg = &#34;no original json value&#34;

            if log_output:
                log.debug(f&#34;Including everything for obj {model} due to {due_to_msg}.&#34;)

                # Log out at debug level what we are including in the JSON.
                for field, new_value in json.items():
                    log.debug(
                        f&#34;   Included field ({field}) value ({new_value})&#34;
                    )

        for k, v in json.items():
            # Must use list of JSON, convert any sets to a list.
            if type(v) is set:
                v = list(v)
                json[k] = v

        return json

    def fields_to_pop_for_json(
            self, json: dict, field_objs: List[Field], log_output: bool
    ) -&gt; Set[Any]:
        &#34;&#34;&#34;
        Goes through the list of fields (field_objs) to determine which ones have not changed in
        order to pop them out of the json representation. This method is used when we only want to
        include the changes in the json.

        :param json: dict representation of a model&#39;s fields and field values as they are currently
            set on the model.
        :param field_objs: List of fields and their values for a model
        :param log_output: boolean to determine if we should log the output or not
        :return: The field keys to remove from the json representation of the model.
        &#34;&#34;&#34;
        fields_to_pop = set()
        for field, new_value in json.items():

            # json has simple strings, numbers, lists, dict;
            # so makes general comparison simpler.
            old_value = self._get_old_json_value(field=field, as_type=type(new_value))

            if old_value is Default:
                if log_output:
                    log.debug(
                        f&#34;   Included field ({field}) with value &#34;
                        f&#34;({new_value}) because there is no original json value for it.&#34;
                    )
            elif self.should_include_field_in_json(
                    new_value=new_value,
                    old_value=old_value,
                    field=field
            ):
                if log_output:
                    log.debug(
                        f&#34;   Included field ({field}) due to new value &#34;
                        f&#34;({new_value}) != old value ({old_value}).&#34;
                    )
            else:
                # We don&#39;t want to mutate dict while traversing it, remember this for later.
                fields_to_pop.add(field)

        # Map a field-key to what other fields should be included if field-key value is used.
        # For now we are NOT supporting `Field.json_path` to keep things simpler
        # when used in conjunction with `Field.include_with_fields`.
        # `Field` will raise an exception if json_path != field name and include_with_fields
        # is used at the same time.
        # It&#39;s something I would like to support in the future, but for now it&#39;s not needed.
        # We can assume that `field_obj.name == field_obj.json_path`
        for field_obj in field_objs:
            if not field_obj.include_with_fields:
                continue
            if field_obj.name not in fields_to_pop:
                continue
            if not (field_obj.include_with_fields &lt;= fields_to_pop):
                fields_to_pop.remove(field_obj.name)

        return fields_to_pop

    def should_include_field_in_json(self, new_value: Any, old_value: Any, field: str) -&gt; bool:
        &#34;&#34;&#34;
        Returns True if the the value for field should be included in the JSON.
        This only gets called if only_include_changes is True when passed to self.json::

            # Passed in like so:
            self.json(only_include_changes=True)

        This method is an easy way to change the comparison logic.

        :param new_value: New value that will be put into JSON.
        :param old_value:
            Old value originals in original JSON [normalized if possible to the same type as
            new_value.
        :param field: Field name.
        :return:
            If True: Will include the fields value in an update.
            If False: Won&#39;t include the fields value in an update.
        &#34;&#34;&#34;
        # Convert old value to set if new value is set and old value is list (from original JSON).
        # If I was really cool :)... I would find out the inner type in case of int/str
        # and to a conversion to compare Apples to Apples.....
        # But trying to minimize changes so I don&#39;t conflict as much with soon to be
        # xmodel-dynamo feature.
        if type(new_value) is set and type(old_value) is list:
            old_value = set(old_value)

        return new_value != old_value

    def _get_old_json_value(self, *, field: str, as_type: Type = None) -&gt; Optional[Any]:
        &#34;&#34;&#34; Returns the old field-values; Will return `Default` if there is no original value.  &#34;&#34;&#34;
        original_json = self._api_state.last_original_update_json
        if original_json is None:
            # todo: Is there another value we could return here to indicate that we
            #       never got an original value in the first place?
            #
            # todo: Also, think about how we could do above todo ^ per-field
            #       [ie: if field was requested in the first place].
            return Default

        old_value = original_json.get(field, Default)
        if old_value is Default:
            # None is a valid value in JSON,
            # this indicates to do the Default thing/value with this field since we don&#39;t have any
            # original value for it.
            return Default

        # json has simple strings, numbers, lists, dict;
        # so makes general comparison simpler.
        old_type = type(old_value)
        if as_type != old_type:
            str_compatible_types = {str, int, float}
            if as_type in str_compatible_types and old_type in str_compatible_types:
                try:
                    # The &#39;id&#39; field is a string and not an int [for example], so in
                    # general, we want to try and convert the old value into the new
                    # values type before comparison, if possible, for the basic types
                    # of str, int, float.
                    old_value = as_type(old_value)
                except ValueError:
                    # Just be sure it&#39;s the same value/type, should be but just in case.
                    old_value = original_json.get(field, None)
                    pass
        return old_value

    def copy_from_model(self, model: BaseModel):
        their_fields = model.api.structure.field_map
        my_fields = self.structure.field_map
        keys = [k for k in their_fields if k in my_fields]

        # Assume we have a model, and are not the class-based `MyModel.api....` version.
        # todo: have `self.model` raise an exception if called on the class api version
        #   (which does not have a related model, just knows about model-type.).
        my_model = self.model
        for k in keys:
            their_value = getattr(model, k)
            if their_value is not None:
                setattr(my_model, k, their_value)

    def update_from_json(self, json: Union[JsonDict, Mapping]):
        &#34;&#34;&#34; REQUIRES associated model object [see self.model].

        todo: Needs more documentation

        We update the dict per-key, with what we got passed in [via &#39;json&#39; parameter]
        overriding anything we got previously. This also makes a copy of the dict, which is
        want we want [no change to modify the incoming dict parameter].
        &#34;&#34;&#34;

        structure = self.structure
        model = self.model
        api_state = self._api_state

        if not isinstance(json, Mapping):
            raise XModelError(
                f&#34;update_from_json(...) was given a non-mapping parameter ({json}).&#34;
            )

        # Merge the old values with the new values.
        api_state.last_original_update_json = {
            **(api_state.last_original_update_json or {}),
            **json
        }

        fields = structure.fields

        values = {}
        for field_obj in fields:
            path_list = field_obj.json_path.split(field_obj.json_path_separator)
            v = json
            got_value = True
            for name in path_list:
                if name not in v:
                    # We don&#39;t even have a &#39;None&#39; value so we assume we just did not get the value
                    # from the api, and therefore we just skip doing anything with it.
                    got_value = False
                    break

                v = v.get(name)
                if v is None:
                    break

            # We map the value we got from JSON into a flat-dict with the BaseModel name as the
            # key...
            if got_value:
                values[field_obj.name] = v if v is not None else Null

        def set_attr_on_model(field, value, model=model):
            &#34;&#34;&#34; Closure to set attr on self unless value is None.
            &#34;&#34;&#34;
            if value is None:
                return
            setattr(model, field, value)

        # Merge in the outer json, keeping the values we mapped [via Field.json_path] for conflicts
        values = {**json, **values}

        # todo: If the json does not have a value [not even a &#39;None&#39; value], don&#39;t update?
        #       We may have gotten a partial update?  For now, always update [even to None]
        #       all defined fields regardless if they are inside the json or not.

        for field_obj in fields:
            # We deal with related types later....
            if field_obj.related_type:
                continue

            f = field_obj.name
            v = values.get(f, Default)

            # A None from JSON means a Null for us.
            # If JSON does not include anything, that&#39;s a None for us.
            if v is None:
                v = Null
            elif v is Default:
                v = None

            # Run the converter if needed.
            # If we have a None value, we don&#39;t need to convert that, there was no value to
            # convert.
            if field_obj.converter and v is not None:
                v = field_obj.converter(
                    self,
                    Converter.Direction.from_json,
                    field_obj,
                    v
                )

            set_attr_on_model(f, v)

        for field_obj in fields:
            # Ok, now we deal with related types...
            related_type = field_obj.related_type
            if not related_type:
                continue

            f = field_obj.name

            # todo: at some point, allow customization of this via Field class
            #   Also, s tore the id
            f_id_name = f&#34;{f}_id&#34;
            if typing_inspect.get_origin(field_obj.type_hint) is list:
                # todo: This code is not complete [Kaden never finished it up]
                #   for now, just comment out.

                raise NotImplementedError(
                    &#34;Type-hints for xmodel models in this format: `attr: List[SomeType]` &#34;
                    &#34;are not currently supported. We want to support it someday. For now you &#34;
                    &#34;must use lower-cased non-generic `list`. At some point the idea is to &#34;
                    &#34;allow one to do `List[ChildModel]` and then we know it&#39;s a list of &#34;
                    &#34;other BaseModel objects and automatically handle that in some way.&#34;
                )

                # child_type: &#39;Type[BaseModel[M]]&#39;
                # child_type = typing_inspect.get_args(obj_type)
                # # __args__ returns a tuple of all arguments passed into List[] so we need to
                # # pull the class out of the tuple
                # if child_type:
                #     child_type = child_type[0]
                #
                # child_api: BaseApi
                # child_api = child_type.api
                # if not child_api and child_api.structure.has_id_field:
                #     # TODO: add a non generic Exception for this
                #     raise XModelError(
                #         f&#34;{model} has an attribute with name ({f}) with type-hint List that &#34;
                #         f&#34;doesn&#39;t contain an API BaseModel Type as the only argument&#34;
                #     )
                # parent_name = model.__class__.__name__.lower()
                # state.set_related_field_id(f, parent_name)
                # continue

            v = None
            if f in values:
                v = values.get(f, Null)
                if v is not Null:
                    v = related_type(v)

            # Check to see if we have an api/json field for object relation name with &#34;_id&#34; on
            # end.
            if v is None and related_type.api.structure.has_id_field():
                # If we don&#39;t have a defined field for this value, check JSON for it and store it.
                #
                # If we have a defined None value for the id field, meaning the field exists
                # in the json, and is set directly to None, then we have a Null relationship.
                # We set that as the value, since there is no need to &#39;lookup&#39; a null value.
                f_id_value = json.get(f_id_name)
                id_field = structure.get_field(f_id_name)

                if not id_field:
                    id_field = field_obj.related_type.api.structure.get_field(&#39;id&#39;)

                # Run the converter if needed.
                # If we have a None value, we don&#39;t need to convert that, there was no value to
                # convert.
                if id_field and id_field.converter and f_id_value is not None:
                    f_id_value = id_field.converter(
                        self,
                        Converter.Direction.from_json,
                        id_field,
                        f_id_value
                    )

                if f_id_value is None and f_id_name in json:
                    # We have a Null situation.
                    f_id_value = Null

                if f_id_value is not None:
                    # We have an id!
                    # Set the value to support automatic lookup of value, lazily.
                    # This method also takes care to set child object to Null or delete it
                    # as needed depending on the f_id_value and what the child&#39;s id field value is.
                    api_state.set_related_field_id(f, f_id_value)
            else:
                # &#39;v&#39; is either going to be None, Null or an BaseModel object.
                set_attr_on_model(f, v)

    def list_of_attrs_to_repr(self) -&gt; List[str]:
        &#34;&#34;&#34;&#34; REQUIRES associated model object [see self.model].

        A list of attribute names to put into the __repr__/string representation
        of the associated model object. This is consulted when the BaseModel has __repr__
        called on it.
        &#34;&#34;&#34;
        names = set()
        model = self.model

        # todo: Move this into pres-club override of list_of_attrs_to_repr in an BaseApi subclass.
        if hasattr(model, &#39;account_id&#39;):
            names.add(&#39;account_id&#39;)

        # todo: Consider adding others here, perhaps all defined fields on model that have
        # todo: a non-None value?

        for f in self.structure.fields:
            if f.include_in_repr:
                names.add(f.name)
        return list(names)

    def forget_original_json_state(self):
        &#34;&#34;&#34; If called, we forget/reset the orginal json state, which is a combination
            of all the json that this object has been updated with over it&#39;s lifetime.

            The json state is what allows the object to decide what has changed,
            when it&#39;s requested to only include changes via the `BaseApi.json` method.

            If forgotten, it&#39;s as-if we never got the json in the first place to compare against.
            Therefore, all attributes that have values will be returned for this object
            when it&#39;s only requested to include changes
            (the RestClient in xmodel-rest can request it to do this, as an example).

            Resetting the state here only effects this object, not any child objects.
            You&#39;ll have to ask child objects directly to forget t heir original json, if desired.
        &#34;&#34;&#34;
        self._api_state.last_original_update_json = None

    # ----------------------------
    # --------- Private ----------
    #
    # I want to make the state and structure private for now, because it might change a bit later.
    # Want to give this some opportunity to be used for a while to see where the areas for
    # improvement are before potentially opening it up publicly to things outside of the sdk.

    _api_state: PrivateApiState[M] = None
    &#34;&#34;&#34; This object will vary from BaseModel class instance-to-instance, and is the area we keep
        api state that is Private for the BaseModel instance.

        Will be None if we are directly associated with BaseModel class, otherwise this will be the
        BaseModel&#39;s instance state, methods in this object need the BaseModel instance.
    &#34;&#34;&#34;

    @property
    def context(self) -&gt; XContext:
        &#34;&#34;&#34; BaseApi context to use when asking this object to send/delete/etc its self to/from
            service.

            This is an old hold-over from when we used to keep a XContext reference.
            This is the same as calling `xinject.context.XContext.current`.
        &#34;&#34;&#34;
        return XContext.grab()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.remote.api.RemoteApi" href="../remote/api.html#xmodel.remote.api.RemoteApi">RemoteApi</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.base.BaseApi.default_converters"><code class="name">var <span class="ident">default_converters</span> : Dict[Type[Any], <a title="xmodel.base.fields.Converter" href="fields.html#xmodel.base.fields.Converter">Converter</a>]</code></dt>
<dd>
<div class="desc"><p>For an overview of type-converts, see
<a href="./#type-converters">Type Converters Overview</a>.</p>
<p>The class attribute defaults to <code>None</code>, but an instance/object will always have
some sort of dict in place (happens during init call).</p>
<p>Notice the <code>todo</code> note in the <a href="./#type-converters">overview</a>. I want it to work that way in the
future (so via <code>BaseApi.set_default_converter</code> and <code>BaseApi.get_default_converter</code>).
It's something coming in the future. For now you'll need to override
<code>default_converters</code> and/or change it directly.</p>
<p>You can provide your own values for this directly in a sub-class,
when an BaseApi or subclass is created, we will merge converters in this order,
with things later in the order taking precedence and override it:</p>
<ol>
<li><code>xmodel.converters.DEFAULT_CONVERTERS</code></li>
<li><code><a title="xmodel.base.BaseApi.default_converters" href="#xmodel.base.BaseApi.default_converters">BaseApi.default_converters</a></code> from <code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> from parent model.
The parent model is the one the model is directly inheriting from.</li>
<li>Finally, <code><a title="xmodel.base.BaseApi.default_converters" href="#xmodel.base.BaseApi.default_converters">BaseApi.default_converters</a></code> from the BaseApi subclass's class attribute
(only looks on type/class directly for <code>default_converters</code>).</li>
</ol>
<p>It takes this final mapping and sets it on <code>self.default_converters</code>,
and will be inherited as explained on on line number <code>2</code> above in the future.</p>
<p>Default converters we have defined at the moment:</p>
<ul>
<li><code><a title="xmodel.converters.convert_json_date" href="../converters.html#xmodel.converters.convert_json_date">convert_json_date()</a></code></li>
<li><code><a title="xmodel.converters.convert_json_datetime" href="../converters.html#xmodel.converters.convert_json_datetime">convert_json_datetime()</a></code></li>
<li>And a set of basic converters via <code><a title="xmodel.converters.ConvertBasicType" href="../converters.html#xmodel.converters.ConvertBasicType">ConvertBasicType</a></code>, supports:<ul>
<li>float</li>
<li>bool</li>
<li>str</li>
<li>int</li>
</ul>
</li>
</ul>
<p>See <code>xmodel.converters.DEFAULT_CONVERTERS</code> to see the default converters map/dict.</p>
<p>Maps type-hint to a default converter.
This converter will be used for <code>TypeValue.convert</code>
when the model BaseStructure is create if none is provided for it at field definition time
for a particular type-hint. If a type-hint is not in this converter, no convert is
called for it.</p>
<p>You don't need to provide one of these for a <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> type-hint,
as the system knows to call json/update_from_json on those types of objects.</p>
<p>The default value provides a way to convert to/from a dt.date/dt.datetime and a string.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.base.BaseApi.context"><code class="name">var <span class="ident">context</span> : <a title="xinject.context.XContext" href="../../xinject/context.html#xinject.context.XContext">XContext</a></code></dt>
<dd>
<div class="desc"><p>BaseApi context to use when asking this object to send/delete/etc its self to/from
service.</p>
<p>This is an old hold-over from when we used to keep a XContext reference.
This is the same as calling <code><a title="xinject.context.XContext.current" href="../../xinject/context.html#xinject.context.XContext.current">XContext.current()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; XContext:
    &#34;&#34;&#34; BaseApi context to use when asking this object to send/delete/etc its self to/from
        service.

        This is an old hold-over from when we used to keep a XContext reference.
        This is the same as calling `xinject.context.XContext.current`.
    &#34;&#34;&#34;
    return XContext.grab()</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.have_changes"><code class="name">var <span class="ident">have_changes</span> : bool</code></dt>
<dd>
<div class="desc"><p>Is True if <code>self.json(only_include_changes=True)</code> is not None;
see json() method for more details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def have_changes(self) -&gt; bool:
    &#34;&#34;&#34; Is True if `self.json(only_include_changes=True)` is not None;
        see json() method for more details.
    &#34;&#34;&#34;
    log.debug(f&#34;Checking Obj {self.model} to see if I have any changes [have_changes]&#34;)
    return self.json(only_include_changes=True) is not None</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.model"><code class="name">var <span class="ident">model</span> : <a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M]</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see doc text below].</p>
<p>Gives you back the model associated with this api. If this BaseApi obj is associated
directly with the BaseModel class type and so there is no associated model, I will
raise an exception.</p>
<p>Some BaseApi methods are dependant on having an associated model, and when they ask for it
and there is None, this will raise an exception for them. The first line of the doc
comment tells you if it needs one.
Normally, it's pretty obvious if the method
will need the model, due to what it will return to you (ie: if it would need model attrs).</p>
<p>The methods that are dependant on a model are ones, like 'json', where it returns the
JSON for a model.
It needs a model to get this data.</p>
<p>If you access an object api via a BaseModel object, that will be the associated model.
If you access it via a BaseModel type/class, it will be directly associated with the model
class.</p>
<p>Examples:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Grab Account model from some_lib (as an example).
&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt;
&gt;&gt;&gt; # api object is associated with MyModelClass class, not model obj.
&gt;&gt;&gt; Account.api
&gt;&gt;&gt;
&gt;&gt;&gt; account_obj = Account.api.get_via_id(3)
&gt;&gt;&gt; # api is associated with the account_obj model object.
&gt;&gt;&gt; account_obj.api
&gt;&gt;&gt;
&gt;&gt;&gt; # This sends object attributes to API, so it needs an associated
&gt;&gt;&gt; # BaseModel object, so this works:
&gt;&gt;&gt; account_obj.api.send()
&gt;&gt;&gt;
&gt;&gt;&gt; # This would produce an exception, since it would try to get BaseModel
&gt;&gt;&gt; # attributes to send. But there is no associated model.
&gt;&gt;&gt; Account.api.send()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; BaseModel[M]:
    &#34;&#34;&#34; REQUIRES associated model object [see doc text below].

    Gives you back the model associated with this api. If this BaseApi obj is associated
    directly with the BaseModel class type and so there is no associated model, I will
    raise an exception.

    Some BaseApi methods are dependant on having an associated model, and when they ask for it
    and there is None, this will raise an exception for them. The first line of the doc
    comment tells you if it needs one.  Normally, it&#39;s pretty obvious if the method
    will need the model, due to what it will return to you (ie: if it would need model attrs).

    The methods that are dependant on a model are ones, like &#39;json&#39;, where it returns the
    JSON for a model.  It needs a model to get this data.

    If you access an object api via a BaseModel object, that will be the associated model.
    If you access it via a BaseModel type/class, it will be directly associated with the model
    class.

    Examples:
    &gt;&gt;&gt; # Grab Account model from some_lib (as an example).
    &gt;&gt;&gt; from some_lib.account import Account
    &gt;&gt;&gt;
    &gt;&gt;&gt; # api object is associated with MyModelClass class, not model obj.
    &gt;&gt;&gt; Account.api
    &gt;&gt;&gt;
    &gt;&gt;&gt; account_obj = Account.api.get_via_id(3)
    &gt;&gt;&gt; # api is associated with the account_obj model object.
    &gt;&gt;&gt; account_obj.api
    &gt;&gt;&gt;
    &gt;&gt;&gt; # This sends object attributes to API, so it needs an associated
    &gt;&gt;&gt; # BaseModel object, so this works:
    &gt;&gt;&gt; account_obj.api.send()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # This would produce an exception, since it would try to get BaseModel
    &gt;&gt;&gt; # attributes to send. But there is no associated model.
    &gt;&gt;&gt; Account.api.send()

    &#34;&#34;&#34;
    api_state = self._api_state
    assert api_state, &#34;BaseApi needs an attached model obj and there is no associated &#34; \
                      &#34;model api state.&#34;
    model = api_state.model
    assert model, &#34;BaseApi needs an attached model obj and there is none.&#34;
    return model</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.model_type"><code class="name">var <span class="ident">model_type</span> : Type[~M]</code></dt>
<dd>
<div class="desc"><p>The same BaseApi class is meant to be re-used for any number of Models,
and so a BaseModel specifies it's BaseApi type as generic <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a>[M]</code>. In this case
is the BaseModel it's self.
That way we can have the type-system aware that different
instances of the same BaseApi class can specify different associated BaseModel classes.</p>
<p>This property will return the BaseModel type/class associated with this BaseApi
instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model_type(self) -&gt; Type[M]:
    &#34;&#34;&#34; The same BaseApi class is meant to be re-used for any number of Models,
        and so a BaseModel specifies it&#39;s BaseApi type as generic `BaseApi[M]`. In this case
        is the BaseModel it&#39;s self.  That way we can have the type-system aware that different
        instances of the same BaseApi class can specify different associated BaseModel classes.

        This property will return the BaseModel type/class associated with this BaseApi
        instance.
    &#34;&#34;&#34;
    # noinspection PyTypeChecker
    return self.structure.model_cls</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.structure"><code class="name">var <span class="ident">structure</span> : <a title="xmodel.base.structure.BaseStructure" href="structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a>[<a title="xmodel.base.fields.Field" href="fields.html#xmodel.base.fields.Field">Field</a>]</code></dt>
<dd>
<div class="desc"><p>Contain things that don't vary among the model instances;
ie: This is the same object and applies to all instances of a particular BaseModel class.</p>
<p>This object has a list of <code>xmodel.fields.Field</code> that apply to the
<code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> you can get via
<code>xmodel.base.structure.Structure.fields</code>; for example.</p>
<p>This is currently created in <code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code>.</p>
<p>BaseApi instance for a BaseModel is only created when first asked for via
<code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="xmodel.base.BaseStructure" href="#xmodel.base.BaseStructure">BaseStructure</a></code></dt>
<dd>Structure with correct field and model type in it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def _structure(self):
    &#34;&#34;&#34;
    Contain things that don&#39;t vary among the model instances;
    ie: This is the same object and applies to all instances of a particular BaseModel class.

    This object has a list of `xmodel.fields.Field` that apply to the
    `xmodel.base.model.BaseModel` you can get via
    `xmodel.base.structure.Structure.fields`; for example.

    This is currently created in `BaseApi.__init__`.

    BaseApi instance for a BaseModel is only created when first asked for via
    `xmodel.base.model.BaseModel.api`.

    Returns:
        BaseStructure: Structure with correct field and model type in it.
    &#34;&#34;&#34;
    return self._structure</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.base.BaseApi.copy_from_model"><code class="name flex">
<span>def <span class="ident">copy_from_model</span></span>(<span>self, model: <a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_from_model(self, model: BaseModel):
    their_fields = model.api.structure.field_map
    my_fields = self.structure.field_map
    keys = [k for k in their_fields if k in my_fields]

    # Assume we have a model, and are not the class-based `MyModel.api....` version.
    # todo: have `self.model` raise an exception if called on the class api version
    #   (which does not have a related model, just knows about model-type.).
    my_model = self.model
    for k in keys:
        their_value = getattr(model, k)
        if their_value is not None:
            setattr(my_model, k, their_value)</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.fields_to_pop_for_json"><code class="name flex">
<span>def <span class="ident">fields_to_pop_for_json</span></span>(<span>self, json: dict, field_objs: List[<a title="xmodel.base.fields.Field" href="fields.html#xmodel.base.fields.Field">Field</a>], log_output: bool) ‑> Set[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Goes through the list of fields (field_objs) to determine which ones have not changed in
order to pop them out of the json representation. This method is used when we only want to
include the changes in the json.</p>
<p>:param json: dict representation of a model's fields and field values as they are currently
set on the model.
:param field_objs: List of fields and their values for a model
:param log_output: boolean to determine if we should log the output or not
:return: The field keys to remove from the json representation of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fields_to_pop_for_json(
        self, json: dict, field_objs: List[Field], log_output: bool
) -&gt; Set[Any]:
    &#34;&#34;&#34;
    Goes through the list of fields (field_objs) to determine which ones have not changed in
    order to pop them out of the json representation. This method is used when we only want to
    include the changes in the json.

    :param json: dict representation of a model&#39;s fields and field values as they are currently
        set on the model.
    :param field_objs: List of fields and their values for a model
    :param log_output: boolean to determine if we should log the output or not
    :return: The field keys to remove from the json representation of the model.
    &#34;&#34;&#34;
    fields_to_pop = set()
    for field, new_value in json.items():

        # json has simple strings, numbers, lists, dict;
        # so makes general comparison simpler.
        old_value = self._get_old_json_value(field=field, as_type=type(new_value))

        if old_value is Default:
            if log_output:
                log.debug(
                    f&#34;   Included field ({field}) with value &#34;
                    f&#34;({new_value}) because there is no original json value for it.&#34;
                )
        elif self.should_include_field_in_json(
                new_value=new_value,
                old_value=old_value,
                field=field
        ):
            if log_output:
                log.debug(
                    f&#34;   Included field ({field}) due to new value &#34;
                    f&#34;({new_value}) != old value ({old_value}).&#34;
                )
        else:
            # We don&#39;t want to mutate dict while traversing it, remember this for later.
            fields_to_pop.add(field)

    # Map a field-key to what other fields should be included if field-key value is used.
    # For now we are NOT supporting `Field.json_path` to keep things simpler
    # when used in conjunction with `Field.include_with_fields`.
    # `Field` will raise an exception if json_path != field name and include_with_fields
    # is used at the same time.
    # It&#39;s something I would like to support in the future, but for now it&#39;s not needed.
    # We can assume that `field_obj.name == field_obj.json_path`
    for field_obj in field_objs:
        if not field_obj.include_with_fields:
            continue
        if field_obj.name not in fields_to_pop:
            continue
        if not (field_obj.include_with_fields &lt;= fields_to_pop):
            fields_to_pop.remove(field_obj.name)

    return fields_to_pop</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.forget_original_json_state"><code class="name flex">
<span>def <span class="ident">forget_original_json_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If called, we forget/reset the orginal json state, which is a combination
of all the json that this object has been updated with over it's lifetime.</p>
<p>The json state is what allows the object to decide what has changed,
when it's requested to only include changes via the <code><a title="xmodel.base.BaseApi.json" href="#xmodel.base.BaseApi.json">BaseApi.json()</a></code> method.</p>
<p>If forgotten, it's as-if we never got the json in the first place to compare against.
Therefore, all attributes that have values will be returned for this object
when it's only requested to include changes
(the RestClient in xmodel-rest can request it to do this, as an example).</p>
<p>Resetting the state here only effects this object, not any child objects.
You'll have to ask child objects directly to forget t heir original json, if desired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forget_original_json_state(self):
    &#34;&#34;&#34; If called, we forget/reset the orginal json state, which is a combination
        of all the json that this object has been updated with over it&#39;s lifetime.

        The json state is what allows the object to decide what has changed,
        when it&#39;s requested to only include changes via the `BaseApi.json` method.

        If forgotten, it&#39;s as-if we never got the json in the first place to compare against.
        Therefore, all attributes that have values will be returned for this object
        when it&#39;s only requested to include changes
        (the RestClient in xmodel-rest can request it to do this, as an example).

        Resetting the state here only effects this object, not any child objects.
        You&#39;ll have to ask child objects directly to forget t heir original json, if desired.
    &#34;&#34;&#34;
    self._api_state.last_original_update_json = None</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.get_child_without_lazy_lookup"><code class="name flex">
<span>def <span class="ident">get_child_without_lazy_lookup</span></span>(<span>self, child_field_name, *, false_if_not_set=False) ‑> Union[<a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a>[~M], None, bool, <a title="xsentinels.null.NullType" href="../../xsentinels/null.html#xsentinels.null.NullType">NullType</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see self.model].</p>
<p>If the child is current set to Null, or an object, returns that value.
Will NOT lazily lookup child, even if its possible to do so.</p>
<p>:param child_field_name: The field name of the child object.
:param false_if_not_set:
Possible Values [Default: False]:
* False: Return None if nothing is currently set.
* True:
Return False if nothing is currently set. This lets you distinguish
between having a None value set on field vs nothing set at all.
Normally this distinction is only useful internally in this class,
external users probably don't need this option.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_child_without_lazy_lookup(
        self,
        child_field_name,
        *,
        false_if_not_set=False,
) -&gt; Union[BaseModel[M], None, bool, NullType]:
    &#34;&#34;&#34; REQUIRES associated model object [see self.model].

    If the child is current set to Null, or an object, returns that value.
    Will NOT lazily lookup child, even if its possible to do so.

    :param child_field_name: The field name of the child object.
    :param false_if_not_set:
        Possible Values [Default: False]:
            * False: Return None if nothing is currently set.
            * True:  Return False if nothing is currently set. This lets you distinguish
              between having a None value set on field vs nothing set at all.
              Normally this distinction is only useful internally in this class,
              external users probably don&#39;t need this option.
    &#34;&#34;&#34;

    model = self.model

    if not self.structure.is_field_a_child(child_field_name):
        raise XModelError(
            f&#34;Called get_child_without_lazy_lookup(&#39;{child_field_name}&#39;) but &#34;
            f&#34;field ({child_field_name}) is NOT a child field on model ({model}).&#34;)

    if child_field_name in model.__dict__:
        return getattr(model, child_field_name)

    if false_if_not_set:
        return False

    return None</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, only_include_changes: bool = False, log_output: bool = False) ‑> Optional[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object (see <code><a title="xmodel.base.BaseApi.model" href="#xmodel.base.BaseApi.model">BaseApi.model</a></code> for details on this).</p>
<p>Return associated model object as a JsonDict (str keys, any value), ready to be encoded
via JSON encoder and sent to the API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>only_include_changes</code></strong></dt>
<dd>
<p>If True, will only include what changed in the JsonDict result.
Defaults to False.
This is normally set to True if system is sending this object via PATCH, which is
the
normal way the system sends objects to API.</p>
<p>If only_include_changes is False (default), we always include everything that
is not 'None'.
When a <code>xmodel.base.client.BaseClient</code> subclass
(such as <code>xmodel.rest.RestClient</code>)
calls this method, it will pass in a value based on it's own
<code>xmodel.rest.RestClient.enable_send_changes_only</code> is set to
(defaults to False there too).
You can override the RestClient.enable_send_changes_only at the BaseModel class
level by making a RestClient subclass and setting <code>enable_send_changes_only</code> to
default to <code>True</code>.</p>
<p>There is a situations where we have to include all attributes, regardless:
1. If the 'id' field is set to a 'None' value. This indicates we need to create
a new object, and we are not partially updating an existing one, even if we
got updated via json at some point in the past.</p>
<p>As always, properties set to None will <em>NOT</em> be included in returned JsonDict,
regardless of what options have been set.</p>
</dd>
<dt><strong><code>log_output</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False (default): won't log anything.
If True: Logs what method returns at debug level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JsonDict</code></dt>
<dd>
<p>Will the needed attributes that should be sent to API.
If returned value is None, that means only_include_changes is True
and there were no changes.</p>
<p>The returned dict is a copy and so can be mutated be the caller.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(
    self, only_include_changes: bool = False, log_output: bool = False
) -&gt; Optional[JsonDict]:
    &#34;&#34;&#34; REQUIRES associated model object (see `BaseApi.model` for details on this).

    Return associated model object as a JsonDict (str keys, any value), ready to be encoded
    via JSON encoder and sent to the API.

    Args:
        only_include_changes: If True, will only include what changed in the JsonDict result.
            Defaults to False.
            This is normally set to True if system is sending this object via PATCH, which is
            the  normal way the system sends objects to API.

            If only_include_changes is False (default), we always include everything that
            is not &#39;None&#39;.
            When a `xmodel.base.client.BaseClient` subclass
            (such as `xmodel.rest.RestClient`)
            calls this method, it will pass in a value based on it&#39;s own
            `xmodel.rest.RestClient.enable_send_changes_only` is set to
            (defaults to False there too).
            You can override the RestClient.enable_send_changes_only at the BaseModel class
            level by making a RestClient subclass and setting `enable_send_changes_only` to
            default to `True`.

            There is a situations where we have to include all attributes, regardless:
                1. If the &#39;id&#39; field is set to a &#39;None&#39; value. This indicates we need to create
                   a new object, and we are not partially updating an existing one, even if we
                   got updated via json at some point in the past.

            As always, properties set to None will *NOT* be included in returned JsonDict,
            regardless of what options have been set.

        log_output (bool): If False (default): won&#39;t log anything.
            If True: Logs what method returns at debug level.


    Returns:
        JsonDict: Will the needed attributes that should be sent to API.
            If returned value is None, that means only_include_changes is True
            and there were no changes.

            The returned dict is a copy and so can be mutated be the caller.
    &#34;&#34;&#34;

    # todo: Refactor _get_fields() to return getter/setter closures for each field, and we
    #       can make this whole method more generic that way. We also can &#39;cache&#39; the logic
    #       needed that way instead of having to figure it out each time, every time.

    structure = self.structure
    model = self.model
    api_state = self._api_state

    json: JsonDict = {}

    field_objs = structure.fields

    # Negate only_include_changes if we don&#39;t have any original update json to compare against.
    if only_include_changes and api_state.last_original_update_json is None:
        only_include_changes = False

    # noinspection PyDefaultArgument
    def set_value_into_json_dict(value, field_name, *, json=json):
        # Sets field value directly on json dict or passed in dict...
        if value is not None:
            # Convert Null into None (that&#39;s how JSON converter represents a Null).
            json[field_name] = value if value is not Null else None

    for field_obj in field_objs:
        # If we are read-only, no need to do anything more.
        if field_obj.read_only:
            continue

        # We deal with non-related types later.
        related_type = field_obj.related_type
        if not related_type:
            continue

        f = field_obj.name
        if field_obj.read_only:
            continue

        # todo: For now, the &#39;api-field-path&#39; option can&#39;t be used at the same time as obj-r.
        if field_obj.json_path != field_obj.name:
            # I&#39;ve put in some initial support for this below, but it&#39;s has not been tested
            # for now, keep raising an exception for this like we have been.
            # There is a work-around, see bottom part of the message in the below error:
            raise NotImplementedError(
                f&#34;Can&#39;t have xmodel.Field on BaseModel with related-type and a json_path &#34;
                f&#34;that differ at the moment, for field ({field_obj}). &#34;
                f&#34;It is something I want to support someday; the support is mostly in place &#34;
                f&#34;already, but it needs some more careful thought, attention and testing &#34;
                f&#34;before we should allow it. &#34;
                &#34;Workaround:  Make an `{field.name}_id` field next to related field on the &#34;
                &#34;model. Then, set `json_path` for that `{field.name}_id` field, set it to &#34;
                &#34;what you want it to be. Finally, set the `{related_field.name}` to &#34;
                &#34;read_only=True. This allows you to rename the `_id` field used to/from api &#34;
                &#34;in the JSON input/output, but the Model can have an alternate name for the &#34;
                &#34;related field. You can see a real-example of this at &#34;
                &#34;`bigcommerce.api.orders._BcCommonOrderMetafield.order&#34;
            )

        obj_type_structure = related_type.api.structure
        obj_type_has_id = obj_type_structure.has_id_field()

        if obj_type_has_id:
            # If the obj uses an &#39;id&#39;, then we have a {field_name}_id we want to
            # send instead of the full object as a json dict.
            #
            # This will grab the id from child obj if it exists, or from a defined field
            # of f&#34;{f}_id&#34; or finally from related id storage.

            # todo: If there is an object with no &#39;id&#39; value, do we ignore it?
            #   or should we embed full object anyway?

            child_obj_id = api_state.get_related_field_id(f)

            # Method below should deal with None vs Null.
            set_value_into_json_dict(child_obj_id, f&#34;{f}_id&#34;)
        else:
            obj: &#39;BaseModel[M]&#39; = getattr(model, f)

            # Related-object has no &#39;id&#39;, so get it&#39;s json dict and set that into the output.
            v = obj
            if obj is not Null and obj is not None:
                # todo: a Field option to override this and always provide all
                #   values (if object always needs to be fully embedded).
                v = obj.api.json(only_include_changes=only_include_changes)

            # if it returns None (ie: no changes) and only_include_changes is enabled,
            # don&#39;t include the sub-object as a change.
            if v is not None or not only_include_changes:
                # Method below should deal with None vs Null.
                set_value_into_json_dict(v, f)

    for field_obj in field_objs:
        # If we are read-only, no need to do anything more.
        if field_obj.read_only:
            continue

        # We don&#39;t deal with related-types here.
        if field_obj.related_type:
            continue

        f = field_obj.name
        v = getattr(model, f)
        if v is not None and field_obj.converter:
            # Convert the value....
            v = field_obj.converter(
                api=self,
                direction=Converter.Direction.to_json,
                field=field_obj,
                value=v
            )

        path = field_obj.json_path
        if not path:
            set_value_into_json_dict(v, f)
            continue

        path_list = path.split(field_obj.json_path_separator)
        d = json
        for name in path_list[:-1]:
            d = d.setdefault(name, {})
        name = path_list[-1]

        # Sets field value into a sub-dictionary of the original `json` dict.
        set_value_into_json_dict(v, name, json=d)

    # If the `last_original_update_json` is None, then we never got update via JSON
    # so there is nothing to compare, include everything!
    if only_include_changes:
        log.debug(f&#34;Checking Obj {model} for changes to include.&#34;)
        fields_to_pop = self.fields_to_pop_for_json(json, field_objs, log_output)

        for f in fields_to_pop:
            del json[f]

        if not json:
            # If nothing in JSON, then return None.
            return None
    else:
        due_to_msg = &#34;unknown&#34;
        if not only_include_changes:
            due_to_msg = &#34;only_include_changes is False&#34;
        if api_state.last_original_update_json is None:
            due_to_msg = &#34;no original json value&#34;

        if log_output:
            log.debug(f&#34;Including everything for obj {model} due to {due_to_msg}.&#34;)

            # Log out at debug level what we are including in the JSON.
            for field, new_value in json.items():
                log.debug(
                    f&#34;   Included field ({field}) value ({new_value})&#34;
                )

    for k, v in json.items():
        # Must use list of JSON, convert any sets to a list.
        if type(v) is set:
            v = list(v)
            json[k] = v

    return json</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.list_of_attrs_to_repr"><code class="name flex">
<span>def <span class="ident">list_of_attrs_to_repr</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>" REQUIRES associated model object [see self.model].</p>
<p>A list of attribute names to put into the <strong>repr</strong>/string representation
of the associated model object. This is consulted when the BaseModel has <strong>repr</strong>
called on it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_of_attrs_to_repr(self) -&gt; List[str]:
    &#34;&#34;&#34;&#34; REQUIRES associated model object [see self.model].

    A list of attribute names to put into the __repr__/string representation
    of the associated model object. This is consulted when the BaseModel has __repr__
    called on it.
    &#34;&#34;&#34;
    names = set()
    model = self.model

    # todo: Move this into pres-club override of list_of_attrs_to_repr in an BaseApi subclass.
    if hasattr(model, &#39;account_id&#39;):
        names.add(&#39;account_id&#39;)

    # todo: Consider adding others here, perhaps all defined fields on model that have
    # todo: a non-None value?

    for f in self.structure.fields:
        if f.include_in_repr:
            names.add(f.name)
    return list(names)</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.should_include_field_in_json"><code class="name flex">
<span>def <span class="ident">should_include_field_in_json</span></span>(<span>self, new_value: Any, old_value: Any, field: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the the value for field should be included in the JSON.
This only gets called if only_include_changes is True when passed to self.json::</p>
<pre><code># Passed in like so:
self.json(only_include_changes=True)
</code></pre>
<p>This method is an easy way to change the comparison logic.</p>
<p>:param new_value: New value that will be put into JSON.
:param old_value:
Old value originals in original JSON [normalized if possible to the same type as
new_value.
:param field: Field name.
:return:
If True: Will include the fields value in an update.
If False: Won't include the fields value in an update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_include_field_in_json(self, new_value: Any, old_value: Any, field: str) -&gt; bool:
    &#34;&#34;&#34;
    Returns True if the the value for field should be included in the JSON.
    This only gets called if only_include_changes is True when passed to self.json::

        # Passed in like so:
        self.json(only_include_changes=True)

    This method is an easy way to change the comparison logic.

    :param new_value: New value that will be put into JSON.
    :param old_value:
        Old value originals in original JSON [normalized if possible to the same type as
        new_value.
    :param field: Field name.
    :return:
        If True: Will include the fields value in an update.
        If False: Won&#39;t include the fields value in an update.
    &#34;&#34;&#34;
    # Convert old value to set if new value is set and old value is list (from original JSON).
    # If I was really cool :)... I would find out the inner type in case of int/str
    # and to a conversion to compare Apples to Apples.....
    # But trying to minimize changes so I don&#39;t conflict as much with soon to be
    # xmodel-dynamo feature.
    if type(new_value) is set and type(old_value) is list:
        old_value = set(old_value)

    return new_value != old_value</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseApi.update_from_json"><code class="name flex">
<span>def <span class="ident">update_from_json</span></span>(<span>self, json: Union[Dict[str, Any], collections.abc.Mapping])</span>
</code></dt>
<dd>
<div class="desc"><p>REQUIRES associated model object [see self.model].</p>
<p>todo: Needs more documentation</p>
<p>We update the dict per-key, with what we got passed in [via 'json' parameter]
overriding anything we got previously. This also makes a copy of the dict, which is
want we want [no change to modify the incoming dict parameter].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_from_json(self, json: Union[JsonDict, Mapping]):
    &#34;&#34;&#34; REQUIRES associated model object [see self.model].

    todo: Needs more documentation

    We update the dict per-key, with what we got passed in [via &#39;json&#39; parameter]
    overriding anything we got previously. This also makes a copy of the dict, which is
    want we want [no change to modify the incoming dict parameter].
    &#34;&#34;&#34;

    structure = self.structure
    model = self.model
    api_state = self._api_state

    if not isinstance(json, Mapping):
        raise XModelError(
            f&#34;update_from_json(...) was given a non-mapping parameter ({json}).&#34;
        )

    # Merge the old values with the new values.
    api_state.last_original_update_json = {
        **(api_state.last_original_update_json or {}),
        **json
    }

    fields = structure.fields

    values = {}
    for field_obj in fields:
        path_list = field_obj.json_path.split(field_obj.json_path_separator)
        v = json
        got_value = True
        for name in path_list:
            if name not in v:
                # We don&#39;t even have a &#39;None&#39; value so we assume we just did not get the value
                # from the api, and therefore we just skip doing anything with it.
                got_value = False
                break

            v = v.get(name)
            if v is None:
                break

        # We map the value we got from JSON into a flat-dict with the BaseModel name as the
        # key...
        if got_value:
            values[field_obj.name] = v if v is not None else Null

    def set_attr_on_model(field, value, model=model):
        &#34;&#34;&#34; Closure to set attr on self unless value is None.
        &#34;&#34;&#34;
        if value is None:
            return
        setattr(model, field, value)

    # Merge in the outer json, keeping the values we mapped [via Field.json_path] for conflicts
    values = {**json, **values}

    # todo: If the json does not have a value [not even a &#39;None&#39; value], don&#39;t update?
    #       We may have gotten a partial update?  For now, always update [even to None]
    #       all defined fields regardless if they are inside the json or not.

    for field_obj in fields:
        # We deal with related types later....
        if field_obj.related_type:
            continue

        f = field_obj.name
        v = values.get(f, Default)

        # A None from JSON means a Null for us.
        # If JSON does not include anything, that&#39;s a None for us.
        if v is None:
            v = Null
        elif v is Default:
            v = None

        # Run the converter if needed.
        # If we have a None value, we don&#39;t need to convert that, there was no value to
        # convert.
        if field_obj.converter and v is not None:
            v = field_obj.converter(
                self,
                Converter.Direction.from_json,
                field_obj,
                v
            )

        set_attr_on_model(f, v)

    for field_obj in fields:
        # Ok, now we deal with related types...
        related_type = field_obj.related_type
        if not related_type:
            continue

        f = field_obj.name

        # todo: at some point, allow customization of this via Field class
        #   Also, s tore the id
        f_id_name = f&#34;{f}_id&#34;
        if typing_inspect.get_origin(field_obj.type_hint) is list:
            # todo: This code is not complete [Kaden never finished it up]
            #   for now, just comment out.

            raise NotImplementedError(
                &#34;Type-hints for xmodel models in this format: `attr: List[SomeType]` &#34;
                &#34;are not currently supported. We want to support it someday. For now you &#34;
                &#34;must use lower-cased non-generic `list`. At some point the idea is to &#34;
                &#34;allow one to do `List[ChildModel]` and then we know it&#39;s a list of &#34;
                &#34;other BaseModel objects and automatically handle that in some way.&#34;
            )

            # child_type: &#39;Type[BaseModel[M]]&#39;
            # child_type = typing_inspect.get_args(obj_type)
            # # __args__ returns a tuple of all arguments passed into List[] so we need to
            # # pull the class out of the tuple
            # if child_type:
            #     child_type = child_type[0]
            #
            # child_api: BaseApi
            # child_api = child_type.api
            # if not child_api and child_api.structure.has_id_field:
            #     # TODO: add a non generic Exception for this
            #     raise XModelError(
            #         f&#34;{model} has an attribute with name ({f}) with type-hint List that &#34;
            #         f&#34;doesn&#39;t contain an API BaseModel Type as the only argument&#34;
            #     )
            # parent_name = model.__class__.__name__.lower()
            # state.set_related_field_id(f, parent_name)
            # continue

        v = None
        if f in values:
            v = values.get(f, Null)
            if v is not Null:
                v = related_type(v)

        # Check to see if we have an api/json field for object relation name with &#34;_id&#34; on
        # end.
        if v is None and related_type.api.structure.has_id_field():
            # If we don&#39;t have a defined field for this value, check JSON for it and store it.
            #
            # If we have a defined None value for the id field, meaning the field exists
            # in the json, and is set directly to None, then we have a Null relationship.
            # We set that as the value, since there is no need to &#39;lookup&#39; a null value.
            f_id_value = json.get(f_id_name)
            id_field = structure.get_field(f_id_name)

            if not id_field:
                id_field = field_obj.related_type.api.structure.get_field(&#39;id&#39;)

            # Run the converter if needed.
            # If we have a None value, we don&#39;t need to convert that, there was no value to
            # convert.
            if id_field and id_field.converter and f_id_value is not None:
                f_id_value = id_field.converter(
                    self,
                    Converter.Direction.from_json,
                    id_field,
                    f_id_value
                )

            if f_id_value is None and f_id_name in json:
                # We have a Null situation.
                f_id_value = Null

            if f_id_value is not None:
                # We have an id!
                # Set the value to support automatic lookup of value, lazily.
                # This method also takes care to set child object to Null or delete it
                # as needed depending on the f_id_value and what the child&#39;s id field value is.
                api_state.set_related_field_id(f, f_id_value)
        else:
            # &#39;v&#39; is either going to be None, Null or an BaseModel object.
            set_attr_on_model(f, v)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xmodel.base.BaseModel"><code class="flex name class">
<span>class <span class="ident">BaseModel</span></span>
<span>(</span><span>*args, **initial_values)</span>
</code></dt>
<dd>
<div class="desc"><p>Used as the abstract base-class for classes/object that communicate with our REST API.</p>
<p>This is one of the main classes, and it's highly recommend you read the
<a href="./#orm-library-overview">SDK Library Overview</a> first, if you have not already.
That document has many basic examples of using this class along with other related classes.</p>
<p>Attributes that start with <code>_</code> or don't have a type-hint are not considered fields
on the object that automatically get mapped to/from the JSON that is passed in.
For more details see <a href="./#type-hints">Type Hints</a>.</p>
<p>When you sub-class <code><a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a></code>, you can create your own Model class, with your own
fields/attrs.
You can pass class arguments/paramters in when you declare your sub-class.
The Model-subclass can provide parameters to the super class during class construction.</p>
<p>In the example below, notice the <code>base_url</code> part. That's a class argument, that is used by the
super-class during the construction of the sub-class (before any instances are created).
In this case it takes this and stores it on
<code>xmodel.rest.RestStructure.base_model_url</code>
as part of the structure information for the <code><a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a></code> subclass.</p>
<p>See <a href="./#basic-model-example">Basic Model Example</a> for an example of what class arguments
are or look at this example below using a RestModel:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 'base_url' part is a class argument:
&gt;&gt;&gt; from xmodel.rest import RestModel
&gt;&gt;&gt; class Account(RestModel[&quot;Account&quot;], base_url='/account'):
&gt;&gt;&gt;    id: str
&gt;&gt;&gt;    name: str
</code></pre>
<p>These class arguments are sent to a special method
<code><a title="xmodel.base.structure.BaseStructure.configure_for_model_type" href="structure.html#xmodel.base.structure.BaseStructure.configure_for_model_type">BaseStructure.configure_for_model_type()</a></code>. See that methods docs for
a list of avaliable class-arguments.</p>
<p>See <code>BaseModel.__init_subclass__</code> for more on the internal details of how this works exactly.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;In the case of <code>base_url</code> example above, it's the base-url-endpoint for the model.</p>
<p>If you want to know more about that see <code>xmodel.rest.RestClient.url_for_endpoint</code>.
It has details on how the final request <code><a title="xurls.url.URL" href="../../xurls/url.html#xurls.url.URL">URL</a></code> is constructed.</p>
</div>
<p>This class also allows you to more easily with with JSON data via:</p>
<ul>
<li><code><a title="xmodel.base.api.BaseApi.json" href="api.html#xmodel.base.api.BaseApi.json">BaseApi.json()</a></code></li>
<li><code><a title="xmodel.base.api.BaseApi.update_from_json" href="api.html#xmodel.base.api.BaseApi.update_from_json">BaseApi.update_from_json()</a></code></li>
<li>Or passing a JSON dict as the first arrument to <code><a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a></code>.</li>
</ul>
<p>Other important related classes are listed below.</p>
<ul>
<li><code><a title="xmodel.base.api.BaseApi" href="api.html#xmodel.base.api.BaseApi">BaseApi</a></code> Accessable via <code><a title="xmodel.base.BaseModel.api" href="#xmodel.base.BaseModel.api">BaseModel.api</a></code>.</li>
<li><code>xmodel.rest.RestClient</code>: Accessable via <code>xmodel.base.api.BaseApi.client</code>.</li>
<li><code>xmodel.rest.settings.RestSettings</code>: Accessable via
<code>xmodel.base.api.BaseApi.settings</code>.</li>
<li><code><a title="xmodel.base.structure.BaseStructure" href="structure.html#xmodel.base.structure.BaseStructure">BaseStructure</a></code>: Accessable via
<code><a title="xmodel.base.api.BaseApi.structure" href="api.html#xmodel.base.api.BaseApi.structure">BaseApi.structure</a></code></li>
<li><code>xmodel.base.auth.BaseAuth</code>: Accessable via <code>xmodel.base.api.BaseApi.auth</code></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">Tip:&ensp;For all of the above, you can change what class is allocated for each one</p>
<p>by changing the type-hint on a subclass.</p>
</div>
<p>Creates a new model object. The first/second params need to be passed as positional
arguments. The rest must be sent as key-word arguments. Everything is optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>Specify the <code>BaseModel.id</code> attribute, if you know it. If left as Default, nothing
will be set on it. It could be set to something via args[0] (ie: a JSON dict).
If you do provide a value, it be set last after everything else has been set.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>
<p>I don't want to take names from what you could put into 'initial_values',
so I keep it as position-only *args. Once Python 3.8 comes out, we can use a
new feature where you can specify some arguments as positional-only and not
keyword-able.</p>
<h2 id="firstarg-if-dict">FirstArg - If Dict:</h2>
<p>If raw dictionary parsed from JSON string. It just calls
<code>self.api.update_from_json(args[0])</code> for you.</p>
<h2 id="firstart-if-basemodel">FirstArt - If BaseModel:</h2>
<p>If a <code><a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a></code>, will copy fields over that have the same name.
You can use this to duplicate a Model object, if you want to copy it.
Or can be used to copy fields from one model type into another,
on fields that are the same name.</p>
<p>Will ignore fields that are present on one but not the other.
Only copy fields that are on both models types.</p>
</dd>
<dt><strong><code>**initial_values</code></strong></dt>
<dd>Let's you specify other attribute values for convenience.
They will be set into the object the same way you would normally doing it:
ie: <code>model_obj.some_attr = v</code> is the same as <code>ModelClass(some_attr=v)</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseModel(Generic[M], ABC):
    &#34;&#34;&#34;
    Used as the abstract base-class for classes/object that communicate with our REST API.

    This is one of the main classes, and it&#39;s highly recommend you read the
    [SDK Library Overview](./#orm-library-overview) first, if you have not already.
    That document has many basic examples of using this class along with other related classes.

    Attributes that start with `_` or don&#39;t have a type-hint are not considered fields
    on the object that automatically get mapped to/from the JSON that is passed in.
    For more details see [Type Hints](./#type-hints).

    When you sub-class `BaseModel`, you can create your own Model class, with your own
    fields/attrs.
    You can pass class arguments/paramters in when you declare your sub-class.
    The Model-subclass can provide parameters to the super class during class construction.

    In the example below, notice the `base_url` part. That&#39;s a class argument, that is used by the
    super-class during the construction of the sub-class (before any instances are created).
    In this case it takes this and stores it on
    `xmodel.rest.RestStructure.base_model_url`
    as part of the structure information for the `BaseModel` subclass.

    See [Basic Model Example](./#basic-model-example) for an example of what class arguments
    are or look at this example below using a RestModel:

    &gt;&gt;&gt; # &#39;base_url&#39; part is a class argument:
    &gt;&gt;&gt; from xmodel.rest import RestModel
    &gt;&gt;&gt; class Account(RestModel[&#34;Account&#34;], base_url=&#39;/account&#39;):
    &gt;&gt;&gt;    id: str
    &gt;&gt;&gt;    name: str

    These class arguments are sent to a special method
    `xmodel.base.structure.BaseStructure.configure_for_model_type`. See that methods docs for
    a list of avaliable class-arguments.

    See `BaseModel.__init_subclass__` for more on the internal details of how this works exactly.

    .. note:: In the case of `base_url` example above, it&#39;s the base-url-endpoint for the model.
        If you want to know more about that see `xmodel.rest.RestClient.url_for_endpoint`.
        It has details on how the final request `xurls.url.URL` is constructed.

    This class also allows you to more easily with with JSON data via:

    - `xmodel.base.api.BaseApi.json`
    - `xmodel.base.api.BaseApi.update_from_json`
    - Or passing a JSON dict as the first arrument to `BaseModel.__init__`.

    Other important related classes are listed below.

    - `xmodel.base.api.BaseApi` Accessable via `BaseModel.api`.
    - `xmodel.rest.RestClient`: Accessable via `xmodel.base.api.BaseApi.client`.
    - `xmodel.rest.settings.RestSettings`: Accessable via
        `xmodel.base.api.BaseApi.settings`.
    - `xmodel.base.structure.BaseStructure`: Accessable via
        `xmodel.base.api.BaseApi.structure`
    - `xmodel.base.auth.BaseAuth`: Accessable via `xmodel.base.api.BaseApi.auth`

    .. tip:: For all of the above, you can change what class is allocated for each one
        by changing the type-hint on a subclass.

    &#34;&#34;&#34;

    # -------------------------------------
    # --------- Public Properties ---------

    api: &#34;BaseApi[M]&#34; = None
    &#34;&#34;&#34; Used to access the api class, which is used to retrieve/send objects to/from api.

        You can specify this as a type-hint in subclasses to change the class we use for this
        automatically, like so::
            from xmodel import BaseModel, BaseApi
            from typing import TypeVar

            M = TypeVar(&#34;M&#34;)

            class MyCoolApi(BaseApi[M]):
                pass

            class MyCoolModel(BaseModel[&#34;MyCoolModel&#34;]):
                api: MyCoolApi[M]  # If this model will have subclasses, you want to use a type-var

        The generic ``T`` type-var in this case refers to whatever model class that your using.
        In the example just above, ``T`` would be referring to ``MyCoolModel`` if you did this
        somewhere to get the BaseModel&#39;s api: ``MyCoolModel.api``.
    &#34;&#34;&#34;

    # --------------------------------------------
    # --------- Config/Option Properties ---------

    def __init_subclass__(
        cls: Type[M],
        *,
        lazy_loader: Callable[[Type[M]], None] = None,
        **kwargs
    ):
        &#34;&#34;&#34;
        We take all arguments (except `lazy_loader`) passed into here and send them to the method
        on our structure:
        `xmodel.base.structure.BaseStructure.configure_for_model_type`.
        This allows you to easily configure the BaseStructure via class arguments.

        For a list of class-arguments, see method parameters for
        `xmodel.base.structure.BaseStructure.configure_for_model_type`.

        See [Basic BaseModel Example](./#basic-model-example) for an example of what class
        arguments are for `BaseModel` classes and how to use them.

        We lazily configure BaseModel sub-classes. They are configured the first time that
        `BaseModel.api` is accessed under that subclass. At that point all parent + that specific
        subclass are configured and an `xmodel.base.api.BaseApi` object is created and set
        on the `BaseModel.api` attribute. From that point forward, that object is what is used.
        This only happens the first time that `BaseModel.api` is accessed.

        If you want to add support for additional BaseModel class arguments,
        you can do it by modifying the base-implementation
        `xmodel.base.structure.BaseStructure`.
        Or if you want it only for a specific sub-set of Models, you can make a custom
        `xmodel.base.structure.BaseStructure` subclass. You can configure your BaseModel to use
        this BaseStructure subclass via a type-hint on `xmodel.base.api.BaseApi.structure`.

        See `xmodel_dynamo.dynamo.DynStructure.configure_for_model_type` for a complete example of a
        custom BaseStructure subclass that adds extra class arguments that are specific to Dynamo.

        Args:
            lazy_loader: This is a callable where the first argument is `cls/self`.
                This is an optional param. If provided, we will call when we need to lazy-load
                but before we do our normal lazy-loading ourselves here.

                Most of the time, you&#39;ll want to import into the global/module space of where
                your class lives any imports you need to do lazily, such as circular imports.

                Right after we call your lazy_loader callable, we will be ourselves calling
                the method `get_type_hints` to get all of our type-hints.
                You&#39;ll want to be sure all of your forward-referenced type-hints on your
                model sub-class are resolvable.

                Forward-ref type hints are the ones that are string based type-hints,
                they get resolved lazily after your lazy_loader (if provided) is called.

                You can see in the code in our method below, look at the check for:

                &gt;&gt;&gt; if &#34;BaseApi&#34; not in globals():

                Look at that for a real-world example of what I am talking about.
                This little piece of code lazily resolves the `BaseApi` type.
        &#34;&#34;&#34;

        # We are taking all args and sending them to a xmodel.base.structure.BaseStructure
        # class object.
        super().__init_subclass__()

        def lazy_setup_api(cls_or_self):
            # If requested, before we do our own lazy-loading below, call passed in lazy-loader.
            if lazy_loader:
                lazy_loader(cls)

            for parent in cls.mro():
                if parent is not cls and issubclass(parent, BaseModel):
                    # Ensure that parent-class has a chance to lazy-load it&#39;s self
                    # before we try to examine our type-hints.
                    getattr(parent, &#39;api&#39;)

            # We potentially get called a lot (for every sub-class)
            # so check to see if we already loaded BaseApi type or not.
            if &#39;BaseApi&#39; not in globals():
                # Lazy import BaseApi into module, helps resolve BaseApi forward-refs;
                # ie: `api: &#34;BaseApi[T]&#34;`
                # We need to resolve these due to use of `get_type_hints()` below.
                #
                # Sets it in such a way so IDE&#39;s such as pycharm don&#39;t get confused + pydoc3
                # can still find it and use the type forward-reference.
                #
                # todo: figure out why dynamic model attribute getter is having an issue with this.
                #   (see that near start of this file at top ^^^)
                from xmodel import BaseApi
                globals()[&#39;BaseApi&#39;] = BaseApi
            try:
                all_type_hints = get_type_hints(cls)
            except (NameError, AttributeError) as e:
                from xmodel import XModelError
                raise XModelError(
                    f&#34;Unable to construct model subclass ({cls}) due to error resolving &#34;
                    f&#34;type-hints on model class. They must be visible at the module-level that &#34;
                    f&#34;the class is defined in. Original error: ({e}).&#34;
                ) from None

            api_cls: Type[&#34;BaseApi&#34;] = all_type_hints[&#39;api&#39;]

            base_cls = None
            for b in cls.__bases__:
                if b is BaseModel:
                    break
                if issubclass(b, BaseModel):
                    base_cls = b
                    break

            base_api = None
            if base_cls:
                base_api = base_cls.api

            api = api_cls(api=base_api)
            cls.api = api

            # Configure structure for our model type with the user supplied options + type-hints.
            structure = api.structure
            try:
                structure.configure_for_model_type(
                    model_type=cls,
                    type_hints=all_type_hints,
                    **kwargs
                )
            except TypeError as e:
                from xmodel import XModelError
                # Adding some more information to the exception.
                raise XModelError(
                    f&#34;Unable to configure model structure for ({cls}) due to error ({e}) &#34;
                    f&#34;while calling ({structure}.configure_for_model_type).&#34;
                )
            return api

        # The LazyClassAttr will turn into the proper type automatically when it&#39;s first accessed.
        lazy_api = LazyClassAttr(lazy_setup_api, name=&#34;api&#34;)

        # Avoids IDE from using this as type-hint for `self.api`, we want it to use the type-hint
        # defined on attribute.
        # Otherwise it will try to be too cleaver by trying to use the type in `lazy_api` instead.
        # The object in `lazy_api` will transform into what has been type-hinted
        # when it&#39;s first accessed by something.
        setattr(cls, &#34;api&#34;, lazy_api)

    # -------------------------------
    # --------- Init Method ---------

    # todo: Python 3.8 has support for positional-arguments only, do that when we start using it.
    # See Doc-Comment for what *args is.
    def __init__(self, *args, **initial_values):
        &#34;&#34;&#34;
        Creates a new model object. The first/second params need to be passed as positional
        arguments. The rest must be sent as key-word arguments. Everything is optional.

        Args:
            id: Specify the `BaseModel.id` attribute, if you know it. If left as Default, nothing
                will be set on it. It could be set to something via args[0] (ie: a JSON dict).
                If you do provide a value, it be set last after everything else has been set.

            *args: I don&#39;t want to take names from what you could put into &#39;initial_values&#39;,
                so I keep it as position-only *args. Once Python 3.8 comes out, we can use a
                new feature where you can specify some arguments as positional-only and not
                keyword-able.

                ## FirstArg - If Dict:
                If raw dictionary parsed from JSON string. It just calls
                `self.api.update_from_json(args[0])` for you.

                ## FirstArt - If BaseModel:
                If a `BaseModel`, will copy fields over that have the same name.
                You can use this to duplicate a Model object, if you want to copy it.
                Or can be used to copy fields from one model type into another,
                on fields that are the same name.

                Will ignore fields that are present on one but not the other.
                Only copy fields that are on both models types.

            **initial_values: Let&#39;s you specify other attribute values for convenience.
                They will be set into the object the same way you would normally doing it:
                ie: `model_obj.some_attr = v` is the same as `ModelClass(some_attr=v)`.
        &#34;&#34;&#34;
        args_len = len(args)
        if args_len &gt; 1:
            raise NotImplementedError(
                &#34;Passing XContext via second positional argument is no longer supported.&#34;
            )

        cls_api_type = type(type(self).api)
        api = cls_api_type(model=self)
        setattr(self, &#34;api&#34;, api)  # Avoids IDE from using this as type-hint for `self.api`.

        first_arg = args[0] if args_len &gt; 0 else None

        if isinstance(first_arg, BaseModel):
            api.copy_from_model(first_arg)
        elif isinstance(first_arg, Mapping):
            api.update_from_json(first_arg)
        elif first_arg is not None:
            raise XModelError(
                f&#34;When a first argument to BaseModel.__init__ is provided, it needs to be a &#34;
                f&#34;mapping/dict with the json values in it OR a BaseModel instance to copy from; &#34;
                f&#34;I was given a type ({type(first_arg)}) with value ({first_arg}) instead.&#34;
            )

        for k, v in initial_values.items():
            if not self.api.structure.get_field(k):
                raise XModelError(
                    f&#34;While constructing {self}, init method got a value for an &#34;
                    f&#34;unknown field ({k}).&#34;
                )

            setattr(self, k, v)

    def __repr__(self):
        msgs = []
        for attr in self.api.list_of_attrs_to_repr():
            msgs.append(f&#39;{attr}={getattr(self, attr, None)}&#39;)

        full_message = &#34;, &#34;.join(msgs)
        return f&#34;{self.__class__.__name__}({full_message})&#34;

    def __setattr__(self, name, value):
        # This gets called for every attribute set.

        # DO NOT use hasattr() in here, because you could make every lazily loaded object load up
        # [ie: an API request to grab lazily loaded object properties] when the lazy object is set.

        api = self.api
        structure = api.structure
        field = structure.get_field(name)
        type_hint = None

        if inspect.isclass(self):
            # If we are a class, just pass it along
            pass
        elif name == &#34;api&#34;:
            # Don&#39;t do anything special with the &#39;api&#39; var.
            pass
        elif name.startswith(&#34;_&#34;):
            # don&#39;t do anything with private vars
            pass
        elif name.endswith(&#34;_id&#34;) and structure.is_field_a_child(name[:-3], and_has_id=True):
            # We have a virtual field for a related field id, redirect to special setter.
            state = _private.api.get_api_state(api)
            state.set_related_field_id(name[:-3], value)
            return

        if not field:
            # We don&#39;t do anything more without a field object
            # (ie: just a normal python attribute of some sort, not tied with API).
            super().__setattr__(name, value)
            return

        try:
            # We have a value going to an attributed that has a type-hint, checking the type...
            # We will also support auto-converting to correct type if needed and possible,
            # otherwise an error will be thrown if we can&#39;t verify type or auto-convert it.
            type_hint = field.type_hint
            value_type = type(value)
            field_obj: Field = structure.get_field(name)

            # todo: idea: We could cache some of these details [perhaps even using closures]
            #       or use dict/set&#39;s someday for a speed improvement, if we ever need to.

            hint_union_sub_types = ()
            if typing_inspect.is_union_type(type_hint):
                # Gets all args in a union type, to see if one of them will match type_hint.
                hint_union_sub_types = typing_inspect.get_args(type_hint)
                # Get first type hint in untion, Field object (where we just got type-hint)
                # already unwraps the type hint, removing any Null/None types. It&#39;s a Union
                # only if there are other non-Null/None types in a union. For right now
                # lets only worry about the first one.
                type_hint = hint_union_sub_types[0]

            state = _private.api.get_api_state(api)
            if (
                # Check for nullability first, as an optimization.
                field.nullable and
                type_hint not in [str, None] and
                value_type is str and
                not value
            ):
                value = Null
            elif value is None:
                # By default, this is None [unless user specified something].
                value = _get_default_value_from_field(self, field)
            elif (
                value_type is type_hint
                or value_type in hint_union_sub_types
                or Optional[value_type] is type_hint
                or type_hint is NullType and field.nullable
            ):
                # Type is the same as type hint, no need to do anything else.
                # We check to reset any related field id info, just in case it exists,
                # since this field is either being set to Null or an actual object.
                state.reset_related_field_id_if_exists(name)
                pass
            elif value is Null:
                # If type_hint supported the Null type, then it would have been dealt with in
                # the previous if statement.
                XModelError(
                    f&#34;Setting a Null value for field ({name}) when typehint ({type_hint}) &#34;
                    f&#34;does not support NullType, for object ({self}).&#34;
                )
            elif field_obj.converter:
                # todo: Someday map str/int/bool (basic conversions) to standard converter methods;
                #   kind of like I we do it for date/time... have some default converter methods.
                #
                # This handles datetime, date, etc...
                value = field_obj.converter(api, Converter.Direction.to_model, field_obj, value)
            elif type_hint in (dict, JsonDict) and value_type in (dict, JsonDict):
                # this is fine for now, keep it as-is!
                #
                # For now, we just assume things in the dict are ok.
                # in the future, we will support `Dict[str, int]` or some such and we will
                # check/convert/ensure the types as needed.
                pass
            elif type_hint in (dict, JsonDict) and value_type in (int, bool, str):
                # just passively convert bool/int/str into empty dict if type-hint is a dict.
                log.warning(
                    f&#34;Converted a int/bool/str into an empty dict. Attr name ({name}),&#34;
                    f&#34;value ({value}) type-hint ({type_hint}) object ({self}). If you don&#39;t want&#34;
                    f&#34;to do this, then don&#39;t put a type-hint on the attribute.&#34;
                )
                value = {}
            elif typing_inspect.get_origin(type_hint) in (list, set):
                # See if we have a converter for this type in our default-converters....
                inside_type_hint = typing_inspect.get_args(type_hint)[0]
                basic_type_converter = self.api.default_converters.get(inside_type_hint)
                if basic_type_converter:
                    converted_values = [
                        basic_type_converter(
                            api,
                            Converter.Direction.to_model,
                            field_obj,
                            x
                        ) for x in loop(value)
                    ]

                    container_type = typing_inspect.get_origin(type_hint)
                    value = container_type(converted_values)
                # Else/Otherwise we just leave things as-is for now, no error and no conversion
                pass
            # Python 3.7 does not have GenericMeta anymore, not sure if we need it, we just need
            # to try using this for a bit and see what happens.
            #
            # If needed in Python 3.7, we can see if we can remove this loop-hole with the new
            # typing_inspect.* methods.
            #
            # elif type(type_hint) is GenericMeta:
            #     # This is a complex type (probably a Parameterized generic), not going to try and
            #     # check it out, don&#39;t want to throw and error as well, just pass it though.
            #     #
            #
            #     pass

            else:
                raise AttributeError(
                    f&#34;Setting name ({name}) with value ({value}) with type ({value_type}) on &#34;
                    f&#34;API object ({self}) but type-hint is ({type_hint}), and I don&#39;t know how&#34;
                    f&#34; to auto-convert type ({value_type}) into ({type_hint}).&#34;
                )
        except ValueError:
            # We want to raise a more informative error than the base ValueError when there
            # is a problem parsing a value
            raise AttributeError(
                f&#34;Parsing value ({value}) with type-hint ({type_hint}) resulted in an error &#34;
                f&#34;for attribute ({name}) on object ({self})&#34;
            )

        if isinstance(value, str):
            # This value has caused me a lot of problems, it&#39;s time to ALWAYS treat them
            # as blank strings, exactly what they should have been set to in the first place.
            if value.startswith(&#39;#########&#39;):
                value = &#39;&#39;

        if field_obj.post_filter:
            value = field_obj.post_filter(api=api, name=name, value=value)

        if field.fset:
            field.fset(self, value)
        elif field.fget:
            raise XModelError(
                f&#34;We have a field ({field}) that does not have a Field.fset (setter function),&#34;
                f&#34;but has a Field.fget ({field.fget}) and someone is attempting to set a &#34;
                f&#34;value on the Model object ({self})... this is unsupported. &#34;
                f&#34;If you want to allow setting the value, you must provider a setter when a &#34;
                f&#34;getter is present/provided.&#34;
            )
        else:
            super().__setattr__(name, value)

    def __getattr__(self, name: str):
        # Reminder: This method only gets called if attribute is not currently defined in self.
        structure = self.api.structure
        state = _private.api.get_api_state(self.api)

        field = structure.get_field(name)

        if name.startswith(&#34;_&#34;):
            return object.__getattribute__(self, name)

        if field and field.fget:
            # Use getter to get value, if we get a non-None value return it.
            # If we get a None back, then do the default thing we normally do
            # (ie: look for default value, related object, etc).
            value = field.fget(self)
            if value is not None:
                return value

        if name.endswith(&#34;_id&#34;) and structure.is_field_a_child(name[:-3], and_has_id=True):
            # We have a field that ends with _id, that when taken off is a child field that
            # uses and id. This means we should treat this field as virtually related field id.
            value = state.get_related_field_id(name[:-3])
            if value is not None:
                if field and field.fset:
                    field.fset(self, value)
                return value

        if not field:
            raise AttributeError(
                f&#34;Getting ({name}) on ({self.__class__.__name__}), which does not exist on object &#34;
                f&#34;or in API. For API objects, you need to use already defined fields/attributes.&#34;
            )

        if (
            field.related_type is not None and
            field.related_type.api.structure.has_id_field()
        ):
            name_id_value = state.get_related_field_id(name)

            # RemoteModel is an abstract interface,
            # Let&#39;s us know how to lazily lookup remote objects by their id value.
            name_type: &#34;RemoteModel&#34; = field.related_type
            obj = None

            if name_id_value is Null:
                # Don&#39;t attempt to lookup object, we have it&#39;s primary id:
                obj = Null
            elif name_id_value is not None:
                # Attempt to lookup remote object, we have it&#39;s primary id:
                obj = name_type.api.get_via_id(name_id_value)
                # todo: consider raising an exception if we have an `id` but no related object?
                #   I&#39;ll think about it.

                # if we have an object, set it and return it
                if obj is not None:
                    if field.fset:
                        field.fset(self, obj)
                    else:
                        super().__setattr__(name, obj)
                    return obj
                # Otherwise, we continue, next thing to do is look for any default value.

        # We next look for a default value, if any set/return that.
        default = _get_default_value_from_field(self, field)

        # We set to default value and return it if we have a non-None value.
        if default is not None:
            # We have a value of some sort, call setter:
            if field.fset:
                field.fset(self, default)
            else:
                super().__setattr__(name, default)
            return default

        # We found no default value, return None.
        return None

    def __eq__(self, other):
        &#34;&#34;&#34; For BaseModel, by default our identity is based on object instance ID, not any values
            in our attributes.  Makes things simpler when trying to find object/self in a Set;
            which is useful when traversing relationships.
        &#34;&#34;&#34;
        return self is other

    def __hash__(self):
        &#34;&#34;&#34; For BaseModel, by default our identity is based on object instance ID, not any values
            in our attributes.  Makes things simpler when trying to find object/self in a Set;
            which is useful when traversing relationships.
        &#34;&#34;&#34;
        return id(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.json.JsonModel" href="../json.html#xmodel.json.JsonModel">JsonModel</a></li>
<li><a title="xmodel.remote.model.RemoteModel" href="../remote/model.html#xmodel.remote.model.RemoteModel">RemoteModel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.base.BaseModel.api"><code class="name">var <span class="ident">api</span> : <a title="xmodel.base.api.BaseApi" href="api.html#xmodel.base.api.BaseApi">BaseApi</a>[~M]</code></dt>
<dd>
<div class="desc"><p>Used to access the api class, which is used to retrieve/send objects to/from api.</p>
<p>You can specify this as a type-hint in subclasses to change the class we use for this
automatically, like so::
from xmodel import BaseModel, BaseApi
from typing import TypeVar</p>
<pre><code>M = TypeVar("M")

class MyCoolApi(BaseApi[M]):
    pass

class MyCoolModel(BaseModel["MyCoolModel"]):
    api: MyCoolApi[M]  # If this model will have subclasses, you want to use a type-var
</code></pre>
<p>The generic <code>T</code> type-var in this case refers to whatever model class that your using.
In the example just above, <code>T</code> would be referring to <code>MyCoolModel</code> if you did this
somewhere to get the BaseModel's api: <code>MyCoolModel.api</code>.</p></div>
</dd>
</dl>
</dd>
<dt id="xmodel.base.BaseStructure"><code class="flex name class">
<span>class <span class="ident">BaseStructure</span></span>
<span>(</span><span>*, parent: Optional[ForwardRef('<a title="xmodel.base.BaseStructure" href="#xmodel.base.BaseStructure">BaseStructure</a>')], field_type: Type[~F])</span>
</code></dt>
<dd>
<div class="desc"><p>BaseStructure class is meant to keep track of things that apply for all
<code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>'s at the class-level.</p>
<p>You can use <code><a title="xmodel.base.BaseStructure.fields" href="#xmodel.base.BaseStructure.fields">BaseStructure.fields</a></code> to get all fields for a particular
<code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
as an example of the sort of information on the <code><a title="xmodel.base.BaseStructure" href="#xmodel.base.BaseStructure">BaseStructure</a></code> object.</p>
<p>BaseStructure is lazily configured for a particular BaseModel the first time something
attempts to get <code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> off the particular BaseModel subclass.</p>
<p>You can get it via first getting api attribute for BaseModel via
<code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> and then getting the structure attribute on that via
<code><a title="xmodel.base.api.BaseApi.structure" href="api.html#xmodel.base.api.BaseApi.structure">BaseApi.structure</a></code>.</p>
<p>Example getting the structure object for the Account model/api:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from some_lib.account import Account
&gt;&gt;&gt; structure = Account.api.structure
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseStructure(Generic[F]):

    &#34;&#34;&#34;
    BaseStructure class is meant to keep track of things that apply for all
    `xmodel.base.model.BaseModel`&#39;s at the class-level.

    You can use `BaseStructure.fields` to get all fields for a particular
    `xmodel.base.model.BaseModel`
    as an example of the sort of information on the `BaseStructure` object.

    BaseStructure is lazily configured for a particular BaseModel the first time something
    attempts to get `xmodel.base.model.BaseModel.api` off the particular BaseModel subclass.

    You can get it via first getting api attribute for BaseModel via
    `xmodel.base.model.BaseModel.api` and then getting the structure attribute on that via
    `xmodel.base.api.BaseApi.structure`.

    Example getting the structure object for the Account model/api:

    &gt;&gt;&gt; from some_lib.account import Account
    &gt;&gt;&gt; structure = Account.api.structure
    &#34;&#34;&#34;

    def __init__(
            self,
            *,
            parent: Optional[&#39;BaseStructure&#39;],
            field_type: Type[F]
    ):
        super().__init__()

        # Set specific ones so I have my own &#39;instance&#39; of them.
        self._name_to_type_hint_map = {}
        self._get_fields_cache = None

        # Copy all my attributes over from parent, for use as &#39;default&#39; values.
        if parent:
            self.__dict__.update(parent.__dict__)
            # noinspection PyProtectedMember
            # This parent is my own type/class, so I am fine accessing it&#39;s private member.
            self._name_to_type_hint_map = parent._name_to_type_hint_map.copy()

        self._get_fields_cache = None
        self.field_type = field_type
        self.internal_shared_api_values = {}

    def configure_for_model_type(
            self,
            *,  # &lt;-- means we don&#39;t support positional arguments
            model_type: Type[&#39;BaseModel&#39;],
            type_hints: Dict[str, Any],
    ):
        &#34;&#34;&#34;
        This EXPECTS to have passed-in the type-hints for my `BaseStructure.;
        see code inside `xmodel.base.model.BaseModel.__init_subclass__` for more details.
        There is no need to get the type-hints twice [it can be a bit expensive, trying to
        limit how may times I grab them]....

        See `xmodel.base.model.BaseModel` for more details on how Models work...
        This describes the options you
        can pass into a `xmodel.base.model.BaseModel` subclass at class-construction time.
        It allows you to customize how the Model class will work.

        This method will remember the options passed to it, but won&#39;t finish constructing the class
        until someone asks for it&#39;s `xmodel.base.model.BaseModel.api` attribute for the first
        time. This allows you
        to dynamically add more Field classes if needed. It also makes things import faster as
        we won&#39;t have to fully setup the class unless something tries to use it.

        Args:
            model_type (Type[xmodel.base.model.BaseModel]): The model we are associated with,
                this is what we are configuring ourselves against.
            type_hints (Dict[str, Any]): List of typehints via Python&#39;s `get_type_hints` method;
                Be aware that `get_type_hints` will try and resolve all type-hints, including
                ones that are forward references. Make sure these types are available at
                the module-level by the time `get_type_hints` runs.
        &#34;&#34;&#34;
        # Prep model class, remove any class Field objects...
        # These objects have been &#34;moved&#34; into me via `self.fields`.
        self._name_to_type_hint_map = type_hints
        self.model_cls = model_type
        for field_obj in self.fields:
            field_name = field_obj.name

            # The default values are inside `field_obj.default` now.
            # We delete the class-vars, so that `__getattr__` is called when someone attempts
            # to grab a value from a BaseModel for an attribute that does not directly exist
            # on the BaseModel subclass so we can do our normal field_obj.default resolution.
            # If the class keeps the value, it prevents `__getattr__` from being called for
            # attributes that don&#39;t exist directly on the model instance/object;
            # Python will instead grab and return the value set on the class for that attribute.
            #
            # todo/thoughts/brain-storm:
            #    Consider just using __getattribute__ for BaseModel instead of __getattr_...
            #    It&#39;s slightly slower but then I could have more flexablity around this...
            #    Thinking of returning the associated field-object if you do
            #    `BaseModelSubClass.some_attr_field` for various purposes....
            #    Using `__getattribute__` would allow for this....
            #    just something I have been thinking about...
            #    For example: you could use that field object as a query-key instead of a string
            #    with the field-name...
            #    might be nicer, and get auto-completion that way... not sure, thinking about it.
            #
            if field_name in self.model_cls.__dict__:
                delattr(self.model_cls, field_name)

    # --------------------------------------
    # --------- Environmental Properties ---------

    model_cls: &#34;Type[BaseModel]&#34;
    &#34;&#34;&#34;
    The model&#39;s class we are defining the structure for.
    This is typed as some sort of `xmodel.base.model.BaseModel`
    .
    This is NOT generically typed anymore, to get much better generically typed
    version you should use `xmodel.base.api.BaseApi.model_type` to get the BaseModel outside
    of the `xmodel.structure` module.
    Using that will give the IDE the correctly typed BaseModel class!
     &#34;&#34;&#34;

    # --------------------------------------
    # --------- General Properties ---------
    #
    # Most of these will be set inside __init_subclass__() via associated BaseModel Class.

    field_type: Type[F]
    &#34;&#34;&#34;
    Field type that this structure will use when auto-generating `xmodel.fields.Field`&#39;s.
    User defined Fields on a model-class will keep whatever type the user used.
    When `xmodel.base.model.BaseModel` class is constructed, and the `BaseStructure` is
    created, we will check to ensure all user-defined fields inherit from this field_type.

    That way you can assume any fields you get off this structure object inherit from
    field_type.
    &#34;&#34;&#34;

    internal_shared_api_values: Dict[Any, Any] = None
    &#34;&#34;&#34;
    A place an `xmodel.base.api.BaseApi` object can use to share values BaseModel-class wide
    (ie: for all BaseModel&#39;s of a specific type).

    This should NOT be used outside of the BaseApi class.
    For example, ``xmodel.base.api.BaseApi.client` stores it&#39;s object lazily here.
    Users outside of BaseApi class should simply ask it for the client and not try
    to go behind it&#39;s back and get it here.

    Code/Users outside of `xmodel.base.api.BaseApi` and it&#39;s subclasses can&#39;t assume
    anything about what&#39;s in this dictionary.  This exists for pure-convenience of the
    `xmodel.base.api.BaseApi` class.
    &#34;&#34;&#34;

    _name_to_type_hint_map: Dict[str, Any]
    &#34;&#34;&#34;
        .. deprecated:: v0.2.33 Use `BaseStructure.fields` instead to get a list of
            the real fields to use. And `xmodel.fields.Field.type_hint` to get the type-hint
            [don&#39;t get it here, keeping this temporary for backwards compatibility].

        A map of  attribute-name to type-hint type.

        .. important:: This WILL NOT take into account field-names where the `Field.name` is
            different then the name of the field on BaseModel the type-hint was assigned to.
    &#34;&#34;&#34;

    _get_fields_cache: Dict[str, F] = None

    @property
    def have_api_endpoint(self) -&gt; bool:
        &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
            That&#39;s determined right now via seeing if `BaseStructure.has_id_field_set()` is True.
        &#34;&#34;&#34;
        if not self.has_id_field():
            return False
        else:
            return True

    def __copy__(self):
        obj = type(self)(parent=self, field_type=self.field_type)
        obj.__dict__.update(self.__dict__)
        obj._name_to_type_hint_map = self._name_to_type_hint_map.copy()
        obj._get_fields_cache = None
        return obj

    def field_exists(self, name: str) -&gt; bool:
        &#34;&#34;&#34; Return `True` if the field with `name` exists on the model, otherwise `False`. &#34;&#34;&#34;
        return name in self.field_map

    def has_id_field(self):
        &#34;&#34;&#34; Defaults to False, returns True for RemoteStructure,
            What this property is really saying is if you can do a foreign-key to the related
            object/model.

            It may be better at some point in the long-run to rename this field to more indicate
            that; perhaps the next time we have a breaking-change we need to do for xmodel.

            For now, we are leaving the name along and hard-coding this to
            return False in BaseStructure, and to return True in RemoteStructure.
        &#34;&#34;&#34;
        return False

    def get_field(self, name: str) -&gt; Optional[F]:
        &#34;&#34;&#34;
        Args:
            name (str): Field name to query on.
        Returns:
            xmodel.fields.Field: If field object exists with `name`.

            None: If not field with `name` exists
        &#34;&#34;&#34;
        if name is None:
            return None
        return self.field_map.get(name)

    @property
    def fields(self) -&gt; List[F]:
        &#34;&#34;&#34; Returns:
                List[xmodel.fields.Field]: list of field objects.
        &#34;&#34;&#34;
        return list(self.field_map.values())

    @property
    def field_map(self) -&gt; Mapping[str, F]:
        &#34;&#34;&#34;

        Returns:
           Dict[str, xmodel.fields.Field]: Map of `xmodel.fields.Field.name` to
                `xmodel.fields.Field` objects.
        &#34;&#34;&#34;
        cached_content = self._get_fields_cache
        if cached_content is not None:
            # Mapping proxy is a read-only view of the passed in dict.
            # This will LIVE update the mapping if underlying dict changed.
            return MappingProxyType(cached_content)

        generated_fields = self._generate_fields()
        self._get_fields_cache = generated_fields
        return MappingProxyType(generated_fields)

    def excluded_field_map(self) -&gt; Dict[str, F]:
        &#34;&#34;&#34;
        Returns:
            Dict[str, xmodel.fields.Field]: Mapping of `xmodel.fields.Field.name` to
                field objects that are excluded (`xmodel.fields.Field.exclude` == `True`).
        &#34;&#34;&#34;
        return {f.name: f for f in self.fields if f.exclude}

    def _generate_fields(self) -&gt; Dict[str, F]:
        &#34;&#34;&#34; Goes though object and grabs/generated Field objects and caches them in self.
            Gives back the definitive list of Field objects.

            For now keeping this private, but may open it up in the future if sub-classes
            need to customize how fields are generated.
        &#34;&#34;&#34;
        full_field_map = {}

        default_field_type: Type[Field] = self.field_type
        type_hint_map = self._name_to_type_hint_map
        model_cls = self.model_cls

        # todo: Figure out how to put this into/consolidate into
        #  `xmodel.base.api.BaseApi`; and simplify stuff!!!
        default_converters = getattr(self.model_cls.api, &#39;default_converters&#39;)

        # todo:  default_con ^^^^ make sure we are using it!!!!

        # Lazy-import BaseModel, we need to check to see if we have a sub-class or not...
        from xmodel import BaseModel

        # This will be a collection of any Fields that exist on the parent(s), merged together...
        base_fields: Dict[str, Field] = {}

        # go though parent and find any Field objects, grab latest version
        # which is the one closest to child on a per-field basis...
        # we exclude it&#39;s self [the model we are currently working with].
        for base in reversed(model_cls.__mro__[1:]):
            base: Type[BaseModel]
            if not inspect.isclass(base):
                continue
            if not issubclass(base, BaseModel):
                continue
            if not base.api:
                # `base` is likely xmodel.base.model.BaseModel; and that has no API allocated
                # to it
                # at the moment [mostly because the __init_subclasses is only executed on sub&#39;s].
                # todo: BaseModel is an abstract class... do we really need structure/fields on it?
                continue
            # todo:  ensure we later on use these and make a new field if needed...
            base_fields.update(base.api.structure.field_map)

        for name, type_hint in type_hint_map.items():
            # Ignore the &#39;api&#39; attribute, it&#39;s special.
            if name == &#39;api&#39;:
                continue

            # Ignore anything the starts with &#39;_&#39;.
            if name.startswith(&#34;_&#34;):
                continue

            # todo:
            #   1. Get Parent Field&#39;s, merge values.
            #   2. Map all type&#39;s and if not map then raise error.

            # noinspection PyArgumentList
            field_obj: Field
            field_value: Field = getattr(model_cls, name, Default)
            if isinstance(field_value, Field):
                field_obj = field_value
                field_value = Default
            elif field_value is not Default:
                if not inspect.isclass(field_value) and isinstance(field_value, property):
                    field_obj = default_field_type(fget=field_value.fget, fset=field_value.fset)
                else:
                    # noinspection PyArgumentList
                    field_obj = default_field_type(default=field_value)
            else:
                # noinspection PyArgumentList
                field_obj = default_field_type()

            # Name can be overridden, we want to use it to lookup parent field name....
            if field_obj.name:
                name = field_obj.name

            field_obj.resolve_defaults(
                name=name,
                type_hint=type_hint_map.get(name, None),
                default_converter_map=default_converters,
                parent_field=base_fields.get(name)
            )

            # Ensure all fields that still have `Default` as their value are resolved to None.
            field_obj.resolve_remaining_defaults_to_none()

            # field-object will unwrap the type-hint for us.
            type_hint = field_obj.type_hint

            # Name can be overridden, we want to use whatever it says we should be using.
            name = field_obj.name
            full_field_map[field_obj.name] = field_obj

            # If we have a converter, we can assume that will take care of things correctly
            # for whatever type we have.  If we don&#39;t have a converter, we only support specific
            # types; We check here for type-compatibility.
            from xmodel import BaseModel
            if (
                not field_obj.converter and
                type_hint not in supported_basic_types and
                (not inspect.isclass(type_hint) or not issubclass(type_hint, BaseModel)) and
                typing_inspect.get_origin(type_hint) not in (list, set)
            ):
                raise XModelError(
                    f&#34;Unsupported type ({type_hint}) with field-name ({name}) &#34;
                    f&#34;for model-class ({model_cls}) in field-obj ({field_obj}).&#34;
                )

            if (
                field_obj.json_path and
                field_obj.json_path != field_obj.name and
                field_obj.related_type
            ):
                XModelError(
                    &#34;Right now obj-relationships can&#39;t use the &#39;json_path&#39; option &#34;
                    &#34;while at the same time being obj-relationships. Must use basic field &#34;
                    &#34;with api_path. &#34;

                    # Copy/Paste from `BaseApi.json`:
                    f&#34;Can&#39;t have xmodel.Field on BaseModel with related-type and a json_path &#34;
                    f&#34;that differ at the moment, for field ({field_obj}). &#34;
                    f&#34;It is something I want to support someday; the support is mostly in place &#34;
                    f&#34;already, but it needs some more careful thought, attention and testing &#34;
                    f&#34;before we should allow it. &#34;
                    &#34;Workaround:  Make an `{field.name}_id` field next to related field on the &#34;
                    &#34;model. Then, set `json_path` for that `{field.name}_id` field, set it to &#34;
                    &#34;what you want it to be. Finally, set the `{related_field.name}` to &#34;
                    &#34;read_only=True. This allows you to rename the `_id` field used to/from api &#34;
                    &#34;in the JSON input/output, but the Model can have an alternate name for the &#34;
                    &#34;related field. You can see a real-example of this at &#34;
                    &#34;`bigcommerce.api.orders._BcCommonOrderMetafield.order&#34;
                )

        # todo: Provide a &#39;remove&#39; option in the Field config class.
        if &#39;id&#39; not in full_field_map:

            # Go though and populate the `Field.field_for_foreign_key_related_field` as needed...
            for k, f in full_field_map.items():
                # If there is a relate field name, and we have a field defined for it...
                # Set it&#39;s field_for_foreign_key_related_field so the correct field...
                # Otherwise generate a field object for this key-field.
                #
                # FYI: The `resolve_defaults` call above will always set
                #      field_for_foreign_key_related_field to None.
                #      We then set it to something here if needed.
                if f.related_field_name_for_id:
                    related_field = full_field_map.get(f.related_field_name_for_id)
                    if related_field:
                        related_field.field_for_foreign_key_related_field = f

        return full_field_map

    def id_cache_key(self, _id):
        &#34;&#34;&#34; Returns a proper key to use for `xmodel.base.client.BaseClient.cache_get`
            and other caching methods for id-based lookup of an object.
        &#34;&#34;&#34;
        if type(_id) is dict:
            # todo: Put module name in this key.
            key = f&#34;{self.model_cls.__name__}&#34;
            try:
                sorted_keys = sorted(_id.keys())
            except TypeError:
                sorted_keys = _id.keys()
            for key_name in sorted_keys:
                key += f&#34;-{key_name}-{_id[key_name]}&#34;
            return key
        else:
            return f&#34;{self.model_cls.__name__}-id-{_id}&#34;

    # todo: Get rid of this [only used by Dynamo right now]. Need to use Field instead...
    def get_unwraped_typehint(self, field_name: str):
        &#34;&#34;&#34;
        This is now done for you on `xmodel.fields.Field.type_hint`, so you can just grab it
        directly your self now.

        Gets typehint for field_name and calls `xmodel.types.unwrap_optional_type`
        on it to try and get the plain type-hint as best as we can.
        &#34;&#34;&#34;
        field = self.get_field(field_name)
        if field is None:
            return None

        return field.type_hint

    def is_field_a_child(self, child_field_name, *, and_has_id=False):
        &#34;&#34;&#34;
        True if the field is a child, otherwise False.  Will still return `False` if
        `and_has_id` argument is `True` and the related type is configured to not use id via class
        argument `has_id_field=False` (see `BaseStructure.configure_for_model_type` for more
        details on class arguments).

        Won&#39;t raise an exception if field does not exist.

        Args:
            child_field_name (str): Name of field to check.
            and_has_id (bool): If True, then return False if related type is not configured to
                use id.
        Returns:
            bool: `True` if this field is a child field, otherwise `False`.
        &#34;&#34;&#34;
        field = self.get_field(child_field_name)
        if not field:
            return False

        related_type = field.related_type
        if not related_type:
            return False

        related_structure = related_type.api.structure
        if and_has_id and not related_structure.has_id_field():
            return False

        return True

    @property
    def endpoint_description(self):
        &#34;&#34;&#34; Gives some sort of basic descriptive string that contains the path/table-name/etc
            that basically indicates the api endpoint being used.

            This is meant for logging and other human readability/debugging purposes.
            Feel free to change the string to whatever is most useful to know.

            I expect this to be overridden by the concrete implementation, see examples here:

            - `xmodel.rest.RestStructure.endpoint_description`
            - `xmodel.dynamo.DynStructure.endpoint_description`
        &#34;&#34;&#34;
        return &#34;?&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xmodel.remote.structure.RemoteStructure" href="../remote/structure.html#xmodel.remote.structure.RemoteStructure">RemoteStructure</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xmodel.base.BaseStructure.field_type"><code class="name">var <span class="ident">field_type</span> : Type[~F]</code></dt>
<dd>
<div class="desc"><p>Field type that this structure will use when auto-generating <code>xmodel.fields.Field</code>'s.
User defined Fields on a model-class will keep whatever type the user used.
When <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> class is constructed, and the <code><a title="xmodel.base.BaseStructure" href="#xmodel.base.BaseStructure">BaseStructure</a></code> is
created, we will check to ensure all user-defined fields inherit from this field_type.</p>
<p>That way you can assume any fields you get off this structure object inherit from
field_type.</p></div>
</dd>
<dt id="xmodel.base.BaseStructure.internal_shared_api_values"><code class="name">var <span class="ident">internal_shared_api_values</span> : Dict[Any, Any]</code></dt>
<dd>
<div class="desc"><p>A place an <code><a title="xmodel.base.api.BaseApi" href="api.html#xmodel.base.api.BaseApi">BaseApi</a></code> object can use to share values BaseModel-class wide
(ie: for all BaseModel's of a specific type).</p>
<p>This should NOT be used outside of the BaseApi class.
For example, <code>`xmodel.base.api.BaseApi.client</code> stores it's object lazily here.
Users outside of BaseApi class should simply ask it for the client and not try
to go behind it's back and get it here.</p>
<p>Code/Users outside of <code><a title="xmodel.base.api.BaseApi" href="api.html#xmodel.base.api.BaseApi">BaseApi</a></code> and it's subclasses can't assume
anything about what's in this dictionary.
This exists for pure-convenience of the
<code><a title="xmodel.base.api.BaseApi" href="api.html#xmodel.base.api.BaseApi">BaseApi</a></code> class.</p></div>
</dd>
<dt id="xmodel.base.BaseStructure.model_cls"><code class="name">var <span class="ident">model_cls</span> : Type[<a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a>]</code></dt>
<dd>
<div class="desc"><p>The model's class we are defining the structure for.
This is typed as some sort of <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code>
.
This is NOT generically typed anymore, to get much better generically typed
version you should use <code><a title="xmodel.base.api.BaseApi.model_type" href="api.html#xmodel.base.api.BaseApi.model_type">BaseApi.model_type</a></code> to get the BaseModel outside
of the <code>xmodel.structure</code> module.
Using that will give the IDE the correctly typed BaseModel class!</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xmodel.base.BaseStructure.endpoint_description"><code class="name">var <span class="ident">endpoint_description</span></code></dt>
<dd>
<div class="desc"><p>Gives some sort of basic descriptive string that contains the path/table-name/etc
that basically indicates the api endpoint being used.</p>
<p>This is meant for logging and other human readability/debugging purposes.
Feel free to change the string to whatever is most useful to know.</p>
<p>I expect this to be overridden by the concrete implementation, see examples here:</p>
<ul>
<li><code>xmodel.rest.RestStructure.endpoint_description</code></li>
<li><code>xmodel.dynamo.DynStructure.endpoint_description</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endpoint_description(self):
    &#34;&#34;&#34; Gives some sort of basic descriptive string that contains the path/table-name/etc
        that basically indicates the api endpoint being used.

        This is meant for logging and other human readability/debugging purposes.
        Feel free to change the string to whatever is most useful to know.

        I expect this to be overridden by the concrete implementation, see examples here:

        - `xmodel.rest.RestStructure.endpoint_description`
        - `xmodel.dynamo.DynStructure.endpoint_description`
    &#34;&#34;&#34;
    return &#34;?&#34;</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.field_map"><code class="name">var <span class="ident">field_map</span> : Mapping[str, ~F]</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Map of <code>xmodel.fields.Field.name</code> to
<code>xmodel.fields.Field</code> objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def field_map(self) -&gt; Mapping[str, F]:
    &#34;&#34;&#34;

    Returns:
       Dict[str, xmodel.fields.Field]: Map of `xmodel.fields.Field.name` to
            `xmodel.fields.Field` objects.
    &#34;&#34;&#34;
    cached_content = self._get_fields_cache
    if cached_content is not None:
        # Mapping proxy is a read-only view of the passed in dict.
        # This will LIVE update the mapping if underlying dict changed.
        return MappingProxyType(cached_content)

    generated_fields = self._generate_fields()
    self._get_fields_cache = generated_fields
    return MappingProxyType(generated_fields)</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.fields"><code class="name">var <span class="ident">fields</span> : List[~F]</code></dt>
<dd>
<div class="desc"><p>Returns:
List[xmodel.fields.Field]: list of field objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fields(self) -&gt; List[F]:
    &#34;&#34;&#34; Returns:
            List[xmodel.fields.Field]: list of field objects.
    &#34;&#34;&#34;
    return list(self.field_map.values())</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.have_api_endpoint"><code class="name">var <span class="ident">have_api_endpoint</span> : bool</code></dt>
<dd>
<div class="desc"><p>Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
That's determined right now via seeing if <code>BaseStructure.has_id_field_set()</code> is True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def have_api_endpoint(self) -&gt; bool:
    &#34;&#34;&#34; Right now, a ready-only property that tells you if this BaseModel has an API endpoint.
        That&#39;s determined right now via seeing if `BaseStructure.has_id_field_set()` is True.
    &#34;&#34;&#34;
    if not self.has_id_field():
        return False
    else:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xmodel.base.BaseStructure.configure_for_model_type"><code class="name flex">
<span>def <span class="ident">configure_for_model_type</span></span>(<span>self, *, model_type: Type[ForwardRef('<a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a>')], type_hints: Dict[str, Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This EXPECTS to have passed-in the type-hints for my `BaseStructure.;
see code inside <code><a title="xmodel.base.model.BaseModel.__init_subclass__" href="model.html#xmodel.base.model.BaseModel.__init_subclass__">BaseModel.__init_subclass__()</a></code> for more details.
There is no need to get the type-hints twice [it can be a bit expensive, trying to
limit how may times I grab them]....</p>
<p>See <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> for more details on how Models work&hellip;
This describes the options you
can pass into a <code><a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a></code> subclass at class-construction time.
It allows you to customize how the Model class will work.</p>
<p>This method will remember the options passed to it, but won't finish constructing the class
until someone asks for it's <code><a title="xmodel.base.model.BaseModel.api" href="model.html#xmodel.base.model.BaseModel.api">BaseModel.api</a></code> attribute for the first
time. This allows you
to dynamically add more Field classes if needed. It also makes things import faster as
we won't have to fully setup the class unless something tries to use it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model_type</code></strong> :&ensp;<code>Type[<a title="xmodel.base.model.BaseModel" href="model.html#xmodel.base.model.BaseModel">BaseModel</a>]</code></dt>
<dd>The model we are associated with,
this is what we are configuring ourselves against.</dd>
<dt><strong><code>type_hints</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>List of typehints via Python's <code>get_type_hints</code> method;
Be aware that <code>get_type_hints</code> will try and resolve all type-hints, including
ones that are forward references. Make sure these types are available at
the module-level by the time <code>get_type_hints</code> runs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_for_model_type(
        self,
        *,  # &lt;-- means we don&#39;t support positional arguments
        model_type: Type[&#39;BaseModel&#39;],
        type_hints: Dict[str, Any],
):
    &#34;&#34;&#34;
    This EXPECTS to have passed-in the type-hints for my `BaseStructure.;
    see code inside `xmodel.base.model.BaseModel.__init_subclass__` for more details.
    There is no need to get the type-hints twice [it can be a bit expensive, trying to
    limit how may times I grab them]....

    See `xmodel.base.model.BaseModel` for more details on how Models work...
    This describes the options you
    can pass into a `xmodel.base.model.BaseModel` subclass at class-construction time.
    It allows you to customize how the Model class will work.

    This method will remember the options passed to it, but won&#39;t finish constructing the class
    until someone asks for it&#39;s `xmodel.base.model.BaseModel.api` attribute for the first
    time. This allows you
    to dynamically add more Field classes if needed. It also makes things import faster as
    we won&#39;t have to fully setup the class unless something tries to use it.

    Args:
        model_type (Type[xmodel.base.model.BaseModel]): The model we are associated with,
            this is what we are configuring ourselves against.
        type_hints (Dict[str, Any]): List of typehints via Python&#39;s `get_type_hints` method;
            Be aware that `get_type_hints` will try and resolve all type-hints, including
            ones that are forward references. Make sure these types are available at
            the module-level by the time `get_type_hints` runs.
    &#34;&#34;&#34;
    # Prep model class, remove any class Field objects...
    # These objects have been &#34;moved&#34; into me via `self.fields`.
    self._name_to_type_hint_map = type_hints
    self.model_cls = model_type
    for field_obj in self.fields:
        field_name = field_obj.name

        # The default values are inside `field_obj.default` now.
        # We delete the class-vars, so that `__getattr__` is called when someone attempts
        # to grab a value from a BaseModel for an attribute that does not directly exist
        # on the BaseModel subclass so we can do our normal field_obj.default resolution.
        # If the class keeps the value, it prevents `__getattr__` from being called for
        # attributes that don&#39;t exist directly on the model instance/object;
        # Python will instead grab and return the value set on the class for that attribute.
        #
        # todo/thoughts/brain-storm:
        #    Consider just using __getattribute__ for BaseModel instead of __getattr_...
        #    It&#39;s slightly slower but then I could have more flexablity around this...
        #    Thinking of returning the associated field-object if you do
        #    `BaseModelSubClass.some_attr_field` for various purposes....
        #    Using `__getattribute__` would allow for this....
        #    just something I have been thinking about...
        #    For example: you could use that field object as a query-key instead of a string
        #    with the field-name...
        #    might be nicer, and get auto-completion that way... not sure, thinking about it.
        #
        if field_name in self.model_cls.__dict__:
            delattr(self.model_cls, field_name)</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.excluded_field_map"><code class="name flex">
<span>def <span class="ident">excluded_field_map</span></span>(<span>self) ‑> Dict[str, ~F]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, xmodel.fields.Field]</code></dt>
<dd>Mapping of <code>xmodel.fields.Field.name</code> to
field objects that are excluded (<code>xmodel.fields.Field.exclude</code> == <code>True</code>).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def excluded_field_map(self) -&gt; Dict[str, F]:
    &#34;&#34;&#34;
    Returns:
        Dict[str, xmodel.fields.Field]: Mapping of `xmodel.fields.Field.name` to
            field objects that are excluded (`xmodel.fields.Field.exclude` == `True`).
    &#34;&#34;&#34;
    return {f.name: f for f in self.fields if f.exclude}</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.field_exists"><code class="name flex">
<span>def <span class="ident">field_exists</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return <code>True</code> if the field with <code>name</code> exists on the model, otherwise <code>False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_exists(self, name: str) -&gt; bool:
    &#34;&#34;&#34; Return `True` if the field with `name` exists on the model, otherwise `False`. &#34;&#34;&#34;
    return name in self.field_map</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, name: str) ‑> Optional[~F]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Field name to query on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xmodel.fields.Field</code></dt>
<dd>If field object exists with <code>name</code>.</dd>
<dt><code>None</code></dt>
<dd>If not field with <code>name</code> exists</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field(self, name: str) -&gt; Optional[F]:
    &#34;&#34;&#34;
    Args:
        name (str): Field name to query on.
    Returns:
        xmodel.fields.Field: If field object exists with `name`.

        None: If not field with `name` exists
    &#34;&#34;&#34;
    if name is None:
        return None
    return self.field_map.get(name)</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.get_unwraped_typehint"><code class="name flex">
<span>def <span class="ident">get_unwraped_typehint</span></span>(<span>self, field_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is now done for you on <code>xmodel.fields.Field.type_hint</code>, so you can just grab it
directly your self now.</p>
<p>Gets typehint for field_name and calls <code>xmodel.types.unwrap_optional_type</code>
on it to try and get the plain type-hint as best as we can.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unwraped_typehint(self, field_name: str):
    &#34;&#34;&#34;
    This is now done for you on `xmodel.fields.Field.type_hint`, so you can just grab it
    directly your self now.

    Gets typehint for field_name and calls `xmodel.types.unwrap_optional_type`
    on it to try and get the plain type-hint as best as we can.
    &#34;&#34;&#34;
    field = self.get_field(field_name)
    if field is None:
        return None

    return field.type_hint</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.has_id_field"><code class="name flex">
<span>def <span class="ident">has_id_field</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defaults to False, returns True for RemoteStructure,
What this property is really saying is if you can do a foreign-key to the related
object/model.</p>
<p>It may be better at some point in the long-run to rename this field to more indicate
that; perhaps the next time we have a breaking-change we need to do for xmodel.</p>
<p>For now, we are leaving the name along and hard-coding this to
return False in BaseStructure, and to return True in RemoteStructure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_id_field(self):
    &#34;&#34;&#34; Defaults to False, returns True for RemoteStructure,
        What this property is really saying is if you can do a foreign-key to the related
        object/model.

        It may be better at some point in the long-run to rename this field to more indicate
        that; perhaps the next time we have a breaking-change we need to do for xmodel.

        For now, we are leaving the name along and hard-coding this to
        return False in BaseStructure, and to return True in RemoteStructure.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.id_cache_key"><code class="name flex">
<span>def <span class="ident">id_cache_key</span></span>(<span>self, _id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a proper key to use for <code>xmodel.base.client.BaseClient.cache_get</code>
and other caching methods for id-based lookup of an object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_cache_key(self, _id):
    &#34;&#34;&#34; Returns a proper key to use for `xmodel.base.client.BaseClient.cache_get`
        and other caching methods for id-based lookup of an object.
    &#34;&#34;&#34;
    if type(_id) is dict:
        # todo: Put module name in this key.
        key = f&#34;{self.model_cls.__name__}&#34;
        try:
            sorted_keys = sorted(_id.keys())
        except TypeError:
            sorted_keys = _id.keys()
        for key_name in sorted_keys:
            key += f&#34;-{key_name}-{_id[key_name]}&#34;
        return key
    else:
        return f&#34;{self.model_cls.__name__}-id-{_id}&#34;</code></pre>
</details>
</dd>
<dt id="xmodel.base.BaseStructure.is_field_a_child"><code class="name flex">
<span>def <span class="ident">is_field_a_child</span></span>(<span>self, child_field_name, *, and_has_id=False)</span>
</code></dt>
<dd>
<div class="desc"><p>True if the field is a child, otherwise False.
Will still return <code>False</code> if
<code>and_has_id</code> argument is <code>True</code> and the related type is configured to not use id via class
argument <code>has_id_field=False</code> (see <code><a title="xmodel.base.BaseStructure.configure_for_model_type" href="#xmodel.base.BaseStructure.configure_for_model_type">BaseStructure.configure_for_model_type()</a></code> for more
details on class arguments).</p>
<p>Won't raise an exception if field does not exist.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>child_field_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of field to check.</dd>
<dt><strong><code>and_has_id</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, then return False if related type is not configured to
use id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if this field is a child field, otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_field_a_child(self, child_field_name, *, and_has_id=False):
    &#34;&#34;&#34;
    True if the field is a child, otherwise False.  Will still return `False` if
    `and_has_id` argument is `True` and the related type is configured to not use id via class
    argument `has_id_field=False` (see `BaseStructure.configure_for_model_type` for more
    details on class arguments).

    Won&#39;t raise an exception if field does not exist.

    Args:
        child_field_name (str): Name of field to check.
        and_has_id (bool): If True, then return False if related type is not configured to
            use id.
    Returns:
        bool: `True` if this field is a child field, otherwise `False`.
    &#34;&#34;&#34;
    field = self.get_field(child_field_name)
    if not field:
        return False

    related_type = field.related_type
    if not related_type:
        return False

    related_structure = related_type.api.structure
    if and_has_id and not related_structure.has_id_field():
        return False

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xmodel" href="../index.html">xmodel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="xmodel.base.api" href="api.html">xmodel.base.api</a></code></li>
<li><code><a title="xmodel.base.fields" href="fields.html">xmodel.base.fields</a></code></li>
<li><code><a title="xmodel.base.model" href="model.html">xmodel.base.model</a></code></li>
<li><code><a title="xmodel.base.structure" href="structure.html">xmodel.base.structure</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xmodel.base.BaseApi" href="#xmodel.base.BaseApi">BaseApi</a></code></h4>
<ul class="">
<li><code><a title="xmodel.base.BaseApi.context" href="#xmodel.base.BaseApi.context">context</a></code></li>
<li><code><a title="xmodel.base.BaseApi.copy_from_model" href="#xmodel.base.BaseApi.copy_from_model">copy_from_model</a></code></li>
<li><code><a title="xmodel.base.BaseApi.default_converters" href="#xmodel.base.BaseApi.default_converters">default_converters</a></code></li>
<li><code><a title="xmodel.base.BaseApi.fields_to_pop_for_json" href="#xmodel.base.BaseApi.fields_to_pop_for_json">fields_to_pop_for_json</a></code></li>
<li><code><a title="xmodel.base.BaseApi.forget_original_json_state" href="#xmodel.base.BaseApi.forget_original_json_state">forget_original_json_state</a></code></li>
<li><code><a title="xmodel.base.BaseApi.get_child_without_lazy_lookup" href="#xmodel.base.BaseApi.get_child_without_lazy_lookup">get_child_without_lazy_lookup</a></code></li>
<li><code><a title="xmodel.base.BaseApi.have_changes" href="#xmodel.base.BaseApi.have_changes">have_changes</a></code></li>
<li><code><a title="xmodel.base.BaseApi.json" href="#xmodel.base.BaseApi.json">json</a></code></li>
<li><code><a title="xmodel.base.BaseApi.list_of_attrs_to_repr" href="#xmodel.base.BaseApi.list_of_attrs_to_repr">list_of_attrs_to_repr</a></code></li>
<li><code><a title="xmodel.base.BaseApi.model" href="#xmodel.base.BaseApi.model">model</a></code></li>
<li><code><a title="xmodel.base.BaseApi.model_type" href="#xmodel.base.BaseApi.model_type">model_type</a></code></li>
<li><code><a title="xmodel.base.BaseApi.should_include_field_in_json" href="#xmodel.base.BaseApi.should_include_field_in_json">should_include_field_in_json</a></code></li>
<li><code><a title="xmodel.base.BaseApi.structure" href="#xmodel.base.BaseApi.structure">structure</a></code></li>
<li><code><a title="xmodel.base.BaseApi.update_from_json" href="#xmodel.base.BaseApi.update_from_json">update_from_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.base.BaseModel" href="#xmodel.base.BaseModel">BaseModel</a></code></h4>
<ul class="">
<li><code><a title="xmodel.base.BaseModel.api" href="#xmodel.base.BaseModel.api">api</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xmodel.base.BaseStructure" href="#xmodel.base.BaseStructure">BaseStructure</a></code></h4>
<ul class="">
<li><code><a title="xmodel.base.BaseStructure.configure_for_model_type" href="#xmodel.base.BaseStructure.configure_for_model_type">configure_for_model_type</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.endpoint_description" href="#xmodel.base.BaseStructure.endpoint_description">endpoint_description</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.excluded_field_map" href="#xmodel.base.BaseStructure.excluded_field_map">excluded_field_map</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.field_exists" href="#xmodel.base.BaseStructure.field_exists">field_exists</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.field_map" href="#xmodel.base.BaseStructure.field_map">field_map</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.field_type" href="#xmodel.base.BaseStructure.field_type">field_type</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.fields" href="#xmodel.base.BaseStructure.fields">fields</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.get_field" href="#xmodel.base.BaseStructure.get_field">get_field</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.get_unwraped_typehint" href="#xmodel.base.BaseStructure.get_unwraped_typehint">get_unwraped_typehint</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.has_id_field" href="#xmodel.base.BaseStructure.has_id_field">has_id_field</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.have_api_endpoint" href="#xmodel.base.BaseStructure.have_api_endpoint">have_api_endpoint</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.id_cache_key" href="#xmodel.base.BaseStructure.id_cache_key">id_cache_key</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.internal_shared_api_values" href="#xmodel.base.BaseStructure.internal_shared_api_values">internal_shared_api_values</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.is_field_a_child" href="#xmodel.base.BaseStructure.is_field_a_child">is_field_a_child</a></code></li>
<li><code><a title="xmodel.base.BaseStructure.model_cls" href="#xmodel.base.BaseStructure.model_cls">model_cls</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>